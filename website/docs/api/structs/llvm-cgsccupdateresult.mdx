---

# DO NOT EDIT!
# Automatically generated via docusaurus-plugin-doxygen by Doxygen.

slug: /api/structs/llvm/cgsccupdateresult
custom_edit_url: null
keywords:
  - doxygen
  - reference
  - struct
toc_max_heading_level: 3

---

import CodeBlock from '@theme/CodeBlock'

import DoxygenPage from '@xpack/docusaurus-plugin-doxygen/components/DoxygenPage'
import IncludesList from '@xpack/docusaurus-plugin-doxygen/components/IncludesList'
import IncludesListItem from '@xpack/docusaurus-plugin-doxygen/components/IncludesListItem'
import MemberDefinition from '@xpack/docusaurus-plugin-doxygen/components/MemberDefinition'
import MembersIndex from '@xpack/docusaurus-plugin-doxygen/components/MembersIndex'
import MembersIndexItem from '@xpack/docusaurus-plugin-doxygen/components/MembersIndexItem'
import SectionDefinition from '@xpack/docusaurus-plugin-doxygen/components/SectionDefinition'

import pluginConfig from '@site/docusaurus-plugin-doxygen-config.json'

# The `CGSCCUpdateResult` Struct Reference

<DoxygenPage pluginConfig={pluginConfig}>

Support structure for SCC passes to communicate updates the call graph back to the CGSCC pass manager infrastructure. <a href="#details">More...</a>

## Declaration

<CodeBlock>struct llvm::CGSCCUpdateResult</CodeBlock>

## Included Headers

<IncludesList>
<IncludesListItem
  filePath="llvm/Analysis/CGSCCPassManager.h"
  permalink="/docs/api/files/include/include/llvm/include/llvm/analysis/cgsccpassmanager-h"
  isLocal="true" />
</IncludesList>

## Public Member Attributes Index

<MembersIndex>

<MembersIndexItem
  type={<><a href="/docs/api/classes/llvm/preservedanalyses">PreservedAnalyses</a></>}
  name={<><a href="#ac113dcaae09e52d6da7235e0757757f0">CrossSCCPA</a></>}>
Preserved analyses across SCCs. <a href="#ac113dcaae09e52d6da7235e0757757f0">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<><a href="/docs/api/classes/llvm/smallpriorityworklist">SmallPriorityWorklist</a>&lt; <a href="/docs/api/classes/llvm/lazycallgraph/scc">LazyCallGraph::SCC</a> &#42;, 1 &gt; &amp;</>}
  name={<><a href="#a277c9d45b3b20308e166249fd56598ed">CWorklist</a></>}>
Worklist of the SCCs queued for processing. <a href="#a277c9d45b3b20308e166249fd56598ed">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<><a href="/docs/api/classes/llvm/smallvector">SmallVector</a>&lt; <a href="/docs/api/classes/llvm/function">Function</a> &#42;, 4 &gt; &amp;</>}
  name={<><a href="#a53676888f06cf2212c0126db2e9cf9dd">DeadFunctions</a></>}>
Functions that a pass has considered to be dead to be removed at the end of the call graph walk in batch. <a href="#a53676888f06cf2212c0126db2e9cf9dd">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<><a href="/docs/api/structs/llvm/smallmapvector">SmallMapVector</a>&lt; <a href="/docs/api/classes/llvm/value">Value</a> &#42;, <a href="/docs/api/classes/llvm/weaktrackingvh">WeakTrackingVH</a>, 16 &gt;</>}
  name={<><a href="#a0a4386bac07827eaf6916d7da69a1cd4">IndirectVHs</a></>}>
Weak VHs to keep track of indirect calls for the purposes of detecting devirtualization. <a href="#a0a4386bac07827eaf6916d7da69a1cd4">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<><a href="/docs/api/classes/llvm/smalldenseset">SmallDenseSet</a>&lt; std::pair&lt; <a href="/docs/api/classes/llvm/lazycallgraph/node">LazyCallGraph::Node</a> &#42;, <a href="/docs/api/classes/llvm/lazycallgraph/scc">LazyCallGraph::SCC</a> &#42; &gt;, 4 &gt; &amp;</>}
  name={<><a href="#a500c2477bf6251954e52d6d9ef808e39">InlinedInternalEdges</a></>}>
A hacky area where the inliner can retain history about inlining decisions that mutated the call graph&#39;s SCC structure in order to avoid infinite inlining. <a href="#a500c2477bf6251954e52d6d9ef808e39">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<><a href="/docs/api/classes/llvm/smallptrsetimpl">SmallPtrSetImpl</a>&lt; <a href="/docs/api/classes/llvm/lazycallgraph/scc">LazyCallGraph::SCC</a> &#42; &gt; &amp;</>}
  name={<><a href="#a6822f3e4bf1d3a55c967bf74b7419704">InvalidatedSCCs</a></>}>
The set of invalidated SCCs which should be skipped if they are found in <code>CWorklist</code>. <a href="#a6822f3e4bf1d3a55c967bf74b7419704">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<><a href="/docs/api/classes/llvm/lazycallgraph/scc">LazyCallGraph::SCC</a> &#42;</>}
  name={<><a href="#ab4eb37646445da693553b9728143f31c">UpdatedC</a></>}>
If non-null, the updated current <code>SCC</code> being processed. <a href="#ab4eb37646445da693553b9728143f31c">More...</a>
</MembersIndexItem>

</MembersIndex>

## Description {#details}

Support structure for SCC passes to communicate updates the call graph back to the CGSCC pass manager infrastructure.

The CGSCC pass manager runs SCC passes which are allowed to update the call graph and SCC structures. This means the structure the pass manager works on is mutating underneath it. In order to support that, there needs to be careful communication about the precise nature and ramifications of these updates to the pass management infrastructure.

All SCC passes will have to accept a reference to the management layer&#39;s update result struct and use it to reflect the results of any CG updates performed.

Passes which do not change the call graph structure in any way can just ignore this argument to their run method.

Definition at line 231 of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/cgsccpassmanager-h">CGSCCPassManager.h</a>.

<SectionDefinition>

## Public Member Attributes

### CrossSCCPA {#ac113dcaae09e52d6da7235e0757757f0}

<MemberDefinition
  prototype="PreservedAnalyses llvm::CGSCCUpdateResult::CrossSCCPA">
Preserved analyses across SCCs.

We specifically want to allow CGSCC passes to mutate ancestor IR (changing both the CG structure and the function IR itself). However, this means we need to take special care to correctly mark what analyses are preserved <em>across</em> SCCs. We have to track this out-of-band here because within the main <code><a href="/docs/api/classes/llvm/passmanager">PassManager</a></code> infrastructure we need to mark everything within an SCC as preserved in order to avoid repeatedly invalidating the same analyses as we unnest pass managers and adaptors. So we track the cross-SCC version of the preserved analyses here from any code that does direct invalidation of SCC analyses, and then use it whenever we move forward in the post-order walk of SCCs before running passes over the new SCC.

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/cgsccpassmanager-h/#l00278">278</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/cgsccpassmanager-h">CGSCCPassManager.h</a>.
</MemberDefinition>

### CWorklist {#a277c9d45b3b20308e166249fd56598ed}

<MemberDefinition
  prototype={<>SmallPriorityWorklist&lt;LazyCallGraph::SCC &#42;, 1&gt;&amp; llvm::CGSCCUpdateResult::CWorklist</>}>
Worklist of the SCCs queued for processing.

When a pass refines the graph and creates new SCCs or causes them to have a different shape or set of component functions it should add the SCCs to this worklist so that we visit them in the refined form.

Note that if the SCCs are part of a RefSCC that is added to the <code>RCWorklist</code>, they don&#39;t need to be added here as visiting the RefSCC will be sufficient to re-visit the SCCs within it.

This worklist is in reverse post-order, as we pop off the back in order to observe SCCs in post-order. When adding SCCs, clients should add them in reverse post-order.

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/cgsccpassmanager-h/#l00245">245</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/cgsccpassmanager-h">CGSCCPassManager.h</a>.
</MemberDefinition>

### DeadFunctions {#a53676888f06cf2212c0126db2e9cf9dd}

<MemberDefinition
  prototype={<>SmallVector&lt;Function &#42;, 4&gt;&amp; llvm::CGSCCUpdateResult::DeadFunctions</>}>
Functions that a pass has considered to be dead to be removed at the end of the call graph walk in batch.

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/cgsccpassmanager-h/#l00291">291</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/cgsccpassmanager-h">CGSCCPassManager.h</a>.
</MemberDefinition>

### IndirectVHs {#a0a4386bac07827eaf6916d7da69a1cd4}

<MemberDefinition
  prototype={<>SmallMapVector&lt;Value &#42;, WeakTrackingVH, 16&gt; llvm::CGSCCUpdateResult::IndirectVHs</>}>
Weak VHs to keep track of indirect calls for the purposes of detecting devirtualization.

This is a map to avoid having duplicate entries. If a <a href="/docs/api/classes/llvm/value">Value</a> is deallocated, its corresponding <a href="/docs/api/classes/llvm/weaktrackingvh">WeakTrackingVH</a> will be nulled out. When checking if a <a href="/docs/api/classes/llvm/value">Value</a> is in the map or not, also check if the corresponding <a href="/docs/api/classes/llvm/weaktrackingvh">WeakTrackingVH</a> is null to avoid issues with a new <a href="/docs/api/classes/llvm/value">Value</a> sharing the same address as a deallocated one.

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/cgsccpassmanager-h/#l00301">301</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/cgsccpassmanager-h">CGSCCPassManager.h</a>.
</MemberDefinition>

### InlinedInternalEdges {#a500c2477bf6251954e52d6d9ef808e39}

<MemberDefinition
  prototype={<>SmallDenseSet&lt;std::pair&lt;LazyCallGraph::Node &#42;, LazyCallGraph::SCC &#42;&gt;, 4&gt;&amp; llvm::CGSCCUpdateResult::InlinedInternalEdges</>}>
A hacky area where the inliner can retain history about inlining decisions that mutated the call graph&#39;s SCC structure in order to avoid infinite inlining.

See the comments in the inliner&#39;s CG update logic.

FIXME: Keeping this here seems like a big layering issue, we should look for a better technique.

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/cgsccpassmanager-h/#l00287">287</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/cgsccpassmanager-h">CGSCCPassManager.h</a>.
</MemberDefinition>

### InvalidatedSCCs {#a6822f3e4bf1d3a55c967bf74b7419704}

<MemberDefinition
  prototype={<>SmallPtrSetImpl&lt;LazyCallGraph::SCC &#42;&gt;&amp; llvm::CGSCCUpdateResult::InvalidatedSCCs</>}>
The set of invalidated SCCs which should be skipped if they are found in <code>CWorklist</code>.

This is used to quickly prune out SCCs when they get deleted and happen to already be on the worklist. We use this primarily to avoid scanning the list and removing entries from it.

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/cgsccpassmanager-h/#l00253">253</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/cgsccpassmanager-h">CGSCCPassManager.h</a>.
</MemberDefinition>

### UpdatedC {#ab4eb37646445da693553b9728143f31c}

<MemberDefinition
  prototype={<>LazyCallGraph::SCC&#42; llvm::CGSCCUpdateResult::UpdatedC</>}>
If non-null, the updated current <code>SCC</code> being processed.

This is set when a graph refinement takes place and the &quot;current&quot; point in the graph moves &quot;down&quot; or earlier in the post-order walk. This will often cause the &quot;current&quot; SCC to be a newly created SCC object and the old one to be added to the above worklist. When that happens, this pointer is non-null and can be used to continue processing the &quot;top&quot; of the post-order walk.

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/cgsccpassmanager-h/#l00263">263</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/cgsccpassmanager-h">CGSCCPassManager.h</a>.
</MemberDefinition>

</SectionDefinition>

<hr/>

The documentation for this struct was generated from the following file:

<ul>
<li><a href="/docs/api/files/include/include/llvm/include/llvm/analysis/cgsccpassmanager-h">CGSCCPassManager.h</a></li>
</ul>

</DoxygenPage>
