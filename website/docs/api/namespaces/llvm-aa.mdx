---

# DO NOT EDIT!
# Automatically generated via docusaurus-plugin-doxygen by Doxygen.

slug: /api/namespaces/llvm/aa
custom_edit_url: null
keywords:
  - doxygen
  - reference
  - namespace

---

import Link from '@docusaurus/Link'
import CodeBlock from '@theme/CodeBlock'

import DoxygenPage from '@xpack/docusaurus-plugin-doxygen/components/DoxygenPage'
import EnumerationList from '@xpack/docusaurus-plugin-doxygen/components/EnumerationList'
import EnumerationListItem from '@xpack/docusaurus-plugin-doxygen/components/EnumerationListItem'
import MemberDefinition from '@xpack/docusaurus-plugin-doxygen/components/MemberDefinition'
import MembersIndex from '@xpack/docusaurus-plugin-doxygen/components/MembersIndex'
import MembersIndexItem from '@xpack/docusaurus-plugin-doxygen/components/MembersIndexItem'
import SectionDefinition from '@xpack/docusaurus-plugin-doxygen/components/SectionDefinition'
import SectionUser from '@xpack/docusaurus-plugin-doxygen/components/SectionUser'

import pluginConfig from '@site/docusaurus-plugin-doxygen-config.json'

# The `AA` Namespace Reference

<DoxygenPage pluginConfig={pluginConfig}>

Abstract <a href="/docs/api/classes/llvm/attribute">Attribute</a> helper functions. <a href="#details">More...</a>

## Definition

<CodeBlock>namespace llvm::AA &#123; ... &#125;</CodeBlock>

## Namespaces Index

<MembersIndex>

<MembersIndexItem
  type="namespace"
  name={<><a href="/docs/api/namespaces/llvm/aa/pointerinfo">llvm::AA::PointerInfo</a></>}>
</MembersIndexItem>

</MembersIndex>

## Classes Index

<MembersIndex>

<MembersIndexItem
  type="struct"
  name={<><a href="/docs/api/structs/llvm/aa/rangety">RangeTy</a></>}>
Helper to represent an access offset and size, with logic to deal with uncertainty and check for overlapping accesses. <a href="/docs/api/structs/llvm/aa/rangety/#details">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="struct"
  name={<><a href="/docs/api/structs/llvm/aa/valueandcontext">ValueAndContext</a></>}>
</MembersIndexItem>

</MembersIndex>

## Typedefs Index

<MembersIndex>

<MembersIndexItem
  type="using"
  name={<><a href="#ab7dc88f593d600ddcfe97fcbd6f15e43">InstExclusionSetTy</a> = <a href="/docs/api/classes/llvm/smallptrset">SmallPtrSet</a>&lt; <a href="/docs/api/classes/llvm/instruction">Instruction</a> &#42;, 4 &gt;</>}>
</MembersIndexItem>

</MembersIndex>

## Enumerations Index

<MembersIndex>

<MembersIndexItem
  type="enum class"
  name={<>: unsigned &#123; <a href="#a0ab72bc360a96141393d6ff9f1af7511">...</a> &#125;</>}>
</MembersIndexItem>

<MembersIndexItem
  type="enum"
  name={<>: uint8&#95;t &#123; <a href="#ac85851126814105f4a92b699293e4141">...</a> &#125;</>}>
Flags to distinguish intra-procedural queries from <em>potentially</em> inter-procedural queries. <a href="#ac85851126814105f4a92b699293e4141">More...</a>
</MembersIndexItem>

</MembersIndex>

## Operators Index

<MembersIndex>

<MembersIndexItem
  type="bool"
  name={<><a href="#a5f26e9da49fb529ebe03e31ba81d1ef8">operator!=</a> (const RangeTy &amp;A, const RangeTy &amp;B)</>}>
</MembersIndexItem>

<MembersIndexItem
  type={<><a href="/docs/api/classes/llvm/raw-ostream">raw&#95;ostream</a> &amp;</>}
  name={<><a href="#a1d9e6f3d4b50c7d8624851ed2ad7ff33">operator&lt;&lt;</a> (raw&#95;ostream &amp;OS, const RangeTy &amp;R)</>}>
</MembersIndexItem>

<MembersIndexItem
  type="bool"
  name={<><a href="#ac63dc1dd71c9173b497a2193dcc3f70c">operator==</a> (const RangeTy &amp;A, const RangeTy &amp;B)</>}>
</MembersIndexItem>

</MembersIndex>

## Functions Index

<MembersIndex>

<MembersIndexItem
  type={<>std::optional&lt; <a href="/docs/api/classes/llvm/value">Value</a> &#42; &gt;</>}
  name={<><a href="#a1e7aede47c97d1e610eeb8bdf152f4cc">combineOptionalValuesInAAValueLatice</a> (const std::optional&lt; Value &#42; &gt; &amp;A, const std::optional&lt; Value &#42; &gt; &amp;B, Type &#42;Ty)</>}>
Return the combination of <code>A</code> and <code>B</code> such that the result is a possible value of both. <a href="#a1e7aede47c97d1e610eeb8bdf152f4cc">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<><a href="/docs/api/classes/llvm/constant">Constant</a> &#42;</>}
  name={<><a href="#abdc024165477822f664fda55551f8a66">getInitialValueForObj</a> (Attributor &amp;A, const AbstractAttribute &amp;QueryingAA, Value &amp;Obj, Type &amp;Ty, const TargetLibraryInfo &#42;TLI, const DataLayout &amp;DL, RangeTy &#42;RangePtr=nullptr)</>}>
Return the initial value of <code>Obj</code> with type <code>Ty</code> if that is a constant. <a href="#abdc024165477822f664fda55551f8a66">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="bool"
  name={<><a href="#a5901858977a1ad4f47eb76f8491fadd8">getPotentialCopiesOfStoredValue</a> (Attributor &amp;A, StoreInst &amp;SI, SmallSetVector&lt; Value &#42;, 4 &gt; &amp;PotentialCopies, const AbstractAttribute &amp;QueryingAA, bool &amp;UsedAssumedInformation, bool OnlyExact=false)</>}>
Collect all potential values of the one stored by <code><a href="/docs/api/namespaces/llvm/si">SI</a></code> into <code>PotentialCopies</code>. <a href="#a5901858977a1ad4f47eb76f8491fadd8">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="bool"
  name={<><a href="#af30179a08c576d56d2469f5373174c43">getPotentiallyLoadedValues</a> (Attributor &amp;A, LoadInst &amp;LI, SmallSetVector&lt; Value &#42;, 4 &gt; &amp;PotentialValues, SmallSetVector&lt; Instruction &#42;, 4 &gt; &amp;PotentialValueOrigins, const AbstractAttribute &amp;QueryingAA, bool &amp;UsedAssumedInformation, bool OnlyExact=false)</>}>
Collect all potential values <code>LI</code> could read into <code>PotentialValues</code>. <a href="#af30179a08c576d56d2469f5373174c43">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<><a href="/docs/api/classes/llvm/value">Value</a> &#42;</>}
  name={<><a href="#af967a81762eaaf67f292abee4a00180c">getWithType</a> (Value &amp;V, Type &amp;Ty)</>}>
Try to convert <code>V</code> to type <code>Ty</code> without introducing new instructions. <a href="#af967a81762eaaf67f292abee4a00180c">More...</a>
</MembersIndexItem>

<MembersIndexItem
  template={<>template &lt;Attribute::AttrKind AK, typename AAType = AbstractAttribute&gt;</>}
  type="bool"
  name={<><a href="#ae8abeaeed2f11072b2d064fe70510e9f">hasAssumedIRAttr</a> (Attributor &amp;A, const AbstractAttribute &#42;QueryingAA, const IRPosition &amp;IRP, DepClassTy DepClass, bool &amp;IsKnown, bool IgnoreSubsumingPositions=false, const AAType &#42;&#42;AAPtr=nullptr)</>}>
Helper to avoid creating an <a href="/docs/api/namespaces/llvm/aa">AA</a> for IR Attributes that might already be set. <a href="#ae8abeaeed2f11072b2d064fe70510e9f">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="bool"
  name={<><a href="#a1496d1d7b408ea24a3c4d3c6d9a2d08c">isAssumedReadNone</a> (Attributor &amp;A, const IRPosition &amp;IRP, const AbstractAttribute &amp;QueryingAA, bool &amp;IsKnown)</>}>
Return true if <code>IRP</code> is readnone. <a href="#a1496d1d7b408ea24a3c4d3c6d9a2d08c">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="bool"
  name={<><a href="#a17d95a36815f9b2bb3441fd61ee328be">isAssumedReadOnly</a> (Attributor &amp;A, const IRPosition &amp;IRP, const AbstractAttribute &amp;QueryingAA, bool &amp;IsKnown)</>}>
Return true if <code>IRP</code> is readonly. <a href="#a17d95a36815f9b2bb3441fd61ee328be">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="bool"
  name={<><a href="#a1f2a3f39b7febd40285065a7ed05b71d">isAssumedThreadLocalObject</a> (Attributor &amp;A, Value &amp;Obj, const AbstractAttribute &amp;QueryingAA)</>}>
Return true if <code>Obj</code> is assumed to be a thread local object. <a href="#a1f2a3f39b7febd40285065a7ed05b71d">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="bool"
  name={<><a href="#a559168f78e20f2d3d0e1763ee6e751ef">isDynamicallyUnique</a> (Attributor &amp;A, const AbstractAttribute &amp;QueryingAA, const Value &amp;V, bool ForAnalysisOnly=true)</>}>
Return true if <code>V</code> is dynamically unique, that is, there are no two &quot;instances&quot; of <code>V</code> at runtime with different values. <a href="#a559168f78e20f2d3d0e1763ee6e751ef">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="bool"
  name={<><a href="#aba7baf8e2e8dff3bb7152c6ffeb52fb8">isGPU</a> (const Module &amp;M)</>}>
Return true iff <code>M</code> target a GPU (and we can use GPU AS reasoning). <a href="#aba7baf8e2e8dff3bb7152c6ffeb52fb8">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="bool"
  name={<><a href="#add4df090e923f2fe0dceeb0c60e5f74b">isNoSyncInst</a> (Attributor &amp;A, const Instruction &amp;I, const AbstractAttribute &amp;QueryingAA)</>}>
Return true if <code>I</code> is a <code>nosync</code> instruction. <a href="#add4df090e923f2fe0dceeb0c60e5f74b">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="bool"
  name={<><a href="#a9b9d4b530f90e36eede3c575ad1948ee">isPotentiallyAffectedByBarrier</a> (Attributor &amp;A, const Instruction &amp;I, const AbstractAttribute &amp;QueryingAA)</>}>
Return true if <code>I</code> is potentially affected by a barrier. <a href="#a9b9d4b530f90e36eede3c575ad1948ee">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="bool"
  name={<><a href="#a2517066083f5a59ca08c9724f8e727db">isPotentiallyAffectedByBarrier</a> (Attributor &amp;A, ArrayRef&lt; const Value &#42; &gt; Ptrs, const AbstractAttribute &amp;QueryingAA, const Instruction &#42;CtxI)</>}>
</MembersIndexItem>

<MembersIndexItem
  type="bool"
  name={<><a href="#adc52b79e64dcac96ea901cbfab1ccc52">isPotentiallyReachable</a> (Attributor &amp;A, const Instruction &amp;FromI, const Instruction &amp;ToI, const AbstractAttribute &amp;QueryingAA, const AA::InstExclusionSetTy &#42;ExclusionSet=nullptr, std::function&lt; bool(const Function &amp;F)&gt; GoBackwardsCB=nullptr)</>}>
Return true if <code>ToI</code> is potentially reachable from <code>FromI</code> without running into any instruction in <code>ExclusionSet</code> The two instructions do not need to be in the same function. <a href="#adc52b79e64dcac96ea901cbfab1ccc52">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="bool"
  name={<><a href="#a18d541007c596beba0b31031ce056669">isPotentiallyReachable</a> (Attributor &amp;A, const Instruction &amp;FromI, const Function &amp;ToFn, const AbstractAttribute &amp;QueryingAA, const AA::InstExclusionSetTy &#42;ExclusionSet=nullptr, std::function&lt; bool(const Function &amp;F)&gt; GoBackwardsCB=nullptr)</>}>
Same as above but it is sufficient to reach any instruction in <code>ToFn</code>. <a href="#a18d541007c596beba0b31031ce056669">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="bool"
  name={<><a href="#a1ec1a38ef077070bf9d3760ddbbcfe24">isValidAtPosition</a> (const ValueAndContext &amp;VAC, InformationCache &amp;InfoCache)</>}>
Return true if the value of <code>VAC</code> is a valid at the position of <code>VAC</code>, that is a constant, an argument of the same function, or an instruction in that function that dominates the position. <a href="#a1ec1a38ef077070bf9d3760ddbbcfe24">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="bool"
  name={<><a href="#ad7be59b8a3d5e2faf55b21c42ed07a63">isValidInScope</a> (const Value &amp;V, const Function &#42;Scope)</>}>
Return true if <code>V</code> is a valid value in <code>Scope</code>, that is a constant or an instruction/argument of <code>Scope</code>. <a href="#ad7be59b8a3d5e2faf55b21c42ed07a63">More...</a>
</MembersIndexItem>

</MembersIndex>

## Description {#details}

Abstract <a href="/docs/api/classes/llvm/attribute">Attribute</a> helper functions.

<SectionDefinition>

## Typedefs

### InstExclusionSetTy {#ab7dc88f593d600ddcfe97fcbd6f15e43}

<MemberDefinition
  prototype={<>using llvm::AA::InstExclusionSetTy =  SmallPtrSet&lt;Instruction &#42;, 4&gt;</>}>

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h/#l00164">164</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h">Attributor.h</a>.
</MemberDefinition>

</SectionDefinition>

<SectionDefinition>

## Enumerations

### enum class  {#a0ab72bc360a96141393d6ff9f1af7511}

<MemberDefinition
  prototype="enum class llvm::AA::GPUAddressSpace : unsigned"
 labels = {["strong"]}>

<EnumerationList title="Enumeration values">

<Link id="a0ab72bc360a96141393d6ff9f1af7511a8045a0a6c688b0635e3caccc408a1446" />
<EnumerationListItem name="Generic">
 (= 0)
</EnumerationListItem>

<Link id="a0ab72bc360a96141393d6ff9f1af7511a4cc6684df7b4a92b1dec6fce3264fac8" />
<EnumerationListItem name="Global">
 (= 1)
</EnumerationListItem>

<Link id="a0ab72bc360a96141393d6ff9f1af7511aa6156ea9d66fef24e87e841fbabf7cca" />
<EnumerationListItem name="Shared">
 (= 3)
</EnumerationListItem>

<Link id="a0ab72bc360a96141393d6ff9f1af7511acb17869fe51048b5a5c4c6106551a255" />
<EnumerationListItem name="Constant">
 (= 4)
</EnumerationListItem>

<Link id="a0ab72bc360a96141393d6ff9f1af7511a509820290d57f333403f490dde7316f4" />
<EnumerationListItem name="Local">
 (= 5)
</EnumerationListItem>

</EnumerationList>

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h/#l00166">166</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h">Attributor.h</a>.
</MemberDefinition>

### enum  {#ac85851126814105f4a92b699293e4141}

<MemberDefinition
  prototype={<>enum llvm::AA::ValueScope : uint8&#95;t</>}>
Flags to distinguish intra-procedural queries from <em>potentially</em> inter-procedural queries.

<EnumerationList title="Enumeration values">

<Link id="ac85851126814105f4a92b699293e4141a5c330ebe62fe7984f41ec28c822a869a" />
<EnumerationListItem name="Intraprocedural">
 (= 1)
</EnumerationListItem>

<Link id="ac85851126814105f4a92b699293e4141ab563ef74be13fcdcf264798ed6af5666" />
<EnumerationListItem name="Interprocedural">
 (= 2)
</EnumerationListItem>

<Link id="ac85851126814105f4a92b699293e4141aab418ed12d74fcdd3d6976b470bd2e66" />
<EnumerationListItem name="AnyScope">
 (= Intraprocedural | Interprocedural)
</EnumerationListItem>

</EnumerationList>

Not that information can be valid for both and therefore both bits might be set.

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h/#l00180">180</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h">Attributor.h</a>.
</MemberDefinition>

</SectionDefinition>

<SectionDefinition>

## Operators

### operator!=() {#a5f26e9da49fb529ebe03e31ba81d1ef8}

<MemberDefinition
  prototype={<>bool llvm::AA::operator!= (<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/structs/llvm/aa/rangety">RangeTy</a> &amp; A, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/structs/llvm/aa/rangety">RangeTy</a> &amp; B)</>}
  labels = {["inline"]}>

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h/#l00328">328</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h">Attributor.h</a>.
</MemberDefinition>

### operator&lt;&lt;() {#a1d9e6f3d4b50c7d8624851ed2ad7ff33}

<MemberDefinition
  prototype={<>raw&#95;ostream &amp; llvm::AA::operator&lt;&lt; (<a href="/docs/api/classes/llvm/raw-ostream">raw&#95;ostream</a> &amp; OS, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/structs/llvm/aa/rangety">RangeTy</a> &amp; R)</>}
  labels = {["inline"]}>

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h/#l00319">319</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h">Attributor.h</a>.
</MemberDefinition>

### operator==() {#ac63dc1dd71c9173b497a2193dcc3f70c}

<MemberDefinition
  prototype={<>bool llvm::AA::operator== (<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/structs/llvm/aa/rangety">RangeTy</a> &amp; A, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/structs/llvm/aa/rangety">RangeTy</a> &amp; B)</>}
  labels = {["inline"]}>

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h/#l00324">324</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h">Attributor.h</a>.
</MemberDefinition>

</SectionDefinition>

<SectionDefinition>

## Functions

### combineOptionalValuesInAAValueLatice() {#a1e7aede47c97d1e610eeb8bdf152f4cc}

<MemberDefinition
  prototype={<>std::optional&lt; Value &#42; &gt; llvm::AA::combineOptionalValuesInAAValueLatice (<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> std::optional&lt; <a href="/docs/api/classes/llvm/value">Value</a> &#42; &gt; &amp; A, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> std::optional&lt; <a href="/docs/api/classes/llvm/value">Value</a> &#42; &gt; &amp; B, <a href="/docs/api/classes/llvm/type">Type</a> &#42; Ty)</>}>
Return the combination of <code>A</code> and <code>B</code> such that the result is a possible value of both.

<code>B</code> is potentially casted to match the type <code>Ty</code> or the type of <code>A</code> if <code>Ty</code> is null.

Examples: X + none =&gt; X not&#95;none + undef =&gt; not&#95;none V1 + V2 =&gt; nullptr

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h/#l00232">232</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h">Attributor.h</a>, definition at line <a href="/docs/api/files/lib/lib/transforms/lib/transforms/ipo/attributor-cpp/#l00339">339</a> of file <a href="/docs/api/files/lib/lib/transforms/lib/transforms/ipo/attributor-cpp">Attributor.cpp</a>.
</MemberDefinition>

### getInitialValueForObj() {#abdc024165477822f664fda55551f8a66}

<MemberDefinition
  prototype={<>Constant &#42; llvm::AA::getInitialValueForObj (<a href="/docs/api/structs/llvm/attributor">Attributor</a> &amp; A, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/structs/llvm/abstractattribute">AbstractAttribute</a> &amp; QueryingAA, <a href="/docs/api/classes/llvm/value">Value</a> &amp; Obj, <a href="/docs/api/classes/llvm/type">Type</a> &amp; Ty, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/classes/llvm/targetlibraryinfo">TargetLibraryInfo</a> &#42; TLI, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/classes/llvm/datalayout">DataLayout</a> &amp; DL, <a href="/docs/api/structs/llvm/aa/rangety">RangeTy</a> &#42; RangePtr=nullptr)</>}>
Return the initial value of <code>Obj</code> with type <code>Ty</code> if that is a constant.

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h/#l00331">331</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h">Attributor.h</a>, definition at line <a href="/docs/api/files/lib/lib/transforms/lib/transforms/ipo/attributor-cpp/#l00242">242</a> of file <a href="/docs/api/files/lib/lib/transforms/lib/transforms/ipo/attributor-cpp">Attributor.cpp</a>.
</MemberDefinition>

### getPotentialCopiesOfStoredValue() {#a5901858977a1ad4f47eb76f8491fadd8}

<MemberDefinition
  prototype={<>bool llvm::AA::getPotentialCopiesOfStoredValue (<a href="/docs/api/structs/llvm/attributor">Attributor</a> &amp; A, <a href="/docs/api/classes/llvm/storeinst">StoreInst</a> &amp; SI, <a href="/docs/api/classes/llvm/smallsetvector">SmallSetVector</a>&lt; <a href="/docs/api/classes/llvm/value">Value</a> &#42;, 4 &gt; &amp; PotentialCopies, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/structs/llvm/abstractattribute">AbstractAttribute</a> &amp; QueryingAA, bool &amp; UsedAssumedInformation, bool OnlyExact=false)</>}>
Collect all potential values of the one stored by <code><a href="/docs/api/namespaces/llvm/si">SI</a></code> into <code>PotentialCopies</code>.

That is, the only copies that were made via the store are assumed to be known and all are in <code>PotentialCopies</code>. Dependences onto <code>QueryingAA</code> are properly tracked, <code>UsedAssumedInformation</code> will inform the caller if assumed information was used.


<SectionUser title="Returns">
True if the assumed potential copies are all in <code>PotentialCopies</code>, false if something went wrong and the copies could not be determined.
</SectionUser>

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h/#l00363">363</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h">Attributor.h</a>, definition at line <a href="/docs/api/files/lib/lib/transforms/lib/transforms/ipo/attributor-cpp/#l00599">599</a> of file <a href="/docs/api/files/lib/lib/transforms/lib/transforms/ipo/attributor-cpp">Attributor.cpp</a>.
</MemberDefinition>

### getPotentiallyLoadedValues() {#af30179a08c576d56d2469f5373174c43}

<MemberDefinition
  prototype={<>bool llvm::AA::getPotentiallyLoadedValues (<a href="/docs/api/structs/llvm/attributor">Attributor</a> &amp; A, <a href="/docs/api/classes/llvm/loadinst">LoadInst</a> &amp; LI, <a href="/docs/api/classes/llvm/smallsetvector">SmallSetVector</a>&lt; <a href="/docs/api/classes/llvm/value">Value</a> &#42;, 4 &gt; &amp; PotentialValues, <a href="/docs/api/classes/llvm/smallsetvector">SmallSetVector</a>&lt; <a href="/docs/api/classes/llvm/instruction">Instruction</a> &#42;, 4 &gt; &amp; PotentialValueOrigins, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/structs/llvm/abstractattribute">AbstractAttribute</a> &amp; QueryingAA, bool &amp; UsedAssumedInformation, bool OnlyExact=false)</>}>
Collect all potential values <code>LI</code> could read into <code>PotentialValues</code>.

That is, the only values read by <code>LI</code> are assumed to be known and all are in <code>PotentialValues</code>. <code>PotentialValueOrigins</code> will contain all the instructions that might have put a potential value into <code>PotentialValues</code>. Dependences onto <code>QueryingAA</code> are properly tracked, <code>UsedAssumedInformation</code> will inform the caller if assumed information was used.


<SectionUser title="Returns">
True if the assumed potential copies are all in <code>PotentialValues</code>, false if something went wrong and the copies could not be determined.
</SectionUser>

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h/#l00348">348</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h">Attributor.h</a>, definition at line <a href="/docs/api/files/lib/lib/transforms/lib/transforms/ipo/attributor-cpp/#l00589">589</a> of file <a href="/docs/api/files/lib/lib/transforms/lib/transforms/ipo/attributor-cpp">Attributor.cpp</a>.
</MemberDefinition>

### getWithType() {#af967a81762eaaf67f292abee4a00180c}

<MemberDefinition
  prototype={<>Value &#42; llvm::AA::getWithType (<a href="/docs/api/classes/llvm/value">Value</a> &amp; V, <a href="/docs/api/classes/llvm/type">Type</a> &amp; Ty)</>}>
Try to convert <code>V</code> to type <code>Ty</code> without introducing new instructions.

If this is not possible return <code>nullptr</code>. Note: this function basically knows how to cast various constants.

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h/#l00221">221</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h">Attributor.h</a>, definition at line <a href="/docs/api/files/lib/lib/transforms/lib/transforms/ipo/attributor-cpp/#l00316">316</a> of file <a href="/docs/api/files/lib/lib/transforms/lib/transforms/ipo/attributor-cpp">Attributor.cpp</a>.
</MemberDefinition>

### hasAssumedIRAttr() {#ae8abeaeed2f11072b2d064fe70510e9f}

<MemberDefinition
  template={<>template &lt;Attribute::AttrKind AK, typename AAType = AbstractAttribute&gt;</>}
  prototype={<>bool llvm::AA::hasAssumedIRAttr (<a href="/docs/api/structs/llvm/attributor">Attributor</a> &amp; A, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/structs/llvm/abstractattribute">AbstractAttribute</a> &#42; QueryingAA, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/structs/llvm/irposition">IRPosition</a> &amp; IRP, <a href="/docs/api/namespaces/llvm/#adadcb655edca867f08f7ea6068a7d8a1">DepClassTy</a> DepClass, bool &amp; IsKnown, bool IgnoreSubsumingPositions=false, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> AAType &#42;&#42; AAPtr=nullptr)</>}>
Helper to avoid creating an <a href="/docs/api/namespaces/llvm/aa">AA</a> for IR Attributes that might already be set.

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h/#l06493">6493</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h">Attributor.h</a>.
</MemberDefinition>

### isAssumedReadNone() {#a1496d1d7b408ea24a3c4d3c6d9a2d08c}

<MemberDefinition
  prototype={<>bool llvm::AA::isAssumedReadNone (<a href="/docs/api/structs/llvm/attributor">Attributor</a> &amp; A, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/structs/llvm/irposition">IRPosition</a> &amp; IRP, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/structs/llvm/abstractattribute">AbstractAttribute</a> &amp; QueryingAA, bool &amp; IsKnown)</>}>
Return true if <code>IRP</code> is readnone.

This will query respective AAs that deduce the information and introduce dependences for <code>QueryingAA</code>.

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h/#l00375">375</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h">Attributor.h</a>, definition at line <a href="/docs/api/files/lib/lib/transforms/lib/transforms/ipo/attributor-cpp/#l00653">653</a> of file <a href="/docs/api/files/lib/lib/transforms/lib/transforms/ipo/attributor-cpp">Attributor.cpp</a>.
</MemberDefinition>

### isAssumedReadOnly() {#a17d95a36815f9b2bb3441fd61ee328be}

<MemberDefinition
  prototype={<>bool llvm::AA::isAssumedReadOnly (<a href="/docs/api/structs/llvm/attributor">Attributor</a> &amp; A, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/structs/llvm/irposition">IRPosition</a> &amp; IRP, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/structs/llvm/abstractattribute">AbstractAttribute</a> &amp; QueryingAA, bool &amp; IsKnown)</>}>
Return true if <code>IRP</code> is readonly.

This will query respective AAs that deduce the information and introduce dependences for <code>QueryingAA</code>.

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h/#l00370">370</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h">Attributor.h</a>, definition at line <a href="/docs/api/files/lib/lib/transforms/lib/transforms/ipo/attributor-cpp/#l00648">648</a> of file <a href="/docs/api/files/lib/lib/transforms/lib/transforms/ipo/attributor-cpp">Attributor.cpp</a>.
</MemberDefinition>

### isAssumedThreadLocalObject() {#a1f2a3f39b7febd40285065a7ed05b71d}

<MemberDefinition
  prototype={<>bool llvm::AA::isAssumedThreadLocalObject (<a href="/docs/api/structs/llvm/attributor">Attributor</a> &amp; A, <a href="/docs/api/classes/llvm/value">Value</a> &amp; Obj, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/structs/llvm/abstractattribute">AbstractAttribute</a> &amp; QueryingAA)</>}>
Return true if <code>Obj</code> is assumed to be a thread local object.

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h/#l00400">400</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h">Attributor.h</a>, definition at line <a href="/docs/api/files/lib/lib/transforms/lib/transforms/ipo/attributor-cpp/#l00835">835</a> of file <a href="/docs/api/files/lib/lib/transforms/lib/transforms/ipo/attributor-cpp">Attributor.cpp</a>.
</MemberDefinition>

### isDynamicallyUnique() {#a559168f78e20f2d3d0e1763ee6e751ef}

<MemberDefinition
  prototype={<>bool llvm::AA::isDynamicallyUnique (<a href="/docs/api/structs/llvm/attributor">Attributor</a> &amp; A, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/structs/llvm/abstractattribute">AbstractAttribute</a> &amp; QueryingAA, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/classes/llvm/value">Value</a> &amp; V, bool ForAnalysisOnly=<a href="/docs/api/files/lib/lib/analysis/basicaliasanalysis-cpp/#af6d5cafbdfc5313e65d990120021a3ec">true</a>)</>}>
Return true if <code>V</code> is dynamically unique, that is, there are no two &quot;instances&quot; of <code>V</code> at runtime with different values.

Note: If <code>ForAnalysisOnly</code> is set we only check that the <a href="/docs/api/structs/llvm/attributor">Attributor</a> will never use <code>V</code> to represent two &quot;instances&quot; not that <code>V</code> could not technically represent them.

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h/#l00206">206</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h">Attributor.h</a>, definition at line <a href="/docs/api/files/lib/lib/transforms/lib/transforms/ipo/attributor-cpp/#l00231">231</a> of file <a href="/docs/api/files/lib/lib/transforms/lib/transforms/ipo/attributor-cpp">Attributor.cpp</a>.
</MemberDefinition>

### isGPU() {#aba7baf8e2e8dff3bb7152c6ffeb52fb8}

<MemberDefinition
  prototype={<>bool llvm::AA::isGPU (<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/classes/llvm/module">Module</a> &amp; M)</>}>
Return true iff <code>M</code> target a GPU (and we can use GPU AS reasoning).

&#125;

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h/#l00175">175</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h">Attributor.h</a>, definition at line <a href="/docs/api/files/lib/lib/transforms/lib/transforms/ipo/attributor-cpp/#l00200">200</a> of file <a href="/docs/api/files/lib/lib/transforms/lib/transforms/ipo/attributor-cpp">Attributor.cpp</a>.
</MemberDefinition>

### isNoSyncInst() {#add4df090e923f2fe0dceeb0c60e5f74b}

<MemberDefinition
  prototype={<>bool llvm::AA::isNoSyncInst (<a href="/docs/api/structs/llvm/attributor">Attributor</a> &amp; A, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/classes/llvm/instruction">Instruction</a> &amp; I, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/structs/llvm/abstractattribute">AbstractAttribute</a> &amp; QueryingAA)</>}>
Return true if <code>I</code> is a <code>nosync</code> instruction.

<a href="/docs/api/classes/llvm/use">Use</a> generic reasoning and potentially the corresponding <a href="/docs/api/structs/llvm/aanosync">AANoSync</a>.

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h/#l00198">198</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h">Attributor.h</a>, definition at line <a href="/docs/api/files/lib/lib/transforms/lib/transforms/ipo/attributor-cpp/#l00205">205</a> of file <a href="/docs/api/files/lib/lib/transforms/lib/transforms/ipo/attributor-cpp">Attributor.cpp</a>.
</MemberDefinition>

### isPotentiallyAffectedByBarrier() {#a9b9d4b530f90e36eede3c575ad1948ee}

<MemberDefinition
  prototype={<>bool llvm::AA::isPotentiallyAffectedByBarrier (<a href="/docs/api/structs/llvm/attributor">Attributor</a> &amp; A, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/classes/llvm/instruction">Instruction</a> &amp; I, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/structs/llvm/abstractattribute">AbstractAttribute</a> &amp; QueryingAA)</>}>
Return true if <code>I</code> is potentially affected by a barrier.

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h/#l00404">404</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h">Attributor.h</a>, definition at line <a href="/docs/api/files/lib/lib/transforms/lib/transforms/ipo/attributor-cpp/#l00889">889</a> of file <a href="/docs/api/files/lib/lib/transforms/lib/transforms/ipo/attributor-cpp">Attributor.cpp</a>.
</MemberDefinition>

### isPotentiallyAffectedByBarrier() {#a2517066083f5a59ca08c9724f8e727db}

<MemberDefinition
  prototype={<>bool llvm::AA::isPotentiallyAffectedByBarrier (<a href="/docs/api/structs/llvm/attributor">Attributor</a> &amp; A, <a href="/docs/api/classes/llvm/arrayref">ArrayRef</a>&lt; <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/classes/llvm/value">Value</a> &#42; &gt; Ptrs, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/structs/llvm/abstractattribute">AbstractAttribute</a> &amp; QueryingAA, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/classes/llvm/instruction">Instruction</a> &#42; CtxI)</>}>

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h/#l00406">406</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h">Attributor.h</a>, definition at line <a href="/docs/api/files/lib/lib/transforms/lib/transforms/ipo/attributor-cpp/#l00918">918</a> of file <a href="/docs/api/files/lib/lib/transforms/lib/transforms/ipo/attributor-cpp">Attributor.cpp</a>.
</MemberDefinition>

### isPotentiallyReachable() {#adc52b79e64dcac96ea901cbfab1ccc52}

<MemberDefinition
  prototype={<>bool llvm::AA::isPotentiallyReachable (<a href="/docs/api/structs/llvm/attributor">Attributor</a> &amp; A, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/classes/llvm/instruction">Instruction</a> &amp; FromI, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/classes/llvm/instruction">Instruction</a> &amp; ToI, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/structs/llvm/abstractattribute">AbstractAttribute</a> &amp; QueryingAA, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="#ab7dc88f593d600ddcfe97fcbd6f15e43">AA::InstExclusionSetTy</a> &#42; ExclusionSet=nullptr, std::function&lt; bool(<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/classes/llvm/function">Function</a> &amp;<a href="/docs/api/files/lib/lib/support/md5-cpp/#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a>)&gt; GoBackwardsCB=nullptr)</>}>
Return true if <code>ToI</code> is potentially reachable from <code>FromI</code> without running into any instruction in <code>ExclusionSet</code> The two instructions do not need to be in the same function.

<code>GoBackwardsCB</code> can be provided to convey domain knowledge about the &quot;lifespan&quot; the user is interested in. By default, the callers of <code>FromI</code> are checked as well to determine if <code>ToI</code> can be reached. If the query is not interested in callers beyond a certain point, e.g., a GPU kernel entry or the function containing an alloca, the <code>GoBackwardsCB</code> should return false.

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h/#l00386">386</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h">Attributor.h</a>, definition at line <a href="/docs/api/files/lib/lib/transforms/lib/transforms/ipo/attributor-cpp/#l00816">816</a> of file <a href="/docs/api/files/lib/lib/transforms/lib/transforms/ipo/attributor-cpp">Attributor.cpp</a>.
</MemberDefinition>

### isPotentiallyReachable() {#a18d541007c596beba0b31031ce056669}

<MemberDefinition
  prototype={<>bool llvm::AA::isPotentiallyReachable (<a href="/docs/api/structs/llvm/attributor">Attributor</a> &amp; A, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/classes/llvm/instruction">Instruction</a> &amp; FromI, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/classes/llvm/function">Function</a> &amp; ToFn, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/structs/llvm/abstractattribute">AbstractAttribute</a> &amp; QueryingAA, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="#ab7dc88f593d600ddcfe97fcbd6f15e43">AA::InstExclusionSetTy</a> &#42; ExclusionSet=nullptr, std::function&lt; bool(<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/classes/llvm/function">Function</a> &amp;<a href="/docs/api/files/lib/lib/support/md5-cpp/#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a>)&gt; GoBackwardsCB=nullptr)</>}>
Same as above but it is sufficient to reach any instruction in <code>ToFn</code>.

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h/#l00393">393</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h">Attributor.h</a>, definition at line <a href="/docs/api/files/lib/lib/transforms/lib/transforms/ipo/attributor-cpp/#l00826">826</a> of file <a href="/docs/api/files/lib/lib/transforms/lib/transforms/ipo/attributor-cpp">Attributor.cpp</a>.
</MemberDefinition>

### isValidAtPosition() {#a1ec1a38ef077070bf9d3760ddbbcfe24}

<MemberDefinition
  prototype={<>bool llvm::AA::isValidAtPosition (<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/structs/llvm/aa/valueandcontext">ValueAndContext</a> &amp; VAC, <a href="/docs/api/structs/llvm/informationcache">InformationCache</a> &amp; InfoCache)</>}>
Return true if the value of <code>VAC</code> is a valid at the position of <code>VAC</code>, that is a constant, an argument of the same function, or an instruction in that function that dominates the position.

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h/#l00216">216</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h">Attributor.h</a>, definition at line <a href="/docs/api/files/lib/lib/transforms/lib/transforms/ipo/attributor-cpp/#l00290">290</a> of file <a href="/docs/api/files/lib/lib/transforms/lib/transforms/ipo/attributor-cpp">Attributor.cpp</a>.
</MemberDefinition>

### isValidInScope() {#ad7be59b8a3d5e2faf55b21c42ed07a63}

<MemberDefinition
  prototype={<>bool llvm::AA::isValidInScope (<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/classes/llvm/value">Value</a> &amp; V, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/classes/llvm/function">Function</a> &#42; Scope)</>}>
Return true if <code>V</code> is a valid value in <code>Scope</code>, that is a constant or an instruction/argument of <code>Scope</code>.

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h/#l00211">211</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h">Attributor.h</a>, definition at line <a href="/docs/api/files/lib/lib/transforms/lib/transforms/ipo/attributor-cpp/#l00280">280</a> of file <a href="/docs/api/files/lib/lib/transforms/lib/transforms/ipo/attributor-cpp">Attributor.cpp</a>.
</MemberDefinition>

</SectionDefinition>

<hr/>

The documentation for this namespace was generated from the following files:

<ul>
<li><a href="/docs/api/files/include/include/llvm/include/llvm/transforms/include/llvm/transforms/ipo/attributor-h">Attributor.h</a></li>
<li><a href="/docs/api/files/lib/lib/transforms/lib/transforms/ipo/attributor-cpp">Attributor.cpp</a></li>
</ul>

</DoxygenPage>
