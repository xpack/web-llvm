---

# DO NOT EDIT!
# Automatically generated via docusaurus-plugin-doxygen by Doxygen.

slug: /api/classes/llvm/lazycallgraph/refscc
custom_edit_url: null
keywords:
  - doxygen
  - reference
  - class
toc_max_heading_level: 3

---

import CodeBlock from '@theme/CodeBlock'

import DoxygenPage from '@xpack/docusaurus-plugin-doxygen/components/DoxygenPage'
import IncludesList from '@xpack/docusaurus-plugin-doxygen/components/IncludesList'
import IncludesListItem from '@xpack/docusaurus-plugin-doxygen/components/IncludesListItem'
import MemberDefinition from '@xpack/docusaurus-plugin-doxygen/components/MemberDefinition'
import MembersIndex from '@xpack/docusaurus-plugin-doxygen/components/MembersIndex'
import MembersIndexItem from '@xpack/docusaurus-plugin-doxygen/components/MembersIndexItem'
import SectionDefinition from '@xpack/docusaurus-plugin-doxygen/components/SectionDefinition'

import pluginConfig from '@site/docusaurus-plugin-doxygen-config.json'

# The `RefSCC` Class Reference

<DoxygenPage pluginConfig={pluginConfig}>

A <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> of the call graph. <a href="#details">More...</a>

## Declaration

<CodeBlock>class llvm::LazyCallGraph::RefSCC</CodeBlock>

## Included Headers

<IncludesList>
<IncludesListItem
  filePath="llvm/Analysis/LazyCallGraph.h"
  permalink="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h"
  isLocal="true" />
</IncludesList>

## Public Member Typedefs Index

<MembersIndex>

<MembersIndexItem
  type="using"
  name={<><a href="#ad85b2ad566b56110886f3c39653b88fa">iterator</a> = <a href="/docs/api/structs/llvm/pointee-iterator">pointee&#95;iterator</a>&lt; <a href="/docs/api/classes/llvm/smallvectorimpl">SmallVectorImpl</a>&lt; <a href="/docs/api/classes/llvm/lazycallgraph/scc">SCC</a> &#42; &gt;::const&#95;iterator &gt;</>}>
</MembersIndexItem>

<MembersIndexItem
  type="using"
  name={<><a href="#ad8fea2aaa35fad7cf415558c8b753288">parent&#95;iterator</a> = <a href="/docs/api/structs/llvm/pointee-iterator">pointee&#95;iterator</a>&lt; <a href="/docs/api/classes/llvm/smallptrsetimpl">SmallPtrSetImpl</a>&lt; <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> &#42; &gt;::const&#95;iterator &gt;</>}>
</MembersIndexItem>

<MembersIndexItem
  type="using"
  name={<><a href="#a69b7350ecfd665c8008e5a47c6734c87">range</a> = <a href="/docs/api/classes/llvm/iterator-range">iterator&#95;range</a>&lt; <a href="#ad85b2ad566b56110886f3c39653b88fa">iterator</a> &gt;</>}>
</MembersIndexItem>

</MembersIndex>

## Friends Index

<MembersIndex>

<MembersIndexItem
  type="class"
  name={<><a href="#a81774ea46253e6427d63a610bd624c08">LazyCallGraph</a></>}>
</MembersIndexItem>

<MembersIndexItem
  type="class"
  name={<><a href="#a3a7a57d977301c68294ee8d4c92543ce">LazyCallGraph::Node</a></>}>
</MembersIndexItem>

<MembersIndexItem
  type={<><a href="/docs/api/classes/llvm/raw-ostream">raw&#95;ostream</a> &amp;</>}
  name={<><a href="#ae06c7c08f7da5bc7d384c81be0b83910">operator&lt;&lt;</a></>}>
Print a short description useful for debugging or logging. <a href="#ae06c7c08f7da5bc7d384c81be0b83910">More...</a>
</MembersIndexItem>

</MembersIndex>

## Private Constructors Index

<MembersIndex>

<MembersIndexItem
  name={<><a href="#ab5fb8a48f9e09ffb93f285d7e121af7d">RefSCC</a> (LazyCallGraph &amp;G)</>}>
Fast-path constructor. <a href="#ab5fb8a48f9e09ffb93f285d7e121af7d">More...</a>
</MembersIndexItem>

</MembersIndex>

## Public Operators Index

<MembersIndex>

<MembersIndexItem
  type={<><a href="/docs/api/classes/llvm/lazycallgraph/scc">SCC</a> &amp;</>}
  name={<><a href="#a571517d23e9e5252dc87f5c23e7105f2">operator&#91;&#93;</a> (int Idx)</>}>
</MembersIndexItem>

</MembersIndex>

## Public Member Functions Index

<MembersIndex>

<MembersIndexItem
  type={<><a href="#ad85b2ad566b56110886f3c39653b88fa">iterator</a></>}
  name={<><a href="#acc4aeec51553504ba50594d9fb8ac4b1">begin</a> () const</>}>
</MembersIndexItem>

<MembersIndexItem
  type={<><a href="#ad85b2ad566b56110886f3c39653b88fa">iterator</a></>}
  name={<><a href="#acbbe8357e4c4fef5f9b7809b41abcdcd">end</a> () const</>}>
</MembersIndexItem>

<MembersIndexItem
  type={<><a href="#ad85b2ad566b56110886f3c39653b88fa">iterator</a></>}
  name={<><a href="#a51f7db86dd464b937f03aab0fbf51506">find</a> (SCC &amp;C) const</>}>
</MembersIndexItem>

<MembersIndexItem
  type="std::string"
  name={<><a href="#ac30dc61a31f34e7359336fa637104bfb">getName</a> () const</>}>
Provide a short name by printing this <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> to a std::string. <a href="#ac30dc61a31f34e7359336fa637104bfb">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="bool"
  name={<><a href="#a35a8d25c6df3f1d3bc5faba32de1dd55">isAncestorOf</a> (const RefSCC &amp;RC) const</>}>
Test if this <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> is an ancestor of <em>RC</em>. <a href="#a35a8d25c6df3f1d3bc5faba32de1dd55">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="bool"
  name={<><a href="#a5c04e8da471c500d025dfdf206c24ed2">isChildOf</a> (const RefSCC &amp;RC) const</>}>
Test if this <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> is a child of <em>RC</em>. <a href="#a5c04e8da471c500d025dfdf206c24ed2">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="bool"
  name={<><a href="#a59f6c7fa7f420326cc1f7026e51b0668">isDescendantOf</a> (const RefSCC &amp;RC) const</>}>
Test if this <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> is a descendant of <em>RC</em>. <a href="#a59f6c7fa7f420326cc1f7026e51b0668">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="bool"
  name={<><a href="#af952e1ffaf5cd4bd83b63cf7fb4cb068">isParentOf</a> (const RefSCC &amp;RC) const</>}>
Test if this <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> is a parent of <em>RC</em>. <a href="#af952e1ffaf5cd4bd83b63cf7fb4cb068">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<>ssize&#95;t</>}
  name={<><a href="#ac62cb27d2f0946c9febb1e1d1e377f55">size</a> () const</>}>
</MembersIndexItem>

</MembersIndex>

## Private Member Functions Index

<MembersIndex>

<MembersIndexItem
  type="void"
  name={<><a href="#ab484ec648a8540467efe37c71d1531ff">clear</a> ()</>}>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#a21ed0a8438a4d6b61af5c4832b4d0124">dump</a> () const</>}>
Dump a short description of this <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> to stderr. <a href="#a21ed0a8438a4d6b61af5c4832b4d0124">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#a992480861cbbf2f720a27e2b56700682">verify</a> ()</>}>
Verify invariants about the <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> and all its SCCs. <a href="#a992480861cbbf2f720a27e2b56700682">More...</a>
</MembersIndexItem>

</MembersIndex>

## Private Member Attributes Index

<MembersIndex>

<MembersIndexItem
  type={<><a href="/docs/api/classes/llvm/lazycallgraph">LazyCallGraph</a> &#42;</>}
  name={<><a href="#a258d60676d3507f4371f54614265c4c5">G</a></>}>
</MembersIndexItem>

<MembersIndexItem
  type={<><a href="/docs/api/classes/llvm/smalldensemap">SmallDenseMap</a>&lt; <a href="/docs/api/classes/llvm/lazycallgraph/scc">SCC</a> &#42;, int, 4 &gt;</>}
  name={<><a href="#ae2e66513096a8568624f8bb6177df0df">SCCIndices</a></>}>
A map from <a href="/docs/api/classes/llvm/lazycallgraph/scc">SCC</a> to index in the postorder list. <a href="#ae2e66513096a8568624f8bb6177df0df">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<><a href="/docs/api/classes/llvm/smallvector">SmallVector</a>&lt; <a href="/docs/api/classes/llvm/lazycallgraph/scc">SCC</a> &#42;, 4 &gt;</>}
  name={<><a href="#a64f45fde9dbe447ac0e25a3c83bd00bf">SCCs</a></>}>
A postorder list of the inner SCCs. <a href="#a64f45fde9dbe447ac0e25a3c83bd00bf">More...</a>
</MembersIndexItem>

</MembersIndex>

## Mutation API Index

<MembersIndex>

<MembersIndexItem
  type={<><a href="/docs/api/classes/llvm/smallvector">SmallVector</a>&lt; <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> &#42;, 1 &gt;</>}
  name={<><a href="#a01b1581633bb40f86d6dc62a1c1a7f72">insertIncomingRefEdge</a> (Node &amp;SourceN, Node &amp;TargetN)</>}>
Insert an edge whose source is in a descendant <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> and target is in this <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a>. <a href="#a01b1581633bb40f86d6dc62a1c1a7f72">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#aa57986c798b44affab5e4d5953e37727">insertInternalRefEdge</a> (Node &amp;SourceN, Node &amp;TargetN)</>}>
Insert a ref edge from one node in this <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> to another in this <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a>. <a href="#aa57986c798b44affab5e4d5953e37727">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#a743c2ac21f2f8a8c6af18e1e09f13229">insertOutgoingEdge</a> (Node &amp;SourceN, Node &amp;TargetN, Edge::Kind EK)</>}>
Insert an edge whose parent is in this <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> and child is in some child <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a>. <a href="#a743c2ac21f2f8a8c6af18e1e09f13229">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#aaf3ba7d78f09755223609e4978bebef7">insertTrivialCallEdge</a> (Node &amp;SourceN, Node &amp;TargetN)</>}>
A convenience wrapper around the above to handle trivial cases of inserting a new call edge. <a href="#aaf3ba7d78f09755223609e4978bebef7">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#a393b4565f554b9d8382c8f610b7f2ce7">insertTrivialRefEdge</a> (Node &amp;SourceN, Node &amp;TargetN)</>}>
A convenience wrapper around the above to handle trivial cases of inserting a new ref edge. <a href="#a393b4565f554b9d8382c8f610b7f2ce7">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<><a href="/docs/api/classes/llvm/smallvector">SmallVector</a>&lt; <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> &#42;, 1 &gt;</>}
  name={<><a href="#a87dd1a69c8d8492e78b32708ceacb2c6">removeInternalRefEdges</a> (ArrayRef&lt; std::pair&lt; Node &#42;, Node &#42; &gt; &gt; Edges)</>}>
Remove a list of ref edges which are entirely within this <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a>. <a href="#a87dd1a69c8d8492e78b32708ceacb2c6">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#ab130250bcdaefbfd3c583cad7b120b62">removeOutgoingEdge</a> (Node &amp;SourceN, Node &amp;TargetN)</>}>
Remove an edge whose source is in this <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> and target is <em>not</em>. <a href="#ab130250bcdaefbfd3c583cad7b120b62">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#a70f7f0574edbfc0f75424499133d4ba3">replaceNodeFunction</a> (Node &amp;N, Function &amp;NewF)</>}>
Directly replace a node&#39;s function with a new function. <a href="#a70f7f0574edbfc0f75424499133d4ba3">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="bool"
  name={<><a href="#a2957918db7f91f405b11d92c1ebf3b0f">switchInternalEdgeToCall</a> (Node &amp;SourceN, Node &amp;TargetN, function&#95;ref&lt; void(ArrayRef&lt; SCC &#42; &gt; MergedSCCs)&gt; MergeCB=&#123;&#125;)</>}>
Make an existing internal ref edge into a call edge. <a href="#a2957918db7f91f405b11d92c1ebf3b0f">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<><a href="/docs/api/classes/llvm/iterator-range">iterator&#95;range</a>&lt; <a href="#ad85b2ad566b56110886f3c39653b88fa">iterator</a> &gt;</>}
  name={<><a href="#a96fe0cb15ded58bd1824fa4e3daec680">switchInternalEdgeToRef</a> (Node &amp;SourceN, Node &amp;TargetN)</>}>
Make an existing internal call edge within a single <a href="/docs/api/classes/llvm/lazycallgraph/scc">SCC</a> into a ref edge. <a href="#a96fe0cb15ded58bd1824fa4e3daec680">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#a5cc0541c3ee15c565ac05fe11f5459d2">switchOutgoingEdgeToCall</a> (Node &amp;SourceN, Node &amp;TargetN)</>}>
Make an existing outgoing ref edge into a call edge. <a href="#a5cc0541c3ee15c565ac05fe11f5459d2">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#adce8df277d53b4d87581583c8269ac71">switchOutgoingEdgeToRef</a> (Node &amp;SourceN, Node &amp;TargetN)</>}>
Make an existing outgoing call edge into a ref edge. <a href="#adce8df277d53b4d87581583c8269ac71">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#ae2f9bc7458beec4389ccf7fb88199d4b">switchTrivialInternalEdgeToRef</a> (Node &amp;SourceN, Node &amp;TargetN)</>}>
Make an existing internal call edge between separate SCCs into a ref edge. <a href="#ae2f9bc7458beec4389ccf7fb88199d4b">More...</a>
</MembersIndexItem>

</MembersIndex>

## Description {#details}

A <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> of the call graph.

This models a Strongly Connected Component of function reference edges in the call graph. As opposed to actual SCCs, these can be used to scope subgraphs of the module which are independent from other subgraphs of the module because they do not reference it in any way. This is also the unit where we do mutation of the graph in order to restrict mutations to those which don&#39;t violate this independence.

A <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> contains a DAG of actual SCCs. All the nodes within the <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> are necessarily within some actual <a href="/docs/api/classes/llvm/lazycallgraph/scc">SCC</a> that nests within it. Since a direct call <em>is</em> a reference, there will always be at least one <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> around any <a href="/docs/api/classes/llvm/lazycallgraph/scc">SCC</a>.

Spurious ref edges, meaning ref edges that still exist in the call graph even though the corresponding IR reference no longer exists, are allowed. This is mostly to support argument promotion, which can modify a caller to no longer pass a function. The only place that needs to specially handle this is deleting a dead function/node, otherwise the dead ref edges are automatically removed when visiting the function/node no longer containing the ref edge.

Definition at line 541 of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h">LazyCallGraph.h</a>.

<SectionDefinition>

## Public Member Typedefs

### iterator {#ad85b2ad566b56110886f3c39653b88fa}

<MemberDefinition
  prototype={<>using llvm::LazyCallGraph::RefSCC::iterator =  pointee&#95;iterator&lt;SmallVectorImpl&lt;SCC &#42;&gt;::const&#95;iterator&gt;</>}>

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h/#l00604">604</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h">LazyCallGraph.h</a>.
</MemberDefinition>

### parent&#95;iterator {#ad8fea2aaa35fad7cf415558c8b753288}

<MemberDefinition
  prototype={<>using llvm::LazyCallGraph::RefSCC::parent&#95;iterator = 
        pointee&#95;iterator&lt;SmallPtrSetImpl&lt;RefSCC &#42;&gt;::const&#95;iterator&gt;</>}>

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h/#l00606">606</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h">LazyCallGraph.h</a>.
</MemberDefinition>

### range {#a69b7350ecfd665c8008e5a47c6734c87}

<MemberDefinition
  prototype={<>using llvm::LazyCallGraph::RefSCC::range =  iterator&#95;range&lt;iterator&gt;</>}>

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h/#l00605">605</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h">LazyCallGraph.h</a>.
</MemberDefinition>

</SectionDefinition>

<SectionDefinition>

## Friends

### LazyCallGraph {#a81774ea46253e6427d63a610bd624c08}

<MemberDefinition
  prototype={<>friend class <a href="/docs/api/classes/llvm/lazycallgraph">LazyCallGraph</a></>}>

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h/#l00542">542</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h">LazyCallGraph.h</a>.
</MemberDefinition>

### LazyCallGraph::Node {#a3a7a57d977301c68294ee8d4c92543ce}

<MemberDefinition
  prototype={<>friend class <a href="/docs/api/classes/llvm/lazycallgraph/node">LazyCallGraph::Node</a></>}>

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h/#l00543">543</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h">LazyCallGraph.h</a>.
</MemberDefinition>

### operator&lt;&lt; {#ae06c7c08f7da5bc7d384c81be0b83910}

<MemberDefinition
  prototype={<>friend <a href="/docs/api/classes/llvm/raw-ostream">raw&#95;ostream</a> &amp; <a href="/docs/api/classes/llvm/raw-ostream">raw&#95;ostream</a> &amp; OS, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> &amp; RC</>}
  labels = {["inline"]}>
Print a short description useful for debugging or logging.

We print the SCCs wrapped in &#39;&#91;&#93;&#39;s and skipping the middle SCCs if there are a large number.

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h/#l00569">569</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h">LazyCallGraph.h</a>.
</MemberDefinition>

</SectionDefinition>

<SectionDefinition>

## Private Constructors

### RefSCC() {#ab5fb8a48f9e09ffb93f285d7e121af7d}

<MemberDefinition
  prototype={<>LazyCallGraph::RefSCC::RefSCC (<a href="/docs/api/classes/llvm/lazycallgraph">LazyCallGraph</a> &amp; G)</>}>
Fast-path constructor.

RefSCCs should instead be constructed by calling formRefSCCFast on the graph itself.

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h/#l00555">555</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h">LazyCallGraph.h</a>, definition at line <a href="/docs/api/files/lib/lib/analysis/lazycallgraph-cpp/#l00333">333</a> of file <a href="/docs/api/files/lib/lib/analysis/lazycallgraph-cpp">LazyCallGraph.cpp</a>.
</MemberDefinition>

</SectionDefinition>

<SectionDefinition>

## Public Operators

### operator&#91;&#93;() {#a571517d23e9e5252dc87f5c23e7105f2}

<MemberDefinition
  prototype={<>SCC &amp; llvm::LazyCallGraph::RefSCC::operator&#91;&#93; (int Idx)</>}
  labels = {["inline"]}>

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h/#l00614">614</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h">LazyCallGraph.h</a>.
</MemberDefinition>

</SectionDefinition>

<SectionDefinition>

## Public Member Functions

### begin() {#acc4aeec51553504ba50594d9fb8ac4b1}

<MemberDefinition
  prototype="iterator llvm::LazyCallGraph::RefSCC::begin () const"
  labels = {["inline"]}>

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h/#l00609">609</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h">LazyCallGraph.h</a>.
</MemberDefinition>

### end() {#acbbe8357e4c4fef5f9b7809b41abcdcd}

<MemberDefinition
  prototype="iterator llvm::LazyCallGraph::RefSCC::end () const"
  labels = {["inline"]}>

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h/#l00610">610</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h">LazyCallGraph.h</a>.
</MemberDefinition>

### find() {#a51f7db86dd464b937f03aab0fbf51506}

<MemberDefinition
  prototype={<>iterator llvm::LazyCallGraph::RefSCC::find (<a href="/docs/api/classes/llvm/lazycallgraph/scc">SCC</a> &amp; C) const</>}
  labels = {["inline"]}>

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h/#l00616">616</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h">LazyCallGraph.h</a>.
</MemberDefinition>

### getName() {#ac30dc61a31f34e7359336fa637104bfb}

<MemberDefinition
  prototype="std::string llvm::LazyCallGraph::RefSCC::getName () const"
  labels = {["inline"]}>
Provide a short name by printing this <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> to a std::string.

This copes with the fact that we don&#39;t have a name per se for an <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> while still making the use of this in debugging and logging useful.

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h/#l00652">652</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h">LazyCallGraph.h</a>.
</MemberDefinition>

### isAncestorOf() {#a35a8d25c6df3f1d3bc5faba32de1dd55}

<MemberDefinition
  prototype={<>bool LazyCallGraph::RefSCC::isAncestorOf (<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> &amp; RC) const</>}>
Test if this <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> is an ancestor of <em>RC</em>.

CAUTION: This method walks the directed graph of edges as far as necessary to find a possible path to the argument. In the worst case this may walk the entire graph and can be extremely expensive.

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h/#l00631">631</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h">LazyCallGraph.h</a>, definition at line <a href="/docs/api/files/lib/lib/analysis/lazycallgraph-cpp/#l00424">424</a> of file <a href="/docs/api/files/lib/lib/analysis/lazycallgraph-cpp">LazyCallGraph.cpp</a>.
</MemberDefinition>

### isChildOf() {#a5c04e8da471c500d025dfdf206c24ed2}

<MemberDefinition
  prototype={<>bool llvm::LazyCallGraph::RefSCC::isChildOf (<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> &amp; RC) const</>}
  labels = {["inline"]}>
Test if this <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> is a child of <em>RC</em>.

CAUTION: This method walks every edge in the argument <code><a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a></code>, it can be very expensive.

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h/#l00637">637</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h">LazyCallGraph.h</a>.
</MemberDefinition>

### isDescendantOf() {#a59f6c7fa7f420326cc1f7026e51b0668}

<MemberDefinition
  prototype={<>bool llvm::LazyCallGraph::RefSCC::isDescendantOf (<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> &amp; RC) const</>}
  labels = {["inline"]}>
Test if this <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> is a descendant of <em>RC</em>.

CAUTION: This method walks the directed graph of edges as far as necessary to find a possible path from the argument. In the worst case this may walk the entire graph and can be extremely expensive.

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h/#l00644">644</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h">LazyCallGraph.h</a>.
</MemberDefinition>

### isParentOf() {#af952e1ffaf5cd4bd83b63cf7fb4cb068}

<MemberDefinition
  prototype={<>bool LazyCallGraph::RefSCC::isParentOf (<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> &amp; RC) const</>}>
Test if this <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> is a parent of <em>RC</em>.

CAUTION: This method walks every edge in the <code><a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a></code>, it can be very expensive.

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h/#l00624">624</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h">LazyCallGraph.h</a>, definition at line <a href="/docs/api/files/lib/lib/analysis/lazycallgraph-cpp/#l00410">410</a> of file <a href="/docs/api/files/lib/lib/analysis/lazycallgraph-cpp">LazyCallGraph.cpp</a>.
</MemberDefinition>

### size() {#ac62cb27d2f0946c9febb1e1d1e377f55}

<MemberDefinition
  prototype={<>ssize&#95;t llvm::LazyCallGraph::RefSCC::size () const</>}
  labels = {["inline"]}>

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h/#l00612">612</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h">LazyCallGraph.h</a>.
</MemberDefinition>

</SectionDefinition>

<SectionDefinition>

## Private Member Functions

### clear() {#ab484ec648a8540467efe37c71d1531ff}

<MemberDefinition
  prototype="void llvm::LazyCallGraph::RefSCC::clear ()"
  labels = {["inline"]}>

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h/#l00557">557</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h">LazyCallGraph.h</a>.
</MemberDefinition>

### dump() {#a21ed0a8438a4d6b61af5c4832b4d0124}

<MemberDefinition
  prototype={<>LLVM&#95;DUMP&#95;METHOD void LazyCallGraph::RefSCC::dump () const</>}>
Dump a short description of this <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> to stderr.

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h/#l00588">588</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h">LazyCallGraph.h</a>, definition at line <a href="/docs/api/files/lib/lib/analysis/lazycallgraph-cpp/#l00336">336</a> of file <a href="/docs/api/files/lib/lib/analysis/lazycallgraph-cpp">LazyCallGraph.cpp</a>.
</MemberDefinition>

### verify() {#a992480861cbbf2f720a27e2b56700682}

<MemberDefinition
  prototype="void LazyCallGraph::RefSCC::verify ()">
Verify invariants about the <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> and all its SCCs.

This will attempt to validate all of the invariants <em>within</em> the <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a>, but not that it is a strongly connected component of the larger graph. This makes it useful even when partially through an update.

Invariants checked:
<ul>
<li>SCCs and their indices match.</li>
<li>The SCCs list is in fact in post-order.</li>
</ul>

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h/#l00600">600</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h">LazyCallGraph.h</a>, definition at line <a href="/docs/api/files/lib/lib/analysis/lazycallgraph-cpp/#l00342">342</a> of file <a href="/docs/api/files/lib/lib/analysis/lazycallgraph-cpp">LazyCallGraph.cpp</a>.
</MemberDefinition>

</SectionDefinition>

<SectionDefinition>

## Private Member Attributes

### G {#a258d60676d3507f4371f54614265c4c5}

<MemberDefinition
  prototype={<>LazyCallGraph&#42; llvm::LazyCallGraph::RefSCC::G</>}>

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h/#l00545">545</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h">LazyCallGraph.h</a>.
</MemberDefinition>

### SCCIndices {#ae2e66513096a8568624f8bb6177df0df}

<MemberDefinition
  prototype={<>SmallDenseMap&lt;SCC &#42;, int, 4&gt; llvm::LazyCallGraph::RefSCC::SCCIndices</>}>
A map from <a href="/docs/api/classes/llvm/lazycallgraph/scc">SCC</a> to index in the postorder list.

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h/#l00551">551</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h">LazyCallGraph.h</a>.
</MemberDefinition>

### SCCs {#a64f45fde9dbe447ac0e25a3c83bd00bf}

<MemberDefinition
  prototype={<>SmallVector&lt;SCC &#42;, 4&gt; llvm::LazyCallGraph::RefSCC::SCCs</>}>
A postorder list of the inner SCCs.

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h/#l00548">548</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h">LazyCallGraph.h</a>.
</MemberDefinition>

</SectionDefinition>

<SectionDefinition>

## Mutation API


These methods provide the core API for updating the call graph in the presence of (potentially still in-flight) DFS-found RefSCCs and SCCs.

Note that these methods sometimes have complex runtimes, so be careful how you call them.

### insertIncomingRefEdge {#a01b1581633bb40f86d6dc62a1c1a7f72}

<MemberDefinition
  prototype={<>SmallVector&lt; LazyCallGraph::RefSCC &#42;, 1 &gt; LazyCallGraph::RefSCC::insertIncomingRefEdge (<a href="/docs/api/classes/llvm/lazycallgraph/node">Node</a> &amp; SourceN, <a href="/docs/api/classes/llvm/lazycallgraph/node">Node</a> &amp; TargetN)</>}>
Insert an edge whose source is in a descendant <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> and target is in this <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a>.

There must be an existing path from the target to the source in this case.

NB! This is has the potential to be a very expensive function. It inherently forms a cycle in the prior <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> DAG and we have to merge RefSCCs to resolve that cycle. But finding all of the RefSCCs which participate in the cycle can in the worst case require traversing every <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> in the graph. Every attempt is made to avoid that, but passes must still exercise caution calling this routine repeatedly.

Also note that this can only insert ref edges. In order to insert a call edge, first insert a ref edge and then switch it to a call edge. These are intentionally kept as separate interfaces because each step of the operation invalidates a different set of data structures.

This returns all the RefSCCs which were merged into the this <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> (the target&#39;s). This allows callers to invalidate any cached information.

FIXME: We could possibly optimize this quite a bit for cases where the caller and callee are very nearby in the graph. See comments in the implementation for details, but that use case might impact users.

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h/#l00778">778</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h">LazyCallGraph.h</a>, definition at line <a href="/docs/api/files/lib/lib/analysis/lazycallgraph-cpp/#l01006">1006</a> of file <a href="/docs/api/files/lib/lib/analysis/lazycallgraph-cpp">LazyCallGraph.cpp</a>.
</MemberDefinition>

### insertInternalRefEdge {#aa57986c798b44affab5e4d5953e37727}

<MemberDefinition
  prototype={<>void LazyCallGraph::RefSCC::insertInternalRefEdge (<a href="/docs/api/classes/llvm/lazycallgraph/node">Node</a> &amp; SourceN, <a href="/docs/api/classes/llvm/lazycallgraph/node">Node</a> &amp; TargetN)</>}>
Insert a ref edge from one node in this <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> to another in this <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a>.

This is always a trivial operation as it doesn&#39;t change any part of the graph structure besides connecting the two nodes.

Note that we don&#39;t support directly inserting internal <em>call</em> edges because that could change the graph structure and requires returning information about what became invalid. As a consequence, the pattern should be to first insert the necessary ref edge, and then to switch it to a call edge if needed and handle any invalidation that results. See the <code>switchInternalEdgeToCall</code> routine for details.

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h/#l00743">743</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h">LazyCallGraph.h</a>, definition at line <a href="/docs/api/files/lib/lib/analysis/lazycallgraph-cpp/#l00974">974</a> of file <a href="/docs/api/files/lib/lib/analysis/lazycallgraph-cpp">LazyCallGraph.cpp</a>.
</MemberDefinition>

### insertOutgoingEdge {#a743c2ac21f2f8a8c6af18e1e09f13229}

<MemberDefinition
  prototype={<>void LazyCallGraph::RefSCC::insertOutgoingEdge (<a href="/docs/api/classes/llvm/lazycallgraph/node">Node</a> &amp; SourceN, <a href="/docs/api/classes/llvm/lazycallgraph/node">Node</a> &amp; TargetN, <a href="/docs/api/classes/llvm/lazycallgraph/edge/#a8a5508e6c049172373b05c47c1b6fe13">Edge::Kind</a> EK)</>}>
Insert an edge whose parent is in this <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> and child is in some child <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a>.

There must be an existing path from the <code>SourceN</code> to the <code>TargetN</code>. This operation is inexpensive and does not change the set of SCCs and RefSCCs in the graph.

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h/#l00751">751</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h">LazyCallGraph.h</a>, definition at line <a href="/docs/api/files/lib/lib/analysis/lazycallgraph-cpp/#l00986">986</a> of file <a href="/docs/api/files/lib/lib/analysis/lazycallgraph-cpp">LazyCallGraph.cpp</a>.
</MemberDefinition>

### insertTrivialCallEdge {#aaf3ba7d78f09755223609e4978bebef7}

<MemberDefinition
  prototype={<>void LazyCallGraph::RefSCC::insertTrivialCallEdge (<a href="/docs/api/classes/llvm/lazycallgraph/node">Node</a> &amp; SourceN, <a href="/docs/api/classes/llvm/lazycallgraph/node">Node</a> &amp; TargetN)</>}>
A convenience wrapper around the above to handle trivial cases of inserting a new call edge.

This is trivial whenever the target is in the same <a href="/docs/api/classes/llvm/lazycallgraph/scc">SCC</a> as the source or the edge is an outgoing edge to some descendant <a href="/docs/api/classes/llvm/lazycallgraph/scc">SCC</a>. In these cases there is no change to the cyclic structure of SCCs or RefSCCs.

To further make calling this convenient, it also handles inserting already existing edges.

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h/#l00843">843</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h">LazyCallGraph.h</a>, definition at line <a href="/docs/api/files/lib/lib/analysis/lazycallgraph-cpp/#l01395">1395</a> of file <a href="/docs/api/files/lib/lib/analysis/lazycallgraph-cpp">LazyCallGraph.cpp</a>.
</MemberDefinition>

### insertTrivialRefEdge {#a393b4565f554b9d8382c8f610b7f2ce7}

<MemberDefinition
  prototype={<>void LazyCallGraph::RefSCC::insertTrivialRefEdge (<a href="/docs/api/classes/llvm/lazycallgraph/node">Node</a> &amp; SourceN, <a href="/docs/api/classes/llvm/lazycallgraph/node">Node</a> &amp; TargetN)</>}>
A convenience wrapper around the above to handle trivial cases of inserting a new ref edge.

This is trivial whenever the target is in the same <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> as the source or the edge is an outgoing edge to some descendant <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a>. In these cases there is no change to the cyclic structure of the RefSCCs.

To further make calling this convenient, it also handles inserting already existing edges.

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h/#l00854">854</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h">LazyCallGraph.h</a>, definition at line <a href="/docs/api/files/lib/lib/analysis/lazycallgraph-cpp/#l01424">1424</a> of file <a href="/docs/api/files/lib/lib/analysis/lazycallgraph-cpp">LazyCallGraph.cpp</a>.
</MemberDefinition>

### removeInternalRefEdges {#a87dd1a69c8d8492e78b32708ceacb2c6}

<MemberDefinition
  prototype={<>SmallVector&lt; LazyCallGraph::RefSCC &#42;, 1 &gt; LazyCallGraph::RefSCC::removeInternalRefEdges (<a href="/docs/api/classes/llvm/arrayref">ArrayRef</a>&lt; std::pair&lt; <a href="/docs/api/classes/llvm/lazycallgraph/node">Node</a> &#42;, <a href="/docs/api/classes/llvm/lazycallgraph/node">Node</a> &#42; &gt; &gt; Edges)</>}
  labels = {["nodiscard"]}>
Remove a list of ref edges which are entirely within this <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a>.

Both the <em>SourceN</em> and all of the <em>TargetNs</em> must be within this <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a>. Removing these edges may break cycles that form this <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> and thus this operation may change the <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> graph significantly. In particular, this operation will re-form new RefSCCs based on the remaining connectivity of the graph. The following invariants are guaranteed to hold after calling this method:

1) If a ref-cycle remains after removal, it leaves this <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> intact and in the graph. No new RefSCCs are built. 2) Otherwise, this <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> will be dead after this call and no longer in the graph or the postorder traversal of the call graph. <a href="/docs/api/classes/llvm/any">Any</a> iterator pointing at this <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> will become invalid. 3) All newly formed RefSCCs will be returned and the order of the RefSCCs returned will be a valid postorder traversal of the new RefSCCs. 4) No <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> other than this <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> has its member set changed (this is inherent in the definition of removing such an edge).

These invariants are very important to ensure that we can build optimization pipelines on top of the CGSCC pass manager which intelligently update the <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> graph without invalidating other parts of the <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> graph.

Note that we provide no routine to remove a <em>call</em> edge. Instead, you must first switch it to a ref edge using <code>switchInternalEdgeToRef</code>. This split API is intentional as each of these two steps can invalidate a different aspect of the graph structure and needs to have the invalidation handled independently.

The runtime complexity of this method is, in the worst case, O(V+E) where V is the number of nodes in this <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> and E is the number of edges leaving the nodes in this <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a>. Note that E includes both edges within this <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> and edges from this <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> to child RefSCCs. Some effort has been made to minimize the overhead of common cases such as self-edges and edge removals which result in a spanning tree with no more cycles.

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h/#l00832">832</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h">LazyCallGraph.h</a>, definition at line <a href="/docs/api/files/lib/lib/analysis/lazycallgraph-cpp/#l01165">1165</a> of file <a href="/docs/api/files/lib/lib/analysis/lazycallgraph-cpp">LazyCallGraph.cpp</a>.
</MemberDefinition>

### removeOutgoingEdge {#ab130250bcdaefbfd3c583cad7b120b62}

<MemberDefinition
  prototype={<>void LazyCallGraph::RefSCC::removeOutgoingEdge (<a href="/docs/api/classes/llvm/lazycallgraph/node">Node</a> &amp; SourceN, <a href="/docs/api/classes/llvm/lazycallgraph/node">Node</a> &amp; TargetN)</>}>
Remove an edge whose source is in this <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a> and target is <em>not</em>.

This removes an inter-RefSCC edge. All inter-RefSCC edges originating from this <a href="/docs/api/classes/llvm/lazycallgraph/scc">SCC</a> have been fully explored by any in-flight DFS graph formation, so this is always safe to call once you have the source <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a>.

This operation does not change the cyclic structure of the graph and so is very inexpensive. It may change the connectivity graph of the SCCs though, so be careful calling this while iterating over them.

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h/#l00791">791</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h">LazyCallGraph.h</a>, definition at line <a href="/docs/api/files/lib/lib/analysis/lazycallgraph-cpp/#l01147">1147</a> of file <a href="/docs/api/files/lib/lib/analysis/lazycallgraph-cpp">LazyCallGraph.cpp</a>.
</MemberDefinition>

### replaceNodeFunction {#a70f7f0574edbfc0f75424499133d4ba3}

<MemberDefinition
  prototype={<>void LazyCallGraph::RefSCC::replaceNodeFunction (<a href="/docs/api/classes/llvm/lazycallgraph/node">Node</a> &amp; N, <a href="/docs/api/classes/llvm/function">Function</a> &amp; NewF)</>}>
Directly replace a node&#39;s function with a new function.

This should be used when moving the body and users of a function to a new formal function object but not otherwise changing the call graph structure in any way.

It requires that the old function in the provided node have zero uses and the new function must have calls and references to it establishing an equivalent graph.

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h/#l00865">865</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h">LazyCallGraph.h</a>, definition at line <a href="/docs/api/files/lib/lib/analysis/lazycallgraph-cpp/#l01448">1448</a> of file <a href="/docs/api/files/lib/lib/analysis/lazycallgraph-cpp">LazyCallGraph.cpp</a>.
</MemberDefinition>

### switchInternalEdgeToCall {#a2957918db7f91f405b11d92c1ebf3b0f}

<MemberDefinition
  prototype={<>bool LazyCallGraph::RefSCC::switchInternalEdgeToCall (<a href="/docs/api/classes/llvm/lazycallgraph/node">Node</a> &amp; SourceN, <a href="/docs/api/classes/llvm/lazycallgraph/node">Node</a> &amp; TargetN, <a href="/docs/api/classes/llvm/function-ref">function&#95;ref</a>&lt; void(<a href="/docs/api/classes/llvm/arrayref">ArrayRef</a>&lt; <a href="/docs/api/classes/llvm/lazycallgraph/scc">SCC</a> &#42; &gt; MergedSCCs)&gt; MergeCB=&#123;&#125;)</>}>
Make an existing internal ref edge into a call edge.

This may form a larger cycle and thus collapse SCCs into TargetN&#39;s <a href="/docs/api/classes/llvm/lazycallgraph/scc">SCC</a>. If that happens, the optional callback <code>MergedCB</code> will be invoked (if provided) on the SCCs being merged away prior to actually performing the merge. Note that this will never include the target <a href="/docs/api/classes/llvm/lazycallgraph/scc">SCC</a> as that will be the <a href="/docs/api/classes/llvm/lazycallgraph/scc">SCC</a> functions are merged into to resolve the cycle. Once this function returns, these merged SCCs are not in a valid state but the pointers will remain valid until destruction of the parent graph instance for the purpose of clearing cached information. This function also returns &#39;true&#39; if a cycle was formed and some SCCs merged away as a convenience.

After this operation, both SourceN&#39;s <a href="/docs/api/classes/llvm/lazycallgraph/scc">SCC</a> and TargetN&#39;s <a href="/docs/api/classes/llvm/lazycallgraph/scc">SCC</a> may move position within this <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a>&#39;s postorder list. <a href="/docs/api/classes/llvm/any">Any</a> SCCs merged are merged into the TargetN&#39;s <a href="/docs/api/classes/llvm/lazycallgraph/scc">SCC</a> in order to preserve reachability analyses which took place on that <a href="/docs/api/classes/llvm/lazycallgraph/scc">SCC</a>.

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h/#l00686">686</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h">LazyCallGraph.h</a>, definition at line <a href="/docs/api/files/lib/lib/analysis/lazycallgraph-cpp/#l00586">586</a> of file <a href="/docs/api/files/lib/lib/analysis/lazycallgraph-cpp">LazyCallGraph.cpp</a>.
</MemberDefinition>

### switchInternalEdgeToRef {#a96fe0cb15ded58bd1824fa4e3daec680}

<MemberDefinition
  prototype={<>iterator&#95;range&lt; LazyCallGraph::RefSCC::iterator &gt; LazyCallGraph::RefSCC::switchInternalEdgeToRef (<a href="/docs/api/classes/llvm/lazycallgraph/node">Node</a> &amp; SourceN, <a href="/docs/api/classes/llvm/lazycallgraph/node">Node</a> &amp; TargetN)</>}>
Make an existing internal call edge within a single <a href="/docs/api/classes/llvm/lazycallgraph/scc">SCC</a> into a ref edge.

Since SourceN and TargetN are part of a single <a href="/docs/api/classes/llvm/lazycallgraph/scc">SCC</a>, this <a href="/docs/api/classes/llvm/lazycallgraph/scc">SCC</a> may be split up due to breaking a cycle in the call edges that formed it. If that happens, then this routine will insert new SCCs into the postorder list <em>before</em> the <a href="/docs/api/classes/llvm/lazycallgraph/scc">SCC</a> of TargetN (previously the <a href="/docs/api/classes/llvm/lazycallgraph/scc">SCC</a> of both). This preserves postorder as the TargetN can reach all of the other nodes by definition of previously being in a single <a href="/docs/api/classes/llvm/lazycallgraph/scc">SCC</a> formed by the cycle from SourceN to TargetN.

The newly added SCCs are added <em>immediately</em> and contiguously prior to the TargetN <a href="/docs/api/classes/llvm/lazycallgraph/scc">SCC</a> and return the range covering the new SCCs in the <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a>&#39;s postorder sequence. You can directly iterate the returned range to observe all of the new SCCs in postorder.

Note that if SourceN and TargetN are in separate SCCs, the simpler routine <code>switchTrivialInternalEdgeToRef</code> should be used instead.

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h/#l00716">716</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h">LazyCallGraph.h</a>, definition at line <a href="/docs/api/files/lib/lib/analysis/lazycallgraph-cpp/#l00752">752</a> of file <a href="/docs/api/files/lib/lib/analysis/lazycallgraph-cpp">LazyCallGraph.cpp</a>.
</MemberDefinition>

### switchOutgoingEdgeToCall {#a5cc0541c3ee15c565ac05fe11f5459d2}

<MemberDefinition
  prototype={<>void LazyCallGraph::RefSCC::switchOutgoingEdgeToCall (<a href="/docs/api/classes/llvm/lazycallgraph/node">Node</a> &amp; SourceN, <a href="/docs/api/classes/llvm/lazycallgraph/node">Node</a> &amp; TargetN)</>}>
Make an existing outgoing ref edge into a call edge.

Note that this is trivial as there are no cyclic impacts and there remains a reference edge.

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h/#l00723">723</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h">LazyCallGraph.h</a>, definition at line <a href="/docs/api/files/lib/lib/analysis/lazycallgraph-cpp/#l00932">932</a> of file <a href="/docs/api/files/lib/lib/analysis/lazycallgraph-cpp">LazyCallGraph.cpp</a>.
</MemberDefinition>

### switchOutgoingEdgeToRef {#adce8df277d53b4d87581583c8269ac71}

<MemberDefinition
  prototype={<>void LazyCallGraph::RefSCC::switchOutgoingEdgeToRef (<a href="/docs/api/classes/llvm/lazycallgraph/node">Node</a> &amp; SourceN, <a href="/docs/api/classes/llvm/lazycallgraph/node">Node</a> &amp; TargetN)</>}>
Make an existing outgoing call edge into a ref edge.

This is trivial as there are no cyclic impacts and there remains a reference edge.

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h/#l00729">729</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h">LazyCallGraph.h</a>, definition at line <a href="/docs/api/files/lib/lib/analysis/lazycallgraph-cpp/#l00953">953</a> of file <a href="/docs/api/files/lib/lib/analysis/lazycallgraph-cpp">LazyCallGraph.cpp</a>.
</MemberDefinition>

### switchTrivialInternalEdgeToRef {#ae2f9bc7458beec4389ccf7fb88199d4b}

<MemberDefinition
  prototype={<>void LazyCallGraph::RefSCC::switchTrivialInternalEdgeToRef (<a href="/docs/api/classes/llvm/lazycallgraph/node">Node</a> &amp; SourceN, <a href="/docs/api/classes/llvm/lazycallgraph/node">Node</a> &amp; TargetN)</>}>
Make an existing internal call edge between separate SCCs into a ref edge.

If SourceN and TargetN in separate SCCs within this <a href="/docs/api/classes/llvm/lazycallgraph/refscc">RefSCC</a>, changing the call edge between them to a ref edge is a trivial operation that does not require any structural changes to the call graph.

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h/#l00696">696</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h">LazyCallGraph.h</a>, definition at line <a href="/docs/api/files/lib/lib/analysis/lazycallgraph-cpp/#l00733">733</a> of file <a href="/docs/api/files/lib/lib/analysis/lazycallgraph-cpp">LazyCallGraph.cpp</a>.
</MemberDefinition>

</SectionDefinition>

<hr/>

The documentation for this class was generated from the following files:

<ul>
<li><a href="/docs/api/files/include/include/llvm/include/llvm/analysis/lazycallgraph-h">LazyCallGraph.h</a></li>
<li><a href="/docs/api/files/lib/lib/analysis/lazycallgraph-cpp">LazyCallGraph.cpp</a></li>
</ul>

</DoxygenPage>
