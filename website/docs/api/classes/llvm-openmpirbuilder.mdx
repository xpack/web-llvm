---

# DO NOT EDIT!
# Automatically generated via docusaurus-plugin-doxygen by Doxygen.

slug: /api/classes/llvm/openmpirbuilder
custom_edit_url: null
keywords:
  - doxygen
  - reference
  - class
toc_max_heading_level: 3

---

import CodeBlock from '@theme/CodeBlock'

import CodeLine from '@xpack/docusaurus-plugin-doxygen/components/CodeLine'
import DoxygenPage from '@xpack/docusaurus-plugin-doxygen/components/DoxygenPage'
import IncludesList from '@xpack/docusaurus-plugin-doxygen/components/IncludesList'
import IncludesListItem from '@xpack/docusaurus-plugin-doxygen/components/IncludesListItem'
import MemberDefinition from '@xpack/docusaurus-plugin-doxygen/components/MemberDefinition'
import MembersIndex from '@xpack/docusaurus-plugin-doxygen/components/MembersIndex'
import MembersIndexItem from '@xpack/docusaurus-plugin-doxygen/components/MembersIndexItem'
import ParametersList from '@xpack/docusaurus-plugin-doxygen/components/ParametersList'
import ParametersListItem from '@xpack/docusaurus-plugin-doxygen/components/ParametersListItem'
import ProgramListing from '@xpack/docusaurus-plugin-doxygen/components/ProgramListing'
import SectionDefinition from '@xpack/docusaurus-plugin-doxygen/components/SectionDefinition'
import SectionUser from '@xpack/docusaurus-plugin-doxygen/components/SectionUser'

import pluginConfig from '@site/docusaurus-plugin-doxygen-config.json'

# The `OpenMPIRBuilder` Class Reference

<DoxygenPage pluginConfig={pluginConfig}>

An interface to create LLVM-IR for OpenMP directives. <a href="#details">More...</a>

## Declaration

<CodeBlock>class llvm::OpenMPIRBuilder</CodeBlock>

## Included Headers

<IncludesList>
<IncludesListItem
  filePath="llvm/Frontend/OpenMP/OMPIRBuilder.h"
  permalink="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h"
  isLocal="true" />
</IncludesList>

## Public Member Typedefs Index

<MembersIndex>

<MembersIndexItem
  type="using"
  name={<><a href="#a49e35e3ee470add16efcde1ab5d5556b">BodyGenCallbackTy</a> = <a href="/docs/api/classes/llvm/function-ref">function&#95;ref</a>&lt; <a href="/docs/api/classes/llvm/error">Error</a>(<a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> AllocaIP, <a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> CodeGenIP)&gt;</>}>
Callback type for body (=inner region) code generation. <a href="#a49e35e3ee470add16efcde1ab5d5556b">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="using"
  name={<><a href="#a0c571620ff53fdb78e7404f5261dbd23">FinalizeCallbackTy</a> = std::function&lt; <a href="/docs/api/classes/llvm/error">Error</a>(<a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> CodeGenIP)&gt;</>}>
Callback type for variable finalization (think destructors). <a href="#a0c571620ff53fdb78e7404f5261dbd23">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="using"
  name={<><a href="#af24d1c61cec57095ced3b08a6dd99ee8">InsertPointOrErrorTy</a> = <a href="/docs/api/classes/llvm/expected">Expected</a>&lt; <a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> &gt;</>}>
<a href="/docs/api/classes/llvm/type">Type</a> used to represent an insertion point or an error value. <a href="#af24d1c61cec57095ced3b08a6dd99ee8">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="using"
  name={<><a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> = <a href="/docs/api/classes/llvm/irbuilder">IRBuilder</a>&lt;&gt;::InsertPoint</>}>
<a href="/docs/api/classes/llvm/type">Type</a> used throughout for insertion points. <a href="#aafc1886793b898052f87edd7e9fdbaa3">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="using"
  name={<><a href="#a296d2e28bddf1051d614f48b61005899">LoopBodyGenCallbackTy</a> = <a href="/docs/api/classes/llvm/function-ref">function&#95;ref</a>&lt; <a href="/docs/api/classes/llvm/error">Error</a>(<a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> CodeGenIP, <a href="/docs/api/classes/llvm/value">Value</a> &#42;IndVar)&gt;</>}>
Callback type for loop body code generation. <a href="#a296d2e28bddf1051d614f48b61005899">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="using"
  name={<><a href="#a71b5ba020f68829f5a1fd99f48b63d42">PrivatizeCallbackTy</a> = <a href="/docs/api/classes/llvm/function-ref">function&#95;ref</a>&lt; <a href="#af24d1c61cec57095ced3b08a6dd99ee8">InsertPointOrErrorTy</a>( <a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> AllocaIP, <a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> CodeGenIP, <a href="/docs/api/classes/llvm/value">Value</a> &amp;Original, <a href="/docs/api/classes/llvm/value">Value</a> &amp;Inner, <a href="/docs/api/classes/llvm/value">Value</a> &#42;&amp;ReplVal)&gt;</>}>
Callback type for variable privatization (think copy &amp; default constructor). <a href="#a71b5ba020f68829f5a1fd99f48b63d42">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="using"
  name={<><a href="#a761a2c853c1d16b33e4e8c565ce0ca45">StorableBodyGenCallbackTy</a> = std::function&lt; <a href="/docs/api/classes/llvm/error">Error</a>(<a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> AllocaIP, <a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> CodeGenIP)&gt;</>}>
</MembersIndexItem>

</MembersIndex>

## Public Constructors Index

<MembersIndex>

<MembersIndexItem
  name={<><a href="#ae1a990c96a3ebf58698901d09c5b4378">OpenMPIRBuilder</a> (Module &amp;M)</>}>
Create a new <a href="/docs/api/classes/llvm/openmpirbuilder">OpenMPIRBuilder</a> operating on the given module <code>M</code>. <a href="#ae1a990c96a3ebf58698901d09c5b4378">More...</a>
</MembersIndexItem>

</MembersIndex>

## Public Destructor Index

<MembersIndex>

<MembersIndexItem
  name={<><a href="#ad66949e2e846451e61d9c8f34014ea31">~OpenMPIRBuilder</a> ()</>}>
</MembersIndexItem>

</MembersIndex>

## Public Member Functions Index

<MembersIndex>

<MembersIndexItem
  type="void"
  name={<><a href="#a50c6490cf353f064946c4e32673ac098">addAttributes</a> (omp::RuntimeFunction FnID, Function &amp;Fn)</>}>
Add attributes known for <code>FnID</code> to <code>Fn</code>. <a href="#a50c6490cf353f064946c4e32673ac098">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#acd1fbb2df257f945afda92919be322f3">applySimd</a> (CanonicalLoopInfo &#42;Loop, MapVector&lt; Value &#42;, Value &#42; &gt; AlignedVars, Value &#42;IfCond, omp::OrderKind Order, ConstantInt &#42;Simdlen, ConstantInt &#42;Safelen)</>}>
Add metadata to simd-ize a loop. <a href="#acd1fbb2df257f945afda92919be322f3">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<><a href="#af24d1c61cec57095ced3b08a6dd99ee8">InsertPointOrErrorTy</a></>}
  name={<><a href="#adaa14806d128ad33bdc48d2bfc46870c">applyWorkshareLoop</a> (DebugLoc DL, CanonicalLoopInfo &#42;CLI, InsertPointTy AllocaIP, bool NeedsBarrier, llvm::omp::ScheduleKind SchedKind=llvm::omp::OMP&#95;SCHEDULE&#95;Default, Value &#42;ChunkSize=nullptr, bool HasSimdModifier=false, bool HasMonotonicModifier=false, bool HasNonmonotonicModifier=false, bool HasOrderedClause=false, omp::WorksharingLoopType LoopType=omp::WorksharingLoopType::ForStaticLoop)</>}>
Modifies the canonical loop to be a workshare loop. <a href="#adaa14806d128ad33bdc48d2bfc46870c">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<><a href="/docs/api/classes/llvm/canonicalloopinfo">CanonicalLoopInfo</a> &#42;</>}
  name={<><a href="#a08610118e213de1b759470f0eafb9b18">collapseLoops</a> (DebugLoc DL, ArrayRef&lt; CanonicalLoopInfo &#42; &gt; Loops, InsertPointTy ComputeIP)</>}>
Collapse a loop nest into a single loop. <a href="#a08610118e213de1b759470f0eafb9b18">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<><a href="#af24d1c61cec57095ced3b08a6dd99ee8">InsertPointOrErrorTy</a></>}
  name={<><a href="#a6cc340cf5dc46cf45eb6f784577cadbd">createAtomicCapture</a> (const LocationDescription &amp;Loc, InsertPointTy AllocaIP, AtomicOpValue &amp;X, AtomicOpValue &amp;V, Value &#42;Expr, AtomicOrdering AO, AtomicRMWInst::BinOp RMWOp, AtomicUpdateCallbackTy &amp;UpdateOp, bool UpdateExpr, bool IsPostfixUpdate, bool IsXBinopExpr)</>}>
Emit atomic update for constructs: — Only Scalar data types V = X; X = X BinOp Expr , X = X BinOp Expr; V = X, V = X; X = Expr BinOp X, X = Expr BinOp X; V = X, V = X; X = UpdateOp(X), X = UpdateOp(X); V = X,. <a href="#a6cc340cf5dc46cf45eb6f784577cadbd">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<><a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a></>}
  name={<><a href="#a6c4eeba23c6f192892487de272e8ce72">createAtomicCompare</a> (const LocationDescription &amp;Loc, AtomicOpValue &amp;X, AtomicOpValue &amp;V, AtomicOpValue &amp;R, Value &#42;E, Value &#42;D, AtomicOrdering AO, omp::OMPAtomicCompareOp Op, bool IsXBinopExpr, bool IsPostfixUpdate, bool IsFailOnly)</>}>
Emit atomic compare for constructs: — Only scalar data types cond-expr-stmt: x = x ordop expr ? <a href="#a6c4eeba23c6f192892487de272e8ce72">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<><a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a></>}
  name={<><a href="#ab84af206a9a08b9bf97eaadc87874c6c">createAtomicCompare</a> (const LocationDescription &amp;Loc, AtomicOpValue &amp;X, AtomicOpValue &amp;V, AtomicOpValue &amp;R, Value &#42;E, Value &#42;D, AtomicOrdering AO, omp::OMPAtomicCompareOp Op, bool IsXBinopExpr, bool IsPostfixUpdate, bool IsFailOnly, AtomicOrdering Failure)</>}>
</MembersIndexItem>

<MembersIndexItem
  type={<><a href="#af24d1c61cec57095ced3b08a6dd99ee8">InsertPointOrErrorTy</a></>}
  name={<><a href="#ae75c4b44f208011259ee93497c2cb411">createAtomicUpdate</a> (const LocationDescription &amp;Loc, InsertPointTy AllocaIP, AtomicOpValue &amp;X, Value &#42;Expr, AtomicOrdering AO, AtomicRMWInst::BinOp RMWOp, AtomicUpdateCallbackTy &amp;UpdateOp, bool IsXBinopExpr)</>}>
Generator for <code>#omp task</code> <a href="#ae75c4b44f208011259ee93497c2cb411">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<><a href="#af24d1c61cec57095ced3b08a6dd99ee8">InsertPointOrErrorTy</a></>}
  name={<><a href="#abca6530c9099bd1b1c3e0a5c32381f07">createBarrier</a> (const LocationDescription &amp;Loc, omp::Directive Kind, bool ForceSimpleCall=false, bool CheckCancelFlag=true)</>}>
Emitter methods for OpenMP directives. <a href="#abca6530c9099bd1b1c3e0a5c32381f07">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<><a href="#af24d1c61cec57095ced3b08a6dd99ee8">InsertPointOrErrorTy</a></>}
  name={<><a href="#a04285415a321e48322c08f3b9185540e">createCancel</a> (const LocationDescription &amp;Loc, Value &#42;IfCondition, omp::Directive CanceledDirective)</>}>
Generator for &#39;<a href="/docs/api/namespaces/llvm/omp">omp</a> cancel&#39;. <a href="#a04285415a321e48322c08f3b9185540e">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<><a href="/docs/api/classes/llvm/expected">Expected</a>&lt; <a href="/docs/api/classes/llvm/canonicalloopinfo">CanonicalLoopInfo</a> &#42; &gt;</>}
  name={<><a href="#ae0287686a5ffe03bc264972c862726ea">createCanonicalLoop</a> (const LocationDescription &amp;Loc, LoopBodyGenCallbackTy BodyGenCB, Value &#42;TripCount, const Twine &amp;Name=&quot;loop&quot;)</>}>
Generator for the control flow structure of an OpenMP canonical loop. <a href="#ae0287686a5ffe03bc264972c862726ea">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<><a href="/docs/api/classes/llvm/expected">Expected</a>&lt; <a href="/docs/api/classes/llvm/canonicalloopinfo">CanonicalLoopInfo</a> &#42; &gt;</>}
  name={<><a href="#ac669acbd0f638c6ef32977575362052e">createCanonicalLoop</a> (const LocationDescription &amp;Loc, LoopBodyGenCallbackTy BodyGenCB, Value &#42;Start, Value &#42;Stop, Value &#42;Step, bool IsSigned, bool InclusiveStop, InsertPointTy ComputeIP=&#123;&#125;, const Twine &amp;Name=&quot;loop&quot;)</>}>
Generator for the control flow structure of an OpenMP canonical loop. <a href="#ac669acbd0f638c6ef32977575362052e">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#afc2cc623eda981e1b3fbb61a44e80ef8">createFlush</a> (const LocationDescription &amp;Loc)</>}>
Generator for &#39;<a href="/docs/api/namespaces/llvm/omp">omp</a> flush&#39;. <a href="#afc2cc623eda981e1b3fbb61a44e80ef8">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<><a href="/docs/api/classes/llvm/canonicalloopinfo">CanonicalLoopInfo</a> &#42;</>}
  name={<><a href="#a445fa52d77040bccb16bfea111234a2e">createLoopSkeleton</a> (DebugLoc DL, Value &#42;TripCount, Function &#42;F, BasicBlock &#42;PreInsertBefore, BasicBlock &#42;PostInsertBefore, const Twine &amp;Name=&#123;&#125;)</>}>
Create the control flow structure of a canonical OpenMP loop. <a href="#a445fa52d77040bccb16bfea111234a2e">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<><a href="#af24d1c61cec57095ced3b08a6dd99ee8">InsertPointOrErrorTy</a></>}
  name={<><a href="#a4f81b9940e1869e146636dc533455929">createParallel</a> (const LocationDescription &amp;Loc, InsertPointTy AllocaIP, BodyGenCallbackTy BodyGenCB, PrivatizeCallbackTy PrivCB, FinalizeCallbackTy FiniCB, Value &#42;IfCondition, Value &#42;NumThreads, omp::ProcBindKind ProcBind, bool IsCancellable)</>}>
Generator for &#39;<a href="/docs/api/namespaces/llvm/omp">omp</a> parallel&#39;. <a href="#a4f81b9940e1869e146636dc533455929">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="std::string"
  name={<><a href="#a488c861f8a68e5f78ceca8b57acd8be5">createPlatformSpecificName</a> (ArrayRef&lt; StringRef &gt; Parts) const</>}>
Get the create a name using the platform specific separators. <a href="#a488c861f8a68e5f78ceca8b57acd8be5">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#a419ffad9e4d59275e299ce1ad3c73cd4">createTaskwait</a> (const LocationDescription &amp;Loc)</>}>
Generator for &#39;<a href="/docs/api/namespaces/llvm/omp">omp</a> taskwait&#39;. <a href="#a419ffad9e4d59275e299ce1ad3c73cd4">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#a0b0ed7f600549e4239bf10b5b85de66c">createTaskyield</a> (const LocationDescription &amp;Loc)</>}>
Generator for &#39;<a href="/docs/api/namespaces/llvm/omp">omp</a> taskyield&#39;. <a href="#a0b0ed7f600549e4239bf10b5b85de66c">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#a784adc2347b72f745ff1239aef3a3c26">finalize</a> (Function &#42;Fn=nullptr)</>}>
Finalize the underlying module, e.g., by outlining regions. <a href="#a784adc2347b72f745ff1239aef3a3c26">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<><a href="/docs/api/classes/llvm/constant">Constant</a> &#42;</>}
  name={<><a href="#afdc1b8675a946ce055c64607ba75af3a">getAddrOfDeclareTargetVar</a> (OffloadEntriesInfoManager::OMPTargetGlobalVarEntryKind CaptureClause, OffloadEntriesInfoManager::OMPTargetDeviceClauseKind DeviceClause, bool IsDeclaration, bool IsExternallyVisible, TargetRegionEntryInfo EntryInfo, StringRef MangledName, std::vector&lt; GlobalVariable &#42; &gt; &amp;GeneratedRefs, bool OpenMPSIMD, std::vector&lt; Triple &gt; TargetTriple, Type &#42;LlvmPtrTy, std::function&lt; Constant &#42;()&gt; GlobalInitializer, std::function&lt; GlobalValue::LinkageTypes()&gt; VariableLinkage)</>}>
Retrieve (or create if non-existent) the address of a declare target variable, used in conjunction with registerTargetGlobalVariable to create declare target global variables. <a href="#afdc1b8675a946ce055c64607ba75af3a">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="unsigned"
  name={<><a href="#ac86b562509588cbc00fbdc441c615bd3">getFlagMemberOffset</a> ()</>}>
Get the offset of the OMP&#95;MAP&#95;MEMBER&#95;OF field. <a href="#ac86b562509588cbc00fbdc441c615bd3">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<><a href="/docs/api/namespaces/llvm/omp/#a02d7a52c47f2d71a111aef9d4fb70ecb">omp::OpenMPOffloadMappingFlags</a></>}
  name={<><a href="#a4f82182a8cc23f854efdbd453f685086">getMemberOfFlag</a> (unsigned Position)</>}>
Get OMP&#95;MAP&#95;MEMBER&#95;OF flag with extra bits reserved based on the position given. <a href="#a4f82182a8cc23f854efdbd453f685086">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<><a href="/docs/api/classes/llvm/globalvariable">GlobalVariable</a> &#42;</>}
  name={<><a href="#aa5ef00e5a7487cc6c5bfed0f301fa1cc">getOrCreateInternalVariable</a> (Type &#42;Ty, const StringRef &amp;Name, unsigned AddressSpace=0)</>}>
Gets (if variable with the given name already exist) or creates internal global variable with the specified Name. <a href="#aa5ef00e5a7487cc6c5bfed0f301fa1cc">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#a1af99f6f33b0db83a3e941fcb819fa29">initialize</a> ()</>}>
Initialize the internal state, this will put structures types and potentially other helpers into the underlying module. <a href="#a1af99f6f33b0db83a3e941fcb819fa29">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#a2242b144e54fa6203dae5c5b27fff17c">loadOffloadInfoMetadata</a> (Module &amp;M)</>}>
Loads all the offload entries information from the host IR metadata. <a href="#a2242b144e54fa6203dae5c5b27fff17c">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#ac6293b7ea84a4deac85481dd10dad437">loadOffloadInfoMetadata</a> (StringRef HostFilePath)</>}>
Loads all the offload entries information from the host IR metadata read from the file passed in as the HostFilePath argument. <a href="#ac6293b7ea84a4deac85481dd10dad437">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#af2e7210874149ecbd52c8ce44ca4f416">popFinalizationCB</a> ()</>}>
Pop the last finalization callback from the finalization stack. <a href="#af2e7210874149ecbd52c8ce44ca4f416">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#a977f2477d245a9d554642492fedd049a">pushFinalizationCB</a> (const FinalizationInfo &amp;FI)</>}>
Push a finalization callback on the finalization stack. <a href="#a977f2477d245a9d554642492fedd049a">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#ae327be8503a76bd4dccfff4713a38553">registerTargetGlobalVariable</a> (OffloadEntriesInfoManager::OMPTargetGlobalVarEntryKind CaptureClause, OffloadEntriesInfoManager::OMPTargetDeviceClauseKind DeviceClause, bool IsDeclaration, bool IsExternallyVisible, TargetRegionEntryInfo EntryInfo, StringRef MangledName, std::vector&lt; GlobalVariable &#42; &gt; &amp;GeneratedRefs, bool OpenMPSIMD, std::vector&lt; Triple &gt; TargetTriple, std::function&lt; Constant &#42;()&gt; GlobalInitializer, std::function&lt; GlobalValue::LinkageTypes()&gt; VariableLinkage, Type &#42;LlvmPtrTy, Constant &#42;Addr)</>}>
Registers a target variable for device or host. <a href="#ae327be8503a76bd4dccfff4713a38553">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#a3cf3a832c89fb823f696ce21ecf37b9b">setConfig</a> (OpenMPIRBuilderConfig C)</>}>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#abeea5a3df7d0266470cd04bb721db70e">setCorrectMemberOfFlag</a> (omp::OpenMPOffloadMappingFlags &amp;Flags, omp::OpenMPOffloadMappingFlags MemberOfFlag)</>}>
Given an initial flag set, this function modifies it to contain the passed in MemberOfFlag generated from the getMemberOfFlag function. <a href="#abeea5a3df7d0266470cd04bb721db70e">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<>std::vector&lt; <a href="/docs/api/classes/llvm/canonicalloopinfo">CanonicalLoopInfo</a> &#42; &gt;</>}
  name={<><a href="#a76e12ec076e7af4be7b8b77a5d53d3fc">tileLoops</a> (DebugLoc DL, ArrayRef&lt; CanonicalLoopInfo &#42; &gt; Loops, ArrayRef&lt; Value &#42; &gt; TileSizes)</>}>
Tile a loop nest. <a href="#a76e12ec076e7af4be7b8b77a5d53d3fc">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#a28a2a9806d828609fe107f766d2dd569">unrollLoopFull</a> (DebugLoc DL, CanonicalLoopInfo &#42;Loop)</>}>
Fully unroll a loop. <a href="#a28a2a9806d828609fe107f766d2dd569">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#a4ca0068cb6a50615c74ecdb8f23839e0">unrollLoopHeuristic</a> (DebugLoc DL, CanonicalLoopInfo &#42;Loop)</>}>
Fully or partially unroll a loop. <a href="#a4ca0068cb6a50615c74ecdb8f23839e0">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#a5e2b7ac5f48193117a340aa15b085719">unrollLoopPartial</a> (DebugLoc DL, CanonicalLoopInfo &#42;Loop, int32&#95;t Factor, CanonicalLoopInfo &#42;&#42;UnrolledCLI)</>}>
Partially unroll a loop. <a href="#a5e2b7ac5f48193117a340aa15b085719">More...</a>
</MembersIndexItem>

</MembersIndex>

## Private Member Functions Index

<MembersIndex>

<MembersIndexItem
  type={<><a href="#af24d1c61cec57095ced3b08a6dd99ee8">InsertPointOrErrorTy</a></>}
  name={<><a href="#a040fad70b742c2d5fb4df1006b8e2fe4">applyDynamicWorkshareLoop</a> (DebugLoc DL, CanonicalLoopInfo &#42;CLI, InsertPointTy AllocaIP, omp::OMPScheduleType SchedType, bool NeedsBarrier, Value &#42;Chunk=nullptr)</>}>
Modifies the canonical loop to be a dynamically-scheduled workshare loop. <a href="#a040fad70b742c2d5fb4df1006b8e2fe4">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<><a href="#af24d1c61cec57095ced3b08a6dd99ee8">InsertPointOrErrorTy</a></>}
  name={<><a href="#ae5ac7c7120c51e85a0a9b107b278773f">applyStaticChunkedWorkshareLoop</a> (DebugLoc DL, CanonicalLoopInfo &#42;CLI, InsertPointTy AllocaIP, bool NeedsBarrier, Value &#42;ChunkSize)</>}>
Modifies the canonical loop a statically-scheduled workshare loop with a user-specified chunk size. <a href="#ae5ac7c7120c51e85a0a9b107b278773f">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<><a href="#af24d1c61cec57095ced3b08a6dd99ee8">InsertPointOrErrorTy</a></>}
  name={<><a href="#a4844b18964505b7687f7261c6eccde30">applyStaticWorkshareLoop</a> (DebugLoc DL, CanonicalLoopInfo &#42;CLI, InsertPointTy AllocaIP, bool NeedsBarrier)</>}>
Modifies the canonical loop to be a statically-scheduled workshare loop. <a href="#a4844b18964505b7687f7261c6eccde30">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<><a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a></>}
  name={<><a href="#a3614ae5b7da8dfc1d3b6e74e3b114ae8">applyWorkshareLoopTarget</a> (DebugLoc DL, CanonicalLoopInfo &#42;CLI, InsertPointTy AllocaIP, omp::WorksharingLoopType LoopType)</>}>
Modifies the canonical loop to be a statically-scheduled workshare loop which is executed on the device. <a href="#a3614ae5b7da8dfc1d3b6e74e3b114ae8">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#af94ce0ccebe00cffe61b5a50ba679eb8">createIfVersion</a> (CanonicalLoopInfo &#42;Loop, Value &#42;IfCond, ValueToValueMapTy &amp;VMap, const Twine &amp;NamePrefix=&quot;&quot;)</>}>
Create alternative version of the loop to support if clause. <a href="#af94ce0ccebe00cffe61b5a50ba679eb8">More...</a>
</MembersIndexItem>

</MembersIndex>

## Public Member Attributes Index

<MembersIndex>

<MembersIndexItem
  type={<><a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> std::string</>}
  name={<><a href="#aefadc356da16598ff8c210dafbf4a2b7">ompOffloadInfoName</a> = &quot;omp&#95;offload.info&quot;</>}>
OMP Offload Info <a href="/docs/api/classes/llvm/metadata">Metadata</a> name string. <a href="#aefadc356da16598ff8c210dafbf4a2b7">More...</a>
</MembersIndexItem>

</MembersIndex>

## Public Static Functions Index

<MembersIndex>

<MembersIndexItem
  type="unsigned"
  name={<><a href="#ac5b407054e7727d04053af9c3f1a5568">getOpenMPDefaultSimdAlign</a> (const Triple &amp;TargetTriple, const StringMap&lt; bool &gt; &amp;Features)</>}>
Get the default alignment value for given target. <a href="#ac5b407054e7727d04053af9c3f1a5568">More...</a>
</MembersIndexItem>

</MembersIndex>

## Description {#details}

An interface to create LLVM-IR for OpenMP directives.

Each OpenMP directive has a corresponding public generator method.

Definition at line 474 of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>.

<SectionDefinition>

## Public Member Typedefs

### BodyGenCallbackTy {#a49e35e3ee470add16efcde1ab5d5556b}

<MemberDefinition
  prototype={<>using llvm::OpenMPIRBuilder::BodyGenCallbackTy = 
      function&#95;ref&lt;Error(InsertPointTy AllocaIP, InsertPointTy CodeGenIP)&gt;</>}>
Callback type for body (=inner region) code generation.

The callback takes code locations as arguments, each describing a location where additional instructions can be inserted.

The CodeGenIP may be in the middle of a basic block or point to the end of it. The basic block may have a terminator or be degenerate. The callback function may just insert instructions at that position, but also split the block (without the Before argument of <a href="/docs/api/classes/llvm/basicblock/#a52c990590792c91dd20b6d45acebe359">BasicBlock::splitBasicBlock</a> such that the identify of the split predecessor block is preserved) and insert additional control flow, including branches that do not lead back to what follows the CodeGenIP. Note that since the callback is allowed to split the block, callers must assume that InsertPoints to positions in the <a href="/docs/api/classes/llvm/basicblock">BasicBlock</a> after CodeGenIP including CodeGenIP itself are invalidated. If such InsertPoints need to be preserved, it can split the block itself before calling the callback.

AllocaIP and CodeGenIP must not point to the same position.


<ParametersList title="Parameters">
<ParametersListItem name="AllocaIP">is the insertion point at which new alloca instructions should be placed. The <a href="/docs/api/classes/llvm/basicblock">BasicBlock</a> it is pointing to must not be split.</ParametersListItem>
<ParametersListItem name="CodeGenIP">is the insertion point at which the body code should be placed.</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
an error, if any were triggered during execution.
</SectionUser>

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l00596">596</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>.
</MemberDefinition>

### FinalizeCallbackTy {#a0c571620ff53fdb78e7404f5261dbd23}

<MemberDefinition
  prototype={<>using llvm::OpenMPIRBuilder::FinalizeCallbackTy =  std::function&lt;Error(InsertPointTy CodeGenIP)&gt;</>}>
Callback type for variable finalization (think destructors).

<ParametersList title="Parameters">
<ParametersListItem name="CodeGenIP">is the insertion point at which the finalization code should be placed.</ParametersListItem>
</ParametersList>
A finalize callback knows about all objects that need finalization, e.g. destruction, when the scope of the currently generated construct is left at the time, and location, the callback is invoked.

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l00543">543</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>.
</MemberDefinition>

### InsertPointOrErrorTy {#af24d1c61cec57095ced3b08a6dd99ee8}

<MemberDefinition
  prototype={<>using llvm::OpenMPIRBuilder::InsertPointOrErrorTy =  Expected&lt;InsertPointTy&gt;</>}>
<a href="/docs/api/classes/llvm/type">Type</a> used to represent an insertion point or an error value.

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l00523">523</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>.
</MemberDefinition>

### InsertPointTy {#aafc1886793b898052f87edd7e9fdbaa3}

<MemberDefinition
  prototype={<>using llvm::OpenMPIRBuilder::InsertPointTy =  IRBuilder&lt;&gt;::InsertPoint</>}>
<a href="/docs/api/classes/llvm/type">Type</a> used throughout for insertion points.

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l00520">520</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>.
</MemberDefinition>

### LoopBodyGenCallbackTy {#a296d2e28bddf1051d614f48b61005899}

<MemberDefinition
  prototype={<>using llvm::OpenMPIRBuilder::LoopBodyGenCallbackTy = 
      function&#95;ref&lt;Error(InsertPointTy CodeGenIP, Value &#42;IndVar)&gt;</>}>
Callback type for loop body code generation.

<ParametersList title="Parameters">
<ParametersListItem name="CodeGenIP">is the insertion point where the loop&#39;s body code must be placed. This will be a dedicated <a href="/docs/api/classes/llvm/basicblock">BasicBlock</a> with a conditional branch from the loop condition check and terminated with an unconditional branch to the loop latch.</ParametersListItem>
<ParametersListItem name="IndVar">is the induction variable usable at the insertion point.</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
an error, if any were triggered during execution.
</SectionUser>

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l00618">618</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>.
</MemberDefinition>

### PrivatizeCallbackTy {#a71b5ba020f68829f5a1fd99f48b63d42}

<MemberDefinition
  prototype={<>using llvm::OpenMPIRBuilder::PrivatizeCallbackTy =  function&#95;ref&lt;InsertPointOrErrorTy(
      InsertPointTy AllocaIP, InsertPointTy CodeGenIP, Value &amp;Original,
      Value &amp;Inner, Value &#42;&amp;ReplVal)&gt;</>}>
Callback type for variable privatization (think copy &amp; default constructor).

<ParametersList title="Parameters">
<ParametersListItem name="AllocaIP">is the insertion point at which new alloca instructions should be placed.</ParametersListItem>
<ParametersListItem name="CodeGenIP">is the insertion point at which the privatization code should be placed.</ParametersListItem>
<ParametersListItem name="Original">The value being copied/created, should not be used in the generated IR.</ParametersListItem>
<ParametersListItem name="Inner">The equivalent of <code>Original</code> that should be used in the generated IR; this is equal to <code>Original</code> if the value is a pointer and can thus be passed directly, otherwise it is an equivalent but different value.</ParametersListItem>
<ParametersListItem name="ReplVal">The replacement value, thus a copy or new created version of <code>Inner</code>.</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
The new insertion point where code generation continues and <code>ReplVal</code> the replacement value.
</SectionUser>

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l00639">639</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>.
</MemberDefinition>

### StorableBodyGenCallbackTy {#a761a2c853c1d16b33e4e8c565ce0ca45}

<MemberDefinition
  prototype={<>using llvm::OpenMPIRBuilder::StorableBodyGenCallbackTy = 
      std::function&lt;Error(InsertPointTy AllocaIP, InsertPointTy CodeGenIP)&gt;</>}>

<SectionUser title="Returns">
an error, if any were triggered during execution.
</SectionUser>

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l00605">605</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>.
</MemberDefinition>

</SectionDefinition>

<SectionDefinition>

## Public Constructors

### OpenMPIRBuilder() {#ae1a990c96a3ebf58698901d09c5b4378}

<MemberDefinition
  prototype={<>llvm::OpenMPIRBuilder::OpenMPIRBuilder (<a href="/docs/api/classes/llvm/module">Module</a> &amp; M)</>}
  labels = {["inline"]}>
Create a new <a href="/docs/api/classes/llvm/openmpirbuilder">OpenMPIRBuilder</a> operating on the given module <code>M</code>.

This will not have an effect on <code>M</code> (see initialize)

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l00478">478</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>.
</MemberDefinition>

</SectionDefinition>

<SectionDefinition>

## Public Destructor

### ~OpenMPIRBuilder() {#ad66949e2e846451e61d9c8f34014ea31}

<MemberDefinition
  prototype="OpenMPIRBuilder::~OpenMPIRBuilder ()">

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l00481">481</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>, definition at line <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp/#l00845">845</a> of file <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp">OMPIRBuilder.cpp</a>.
</MemberDefinition>

</SectionDefinition>

<SectionDefinition>

## Public Member Functions

### addAttributes() {#a50c6490cf353f064946c4e32673ac098}

<MemberDefinition
  prototype={<>void OpenMPIRBuilder::addAttributes (<a href="/docs/api/namespaces/llvm/omp/#a4c503140c7f851151906d85b515330e9">omp::RuntimeFunction</a> FnID, <a href="/docs/api/classes/llvm/function">Function</a> &amp; Fn)</>}>
Add attributes known for <code>FnID</code> to <code>Fn</code>.

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l00517">517</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>, definition at line <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp/#l00562">562</a> of file <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp">OMPIRBuilder.cpp</a>.
</MemberDefinition>

### applySimd() {#acd1fbb2df257f945afda92919be322f3}

<MemberDefinition
  prototype={<>void OpenMPIRBuilder::applySimd (<a href="/docs/api/classes/llvm/canonicalloopinfo">CanonicalLoopInfo</a> &#42; Loop, <a href="/docs/api/classes/llvm/mapvector">MapVector</a>&lt; <a href="/docs/api/classes/llvm/value">Value</a> &#42;, <a href="/docs/api/classes/llvm/value">Value</a> &#42; &gt; AlignedVars, <a href="/docs/api/classes/llvm/value">Value</a> &#42; IfCond, omp::OrderKind Order, <a href="/docs/api/classes/llvm/constantint">ConstantInt</a> &#42; Simdlen, <a href="/docs/api/classes/llvm/constantint">ConstantInt</a> &#42; Safelen)</>}>
Add metadata to simd-ize a loop.

If IfCond is not nullptr, the loop is cloned. The metadata which prevents vectorization is added to to the cloned loop. The cloned loop is executed when ifCond is evaluated to false.


<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/classes/llvm/loop&quot;>Loop</a>">The loop to simd-ize.</ParametersListItem>
<ParametersListItem name="AlignedVars">The map which containts pairs of the pointer and its corresponding alignment.</ParametersListItem>
<ParametersListItem name="IfCond">The value which corresponds to the if clause condition.</ParametersListItem>
<ParametersListItem name="Order">The enum to map order clause.</ParametersListItem>
<ParametersListItem name="Simdlen">The Simdlen length to apply to the simd loop.</ParametersListItem>
<ParametersListItem name="Safelen">The Safelen length to apply to the simd loop.</ParametersListItem>
</ParametersList>

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l01219">1219</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>, definition at line <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp/#l05342">5342</a> of file <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp">OMPIRBuilder.cpp</a>.
</MemberDefinition>

### applyWorkshareLoop() {#adaa14806d128ad33bdc48d2bfc46870c}

<MemberDefinition
  prototype={<>OpenMPIRBuilder::InsertPointOrErrorTy OpenMPIRBuilder::applyWorkshareLoop (<a href="/docs/api/classes/llvm/debugloc">DebugLoc</a> DL, <a href="/docs/api/classes/llvm/canonicalloopinfo">CanonicalLoopInfo</a> &#42; CLI, <a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> AllocaIP, bool NeedsBarrier, llvm::omp::ScheduleKind SchedKind=llvm::omp::OMP&#95;SCHEDULE&#95;Default, <a href="/docs/api/classes/llvm/value">Value</a> &#42; ChunkSize=nullptr, bool HasSimdModifier=false, bool HasMonotonicModifier=false, bool HasNonmonotonicModifier=false, bool HasOrderedClause=false, <a href="/docs/api/namespaces/llvm/omp/#ab6fb146c332fd3f3d677ee65081fe669">omp::WorksharingLoopType</a> LoopType=<a href="/docs/api/namespaces/llvm/omp/#ab6fb146c332fd3f3d677ee65081fe669a45663d75b039e00b6412fb82fed8c306">omp::WorksharingLoopType::ForStaticLoop</a>)</>}>
Modifies the canonical loop to be a workshare loop.

This takes a <code><a href="/docs/api/classes/llvm/loopinfo">LoopInfo</a></code> representing a canonical loop, such as the one created by <code>createCanonicalLoop</code> and emits additional instructions to turn it into a workshare loop. In particular, it calls to an OpenMP runtime function in the preheader to obtain the loop bounds to be used in the current thread, updates the relevant instructions in the canonical loop and calls to an OpenMP runtime finalization function after the loop.

The concrete transformation is done by applyStaticWorkshareLoop, applyStaticChunkedWorkshareLoop, or applyDynamicWorkshareLoop, depending on the value of <code>SchedKind</code> and <code>ChunkSize</code>.


<ParametersList title="Parameters">
<ParametersListItem name="DL">Debug location for instructions added for the workshare-loop construct itself.</ParametersListItem>
<ParametersListItem name="CLI">A descriptor of the canonical loop to workshare.</ParametersListItem>
<ParametersListItem name="AllocaIP">An insertion point for Alloca instructions usable in the preheader of the loop.</ParametersListItem>
<ParametersListItem name="NeedsBarrier">Indicates whether a barrier must be insterted after the loop.</ParametersListItem>
<ParametersListItem name="SchedKind">Scheduling algorithm to use.</ParametersListItem>
<ParametersListItem name="ChunkSize">The chunk size for the inner loop.</ParametersListItem>
<ParametersListItem name="HasSimdModifier">Whether the simd modifier is present in the schedule clause.</ParametersListItem>
<ParametersListItem name="HasMonotonicModifier">Whether the monotonic modifier is present in the schedule clause.</ParametersListItem>
<ParametersListItem name="HasNonmonotonicModifier">Whether the nonmonotonic modifier is present in the schedule clause.</ParametersListItem>
<ParametersListItem name="HasOrderedClause">Whether the (parameterless) ordered clause is present.</ParametersListItem>
<ParametersListItem name="LoopType">Information about type of loop worksharing. It corresponds to type of loop workshare OpenMP pragma.</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
Point where to insert code after the workshare construct.
</SectionUser>

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l01107">1107</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>, definition at line <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp/#l04621">4621</a> of file <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp">OMPIRBuilder.cpp</a>.
</MemberDefinition>

### collapseLoops() {#a08610118e213de1b759470f0eafb9b18}

<MemberDefinition
  prototype={<>CanonicalLoopInfo &#42; OpenMPIRBuilder::collapseLoops (<a href="/docs/api/classes/llvm/debugloc">DebugLoc</a> DL, <a href="/docs/api/classes/llvm/arrayref">ArrayRef</a>&lt; <a href="/docs/api/classes/llvm/canonicalloopinfo">CanonicalLoopInfo</a> &#42; &gt; Loops, <a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> ComputeIP)</>}>
Collapse a loop nest into a single loop.

Merges loops of a loop nest into a single CanonicalLoopNest representation that has the same number of innermost loop iterations as the origin loop nest. The induction variables of the input loops are derived from the collapsed loop&#39;s induction variable. This is intended to be used to implement OpenMP&#39;s collapse clause. Before applying a directive, collapseLoops normalizes a loop nest to contain only a single loop and the directive&#39;s implementation does not need to handle multiple loops itself. This does not remove the need to handle all loop nest handling by directives, such as the ordered(&lt;n&gt;) clause or the simd schedule-clause modifier of the worksharing-loop directive.

Example: 
<ProgramListing>

<CodeLine><span class="doxyHighlightKeywordFlow">for</span><span class="doxyHighlight"> (</span><span class="doxyHighlightKeywordType">int</span><span class="doxyHighlight"> i = 0; i &lt; 7; ++i) </span><span class="doxyHighlightComment">// Canonical loop &quot;i&quot;</span></CodeLine>
<CodeLine><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">for</span><span class="doxyHighlight"> (</span><span class="doxyHighlightKeywordType">int</span><span class="doxyHighlight"> j = 0; <a href="/docs/api/namespaces/llvm/m68k/#ab3a288f2953d8eca3e363959fc2cf38ea363b122c528f54df4a0446b6bab05515">j</a> &lt; 9; ++<a href="/docs/api/namespaces/llvm/m68k/#ab3a288f2953d8eca3e363959fc2cf38ea363b122c528f54df4a0446b6bab05515">j</a>) </span><span class="doxyHighlightComment">// Canonical loop &quot;j&quot;</span></CodeLine>
<CodeLine><span class="doxyHighlight">    body(i, j);</span></CodeLine>

</ProgramListing>


After collapsing with Loops=&#123;i,j&#125;, the loop is changed to 
<ProgramListing>

<CodeLine><span class="doxyHighlightKeywordFlow">for</span><span class="doxyHighlight"> (</span><span class="doxyHighlightKeywordType">int</span><span class="doxyHighlight"> ij = 0; ij &lt; 63; ++ij) &#123;</span></CodeLine>
<CodeLine><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordType">int</span><span class="doxyHighlight"> i = ij / 9;</span></CodeLine>
<CodeLine><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordType">int</span><span class="doxyHighlight"> <a href="/docs/api/namespaces/llvm/m68k/#ab3a288f2953d8eca3e363959fc2cf38ea363b122c528f54df4a0446b6bab05515">j</a> = ij % 9;</span></CodeLine>
<CodeLine><span class="doxyHighlight">  body(i, j);</span></CodeLine>
<CodeLine><span class="doxyHighlight">&#125;</span></CodeLine>

</ProgramListing>


In the current implementation, the following limitations apply:


<ul>
<li>All input loops have an induction variable of the same type.</li>
<li>The collapsed loop will have the same trip count integer type as the input loops. Therefore it is possible that the collapsed loop cannot represent all iterations of the input loops. For instance, assuming a 32 bit integer type, and two input loops both iterating 2^16 times, the theoretical trip count of the collapsed loop would be 2^32 iteration, which cannot be represented in an 32-bit integer. Behavior is undefined in this case.</li>
<li>The trip counts of every input loop must be available at <code>ComputeIP</code>. Non-rectangular loops are not yet supported.</li>
<li>At each nest level, code between a surrounding loop and its nested loop is hoisted into the loop body, and such code will be executed more often than before collapsing (or not at all if any inner loop iteration has a trip count of 0). This is permitted by the OpenMP specification.</li>
</ul>



<ParametersList title="Parameters">
<ParametersListItem name="DL">Debug location for instructions added for collapsing, such as instructions to compute/derive the input loop&#39;s induction variables.</ParametersListItem>
<ParametersListItem name="Loops">Loops in the loop nest to collapse. Loops are specified from outermost-to-innermost and every control flow of a loop&#39;s body must pass through its directly nested loop.</ParametersListItem>
<ParametersListItem name="ComputeIP">Where additional instruction that compute the collapsed trip count. If not set, defaults to before the generated loop.</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
The <a href="/docs/api/classes/llvm/canonicalloopinfo">CanonicalLoopInfo</a> object representing the collapsed loop.
</SectionUser>

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l00842">842</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>, definition at line <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp/#l04887">4887</a> of file <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp">OMPIRBuilder.cpp</a>.
</MemberDefinition>

### createAtomicCapture() {#a6cc340cf5dc46cf45eb6f784577cadbd}

<MemberDefinition
  prototype={<>OpenMPIRBuilder::InsertPointOrErrorTy OpenMPIRBuilder::createAtomicCapture (<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/structs/llvm/openmpirbuilder/locationdescription">LocationDescription</a> &amp; Loc, <a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> AllocaIP, AtomicOpValue &amp; X, AtomicOpValue &amp; V, <a href="/docs/api/classes/llvm/value">Value</a> &#42; Expr, <a href="/docs/api/namespaces/llvm/#a9bccbe67aaab722783ca4e7c504aaaa7">AtomicOrdering</a> AO, <a href="/docs/api/classes/llvm/atomicrmwinst/#a461cfbbb5c7a57ab73210498923cf615">AtomicRMWInst::BinOp</a> RMWOp, AtomicUpdateCallbackTy &amp; UpdateOp, bool UpdateExpr, bool IsPostfixUpdate, bool IsXBinopExpr)</>}>
Emit atomic update for constructs: — Only Scalar data types V = X; X = X BinOp Expr , X = X BinOp Expr; V = X, V = X; X = Expr BinOp X, X = Expr BinOp X; V = X, V = X; X = UpdateOp(X), X = UpdateOp(X); V = X,.

<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The insert and source location description.</ParametersListItem>
<ParametersListItem name="AllocaIP">The insertion point to be used for alloca instructions.</ParametersListItem>
<ParametersListItem name="X">The target atomic pointer to be updated</ParametersListItem>
<ParametersListItem name="V"><a href="/docs/api/classes/llvm/sys/memory">Memory</a> address where to store captured value</ParametersListItem>
<ParametersListItem name="Expr">The value to update X with.</ParametersListItem>
<ParametersListItem name="AO">Atomic ordering of the generated atomic instructions</ParametersListItem>
<ParametersListItem name="RMWOp">The binary operation used for update. If operation is not supported by atomicRMW, or belong to &#123;FADD, FSUB, BAD&#95;BINOP&#125;. Then a cmpExch based atomic will be generated.</ParametersListItem>
<ParametersListItem name="UpdateOp">Code generator for complex expressions that cannot be expressed through atomicrmw instruction.</ParametersListItem>
<ParametersListItem name="UpdateExpr">true if X is an in place update of the form X = X BinOp Expr or X = Expr BinOp X</ParametersListItem>
<ParametersListItem name="IsXBinopExpr">true if X is Left H.S. in Right H.S. part of the update expression, false otherwise. (e.g. true for X = X BinOp Expr)</ParametersListItem>
<ParametersListItem name="IsPostfixUpdate">true if original value of &#39;x&#39; must be stored in &#39;v&#39;, not an updated one.</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
Insertion point after generated atomic capture IR.
</SectionUser>

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l03299">3299</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>, definition at line <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp/#l08793">8793</a> of file <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp">OMPIRBuilder.cpp</a>.
</MemberDefinition>

### createAtomicCompare() {#a6c4eeba23c6f192892487de272e8ce72}

<MemberDefinition
  prototype={<>OpenMPIRBuilder::InsertPointTy OpenMPIRBuilder::createAtomicCompare (<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/structs/llvm/openmpirbuilder/locationdescription">LocationDescription</a> &amp; Loc, AtomicOpValue &amp; X, AtomicOpValue &amp; V, AtomicOpValue &amp; R, <a href="/docs/api/classes/llvm/value">Value</a> &#42; E, <a href="/docs/api/classes/llvm/value">Value</a> &#42; D, <a href="/docs/api/namespaces/llvm/#a9bccbe67aaab722783ca4e7c504aaaa7">AtomicOrdering</a> AO, <a href="/docs/api/namespaces/llvm/omp/#acb593a387130148478f3c30af0d322df">omp::OMPAtomicCompareOp</a> Op, bool IsXBinopExpr, bool IsPostfixUpdate, bool IsFailOnly)</>}>
Emit atomic compare for constructs: — Only scalar data types cond-expr-stmt: x = x ordop expr ?

expr : x; x = expr ordop x ? expr : x; x = x == e ? d : x; x = e == x ? d : x; (this one is not in the spec) cond-update-stmt: if (x ordop expr) &#123; x = expr; &#125; if (expr ordop x) &#123; x = expr; &#125; if (x == e) &#123; x = d; &#125; if (e == x) &#123; x = d; &#125; (this one is not in the spec) conditional-update-capture-atomic: v = x; cond-update-stmt; (IsPostfixUpdate=true, IsFailOnly=false) cond-update-stmt; v = x; (IsPostfixUpdate=false, IsFailOnly=false) if (x == e) &#123; x = d; &#125; else &#123; v = x; &#125; (IsPostfixUpdate=false, IsFailOnly=true) r = x == e; if (r) &#123; x = d; &#125; (IsPostfixUpdate=false, IsFailOnly=false) r = x == e; if (r) &#123; x = d; &#125; else &#123; v = x; &#125; (IsPostfixUpdate=false, IsFailOnly=true)


<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The insert and source location description.</ParametersListItem>
<ParametersListItem name="X">The target atomic pointer to be updated.</ParametersListItem>
<ParametersListItem name="V"><a href="/docs/api/classes/llvm/sys/memory">Memory</a> address where to store captured value (for compare capture only).</ParametersListItem>
<ParametersListItem name="R"><a href="/docs/api/classes/llvm/sys/memory">Memory</a> address where to store comparison result (for compare capture with &#39;==&#39; only).</ParametersListItem>
<ParametersListItem name="E">The expected value (&#39;e&#39;) for forms that use an equality comparison or an expression (&#39;expr&#39;) for forms that use &#39;ordop&#39; (logically an atomic maximum or minimum).</ParametersListItem>
<ParametersListItem name="D">The desired value for forms that use an equality comparison. If forms that use &#39;ordop&#39;, it should be <code>nullptr</code>.</ParametersListItem>
<ParametersListItem name="AO">Atomic ordering of the generated atomic instructions.</ParametersListItem>
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/#ab471937b9a227e70c7fe8bd9604014d6&quot;>Op</a>">Atomic compare operation. It can only be ==, &lt;, or &gt;.</ParametersListItem>
<ParametersListItem name="IsXBinopExpr">True if the conditional statement is in the form where x is on LHS. It only matters for &lt; or &gt;.</ParametersListItem>
<ParametersListItem name="IsPostfixUpdate">True if original value of &#39;x&#39; must be stored in &#39;v&#39;, not an updated one (for compare capture only).</ParametersListItem>
<ParametersListItem name="IsFailOnly">True if the original value of &#39;x&#39; is stored to &#39;v&#39; only when the comparison fails. This is only valid for the case the comparison is &#39;==&#39;.</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
Insertion point after generated atomic capture IR.
</SectionUser>

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l03351">3351</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>, definition at line <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp/#l08831">8831</a> of file <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp">OMPIRBuilder.cpp</a>.
</MemberDefinition>

### createAtomicCompare() {#ab84af206a9a08b9bf97eaadc87874c6c}

<MemberDefinition
  prototype={<>OpenMPIRBuilder::InsertPointTy OpenMPIRBuilder::createAtomicCompare (<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/structs/llvm/openmpirbuilder/locationdescription">LocationDescription</a> &amp; Loc, AtomicOpValue &amp; X, AtomicOpValue &amp; V, AtomicOpValue &amp; R, <a href="/docs/api/classes/llvm/value">Value</a> &#42; E, <a href="/docs/api/classes/llvm/value">Value</a> &#42; D, <a href="/docs/api/namespaces/llvm/#a9bccbe67aaab722783ca4e7c504aaaa7">AtomicOrdering</a> AO, <a href="/docs/api/namespaces/llvm/omp/#acb593a387130148478f3c30af0d322df">omp::OMPAtomicCompareOp</a> Op, bool IsXBinopExpr, bool IsPostfixUpdate, bool IsFailOnly, <a href="/docs/api/namespaces/llvm/#a9bccbe67aaab722783ca4e7c504aaaa7">AtomicOrdering</a> Failure)</>}>

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l03355">3355</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>, definition at line <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp/#l08842">8842</a> of file <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp">OMPIRBuilder.cpp</a>.
</MemberDefinition>

### createAtomicUpdate() {#ae75c4b44f208011259ee93497c2cb411}

<MemberDefinition
  prototype={<>OpenMPIRBuilder::InsertPointOrErrorTy OpenMPIRBuilder::createAtomicUpdate (<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/structs/llvm/openmpirbuilder/locationdescription">LocationDescription</a> &amp; Loc, <a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> AllocaIP, AtomicOpValue &amp; X, <a href="/docs/api/classes/llvm/value">Value</a> &#42; Expr, <a href="/docs/api/namespaces/llvm/#a9bccbe67aaab722783ca4e7c504aaaa7">AtomicOrdering</a> AO, <a href="/docs/api/classes/llvm/atomicrmwinst/#a461cfbbb5c7a57ab73210498923cf615">AtomicRMWInst::BinOp</a> RMWOp, AtomicUpdateCallbackTy &amp; UpdateOp, bool IsXBinopExpr)</>}>
Generator for <code>#omp task</code>

<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The location where the task construct was encountered.</ParametersListItem>
<ParametersListItem name="AllocaIP">The insertion point to be used for alloca instructions.</ParametersListItem>
<ParametersListItem name="BodyGenCB">Callback that will generate the region code.</ParametersListItem>
<ParametersListItem name="Tied">True if the task is tied, false if the task is untied.</ParametersListItem>
<ParametersListItem name="Final">i1 value which is <code>true</code> if the task is final, <code>false</code> if the task is not final.</ParametersListItem>
<ParametersListItem name="IfCondition">i1 value. If it evaluates to <code>false</code>, an undeferred task is generated, and the encountering thread must suspend the current task region, for which execution cannot be resumed until execution of the structured block that is associated with the generated task is completed.</ParametersListItem>
<ParametersListItem name="EventHandle">If present, signifies the event handle as part of the detach clause</ParametersListItem>
<ParametersListItem name="Mergeable">If the given task is <code>mergeable</code></ParametersListItem>
<ParametersListItem name="priority">‘priority-value` specifies the execution order of the / tasks that is generated by the construct <a href="#af24d1c61cec57095ced3b08a6dd99ee8">InsertPointOrErrorTy</a> createTask(const <a href="/docs/api/structs/llvm/openmpirbuilder/locationdescription">LocationDescription</a> &amp;<a href="/docs/api/namespaces/llvm/loc">Loc</a>, <a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> AllocaIP, <a href="#a49e35e3ee470add16efcde1ab5d5556b">BodyGenCallbackTy</a> BodyGenCB, bool Tied = true, <a href="/docs/api/classes/llvm/value">Value</a> &#42;Final = nullptr, <a href="/docs/api/classes/llvm/value">Value</a> &#42;IfCondition = nullptr, <a href="/docs/api/classes/llvm/smallvector">SmallVector&lt;DependData&gt;</a> Dependencies = &#123;&#125;, bool Mergeable = false, <a href="/docs/api/classes/llvm/value">Value</a> &#42;EventHandle = nullptr, <a href="/docs/api/classes/llvm/value">Value</a> &#42;Priority = nullptr);</ParametersListItem>
</ParametersList>
/ Generator for the taskgroup construct / /
<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The location where the taskgroup construct was encountered. /</ParametersListItem>
<ParametersListItem name="AllocaIP">The insertion point to be used for alloca instructions. /</ParametersListItem>
<ParametersListItem name="BodyGenCB">
Callback that will generate the region code. <a href="#af24d1c61cec57095ced3b08a6dd99ee8">InsertPointOrErrorTy</a> createTaskgroup(const LocationDescription &amp;Loc,
                                       InsertPointTy AllocaIP,
                                       BodyGenCallbackTy BodyGenCB);
</ParametersListItem>
</ParametersList>
using FileIdentifierInfoCallbackTy = std::function&lt;std::tuple&lt;std::string, uint64&#95;t&gt;()&gt;;

/ Creates a unique info for a target entry when provided a filename and / line number from. / /
<ParametersList title="Parameters">
<ParametersListItem name="CallBack">A callback function which should return filename the entry / resides in as well as the line number for the target entry /</ParametersListItem>
<ParametersListItem name="ParentName">The name of the parent the target entry resides in, if / any. static <a href="/docs/api/structs/llvm/targetregionentryinfo">TargetRegionEntryInfo</a> getTargetEntryUniqueInfo(FileIdentifierInfoCallbackTy CallBack, <a href="/docs/api/classes/llvm/stringref">StringRef</a> ParentName = &quot;&quot;);</ParametersListItem>
</ParametersList>
/ Enum class for the RedctionGen CallBack type to be used. enum class ReductionGenCBKind &#123; Clang, MLIR &#125;;

/ ReductionGen CallBack for Clang / /
<ParametersList title="Parameters">
<ParametersListItem name="CodeGenIP"><a href="/docs/api/classes/llvm/irbuilder">InsertPoint</a> for CodeGen. /</ParametersListItem>
<ParametersListItem name="Index">Index of the ReductionInfo to generate code for. /</ParametersListItem>
<ParametersListItem name="LHSPtr">Optionally used by Clang to return the LHSPtr it used for / codegen, used for fixup later. /</ParametersListItem>
<ParametersListItem name="RHSPtr">Optionally used by Clang to / return the RHSPtr it used for codegen, used for fixup later. /</ParametersListItem>
<ParametersListItem name="CurFn">
Optionally used by Clang to pass in the Current <a href="/docs/api/classes/llvm/function">Function</a> as / Clang context may be old. using ReductionGenClangCBTy = std::function&lt;<a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy(InsertPointTy CodeGenIP, unsigned Index,
                                  Value &#42;&#42;LHS, Value &#42;&#42;RHS, Function &#42;CurFn)</a>&gt;;
</ParametersListItem>
</ParametersList>
/ ReductionGen CallBack for MLIR / /
<ParametersList title="Parameters">
<ParametersListItem name="CodeGenIP"><a href="/docs/api/classes/llvm/irbuilder">InsertPoint</a> for CodeGen. /</ParametersListItem>
<ParametersListItem name="LHS"><a href="/docs/api/classes/llvm/pass">Pass</a> in the LHS <a href="/docs/api/classes/llvm/value">Value</a> to be used for CodeGen. /</ParametersListItem>
<ParametersListItem name="RHS">
<a href="/docs/api/classes/llvm/pass">Pass</a> in the RHS <a href="/docs/api/classes/llvm/value">Value</a> to be used for CodeGen. using ReductionGenCBTy = std::function&lt;<a href="#af24d1c61cec57095ced3b08a6dd99ee8">InsertPointOrErrorTy(
      InsertPointTy CodeGenIP, Value &#42;LHS, Value &#42;RHS, Value &#42;&amp;Res)</a>&gt;;
</ParametersListItem>
</ParametersList>
/ Functions used to generate atomic reductions. Such functions take two / Values representing pointers to LHS and RHS of the reduction, as well as / the element type of these pointers. They are expected to atomically / update the LHS to the reduced value. using ReductionGenAtomicCBTy = std::function&lt;<a href="#af24d1c61cec57095ced3b08a6dd99ee8">InsertPointOrErrorTy(
      InsertPointTy, Type &#42;, Value &#42;, Value &#42;)</a>&gt;;

/ Enum class for reduction evaluation types scalar, complex and aggregate. enum class EvalKind &#123; Scalar, Complex, Aggregate &#125;;

/ Information about an OpenMP reduction. struct ReductionInfo &#123; ReductionInfo(Type &#42;ElementType, Value &#42;Variable, Value &#42;PrivateVariable,
                  EvalKind EvaluationKind, ReductionGenCBTy ReductionGen,
                  ReductionGenClangCBTy ReductionGenClang,
                  ReductionGenAtomicCBTy AtomicReductionGen) : ElementType(ElementType), Variable(Variable), PrivateVariable(PrivateVariable), EvaluationKind(EvaluationKind), ReductionGen(ReductionGen), ReductionGenClang(ReductionGenClang), AtomicReductionGen(AtomicReductionGen) &#123;&#125; ReductionInfo(Value &#42;PrivateVariable) : ElementType(nullptr), Variable(nullptr), PrivateVariable(PrivateVariable), EvaluationKind(EvalKind::Scalar), ReductionGen(), ReductionGenClang(), AtomicReductionGen() &#123;&#125;

/ Reduction element type, must match pointee type of variable. <a href="/docs/api/classes/llvm/type">Type</a> &#42;ElementType;

/ Reduction variable of pointer type. <a href="/docs/api/classes/llvm/value">Value</a> &#42;Variable;

/ Thread-private partial reduction variable. <a href="/docs/api/classes/llvm/value">Value</a> &#42;PrivateVariable;

/ Reduction evaluation kind - scalar, complex or aggregate. EvalKind EvaluationKind;

/ Callback for generating the reduction body. The IR produced by this will / be used to combine two values in a thread-safe context, e.g., under / lock or within the same thread, and therefore need not be atomic. ReductionGenCBTy ReductionGen;

/ Clang callback for generating the reduction body. The IR produced by / this will be used to combine two values in a thread-safe context, e.g., / under lock or within the same thread, and therefore need not be atomic. ReductionGenClangCBTy ReductionGenClang;

/ Callback for generating the atomic reduction body, may be null. The IR / produced by this will be used to atomically combine two values during / reduction. If null, the implementation will use the non-atomic version / along with the appropriate synchronization mechanisms. ReductionGenAtomicCBTy AtomicReductionGen; &#125;;

enum class CopyAction : unsigned &#123; RemoteLaneToThread: Copy over a Reduce list from a remote lane in the warp using shuffle instructions. RemoteLaneToThread, ThreadCopy: Make a copy of a Reduce list on the thread&#39;s stack. ThreadCopy, &#125;;

struct CopyOptionsTy &#123; <a href="/docs/api/classes/llvm/value">Value</a> &#42;RemoteLaneOffset = nullptr; <a href="/docs/api/classes/llvm/value">Value</a> &#42;ScratchpadIndex = nullptr; <a href="/docs/api/classes/llvm/value">Value</a> &#42;ScratchpadWidth = nullptr; &#125;;

/ Supporting functions for Reductions CodeGen. private: / Get the id of the current thread on the GPU. <a href="/docs/api/classes/llvm/value">Value</a> &#42;getGPUThreadID();

/ Get the GPU warp size. <a href="/docs/api/classes/llvm/value">Value</a> &#42;getGPUWarpSize();

/ Get the id of the warp in the block. / We assume that the warp size is 32, which is always the case / on the <a href="/docs/api/namespaces/llvm/nvptx">NVPTX</a> device, to generate more efficient code. <a href="/docs/api/classes/llvm/value">Value</a> &#42;getNVPTXWarpID();

/ Get the id of the current lane in the Warp. / We assume that the warp size is 32, which is always the case / on the <a href="/docs/api/namespaces/llvm/nvptx">NVPTX</a> device, to generate more efficient code. <a href="/docs/api/classes/llvm/value">Value</a> &#42;getNVPTXLaneID();

/ Cast value to the specified type. <a href="/docs/api/classes/llvm/value">Value</a> &#42;castValueToType(<a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> AllocaIP, <a href="/docs/api/classes/llvm/value">Value</a> &#42;From, <a href="/docs/api/classes/llvm/type">Type</a> &#42;ToType);

/ This function creates calls to one of two shuffle functions to copy / variables between lanes in a warp. <a href="/docs/api/classes/llvm/value">Value</a> &#42;createRuntimeShuffleFunction(<a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> AllocaIP, <a href="/docs/api/classes/llvm/value">Value</a> &#42;Element, <a href="/docs/api/classes/llvm/type">Type</a> &#42;ElementType, <a href="/docs/api/classes/llvm/value">Value</a> &#42;Offset);

/ <a href="/docs/api/classes/llvm/function">Function</a> to shuffle over the value from the remote lane. void shuffleAndStore(InsertPointTy AllocaIP, Value &#42;SrcAddr, Value &#42;DstAddr,
                       Type &#42;ElementType, Value &#42;Offset,
                       Type &#42;ReductionArrayTy);

/ Emit instructions to copy a Reduce list, which contains partially / aggregated values, in the specified direction. void emitReductionListCopy( <a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> AllocaIP, CopyAction Action, <a href="/docs/api/classes/llvm/type">Type</a> &#42;ReductionArrayTy, <a href="/docs/api/classes/llvm/arrayref">ArrayRef&lt;ReductionInfo&gt;</a> ReductionInfos, <a href="/docs/api/classes/llvm/value">Value</a> &#42;SrcBase, <a href="/docs/api/classes/llvm/value">Value</a> &#42;DestBase, CopyOptionsTy CopyOptions = &#123;nullptr, nullptr, nullptr&#125;);

/ Emit a helper that reduces data across two OpenMP threads (lanes) / in the same warp. It uses shuffle instructions to copy over data from / a remote lane&#39;s stack. The reduction algorithm performed is specified / by the fourth parameter. / / Algorithm Versions. / Full Warp Reduce (argument value 0): / This algorithm assumes that all 32 lanes are active and gathers / data from these 32 lanes, producing a single resultant value. / Contiguous Partial Warp Reduce (argument value 1): / This algorithm assumes that only a <em>contiguous</em> subset of lanes / are active. This happens for the last warp in a parallel region / when the user specified num&#95;threads is not an integer multiple of / 32. This contiguous subset always starts with the zeroth lane. / Partial Warp Reduce (argument value 2): / This algorithm gathers data from any number of lanes at any position. / All reduced values are stored in the lowest possible lane. The set / of problems every algorithm addresses is a super set of those / addressable by algorithms with a lower version number. Overhead / increases as algorithm version increases. / / Terminology / Reduce element: / Reduce element refers to the individual data field with primitive / data types to be combined and reduced across threads. / Reduce list: / Reduce list refers to a collection of local, thread-private / reduce elements. / Remote Reduce list: / Remote Reduce list refers to a collection of remote (relative to / the current thread) reduce elements. / / We distinguish between three states of threads that are important to / the implementation of this function. / Alive threads: / Threads in a warp executing the SIMT instruction, as distinguished from / threads that are inactive due to divergent control flow. / Active threads: / The minimal set of threads that has to be alive upon entry to this / function. The computation is correct iff active threads are alive. / Some threads are alive but they are not active because they do not / contribute to the computation in any useful manner. Turning them off / may introduce control flow overheads without any tangible benefits. / Effective threads: / In order to comply with the argument requirements of the shuffle / function, we must keep all lanes holding data alive. But at most / half of them perform value aggregation; we refer to this half of / threads as effective. The other half is simply handing off their / data. / / Procedure / <a href="/docs/api/classes/llvm/value">Value</a> shuffle: / In this step active threads transfer data from higher lane positions / in the warp to lower lane positions, creating Remote Reduce list. / <a href="/docs/api/classes/llvm/value">Value</a> aggregation: / In this step, effective threads combine their thread local Reduce list / with Remote Reduce list and store the result in the thread local / Reduce list. / <a href="/docs/api/classes/llvm/value">Value</a> copy: / In this step, we deal with the assumption made by algorithm 2 / (i.e. contiguity assumption). When we have an odd number of lanes / active, say 2k+1, only k threads will be effective and therefore k / new values will be produced. However, the Reduce list owned by the / (2k+1)th thread is ignored in the value aggregation. Therefore / we copy the Reduce list from the (2k+1)th lane to (k+1)th lane so / that the contiguity assumption still holds. / /
<ParametersList title="Parameters">
<ParametersListItem name="ReductionInfos">Array type containing the ReductionOps. /</ParametersListItem>
<ParametersListItem name="ReduceFn">The reduction function. /</ParametersListItem>
<ParametersListItem name="FuncAttrs">Optional param to specify any function attributes that / need to be copied to the new function. / /</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
The ShuffleAndReduce function. <a href="/docs/api/classes/llvm/function">Function</a> &#42;emitShuffleAndReduceFunction( <a href="/docs/api/classes/llvm/arrayref">ArrayRef&lt;OpenMPIRBuilder::ReductionInfo&gt;</a> ReductionInfos, <a href="/docs/api/classes/llvm/function">Function</a> &#42;ReduceFn, AttributeList FuncAttrs);
</SectionUser>

/ This function emits a helper that gathers Reduce lists from the first / lane of every active warp to lanes in the first warp. / / void inter&#95;warp&#95;copy&#95;func(void&#42; reduce&#95;data, num&#95;warps) / shared smem&#91;warp&#95;size&#93;; / For all data entries D in reduce&#95;data: / sync / If (I am the first lane in each warp) / Copy my local D to smem&#91;warp&#95;id&#93; / sync / if (I am the first warp) / Copy smem&#91;thread&#95;id&#93; to my local D / /
<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The insert and source location description. /</ParametersListItem>
<ParametersListItem name="ReductionInfos">Array type containing the ReductionOps. /</ParametersListItem>
<ParametersListItem name="FuncAttrs">Optional param to specify any function attributes that / need to be copied to the new function. / /</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
The InterWarpCopy function. <a href="/docs/api/classes/llvm/expected">Expected&lt;Function &#42;&gt;</a> emitInterWarpCopyFunction(const LocationDescription &amp;Loc,
                            ArrayRef&lt;ReductionInfo&gt; ReductionInfos,
                            AttributeList FuncAttrs);
</SectionUser>

/ This function emits a helper that copies all the reduction variables from / the team into the provided global buffer for the reduction variables. / / void list&#95;to&#95;global&#95;copy&#95;func(void &#42;buffer, int Idx, void &#42;reduce&#95;data) / For all data entries D in reduce&#95;data: / Copy local D to buffer.D&#91;Idx&#93; / /
<ParametersList title="Parameters">
<ParametersListItem name="ReductionInfos">Array type containing the ReductionOps. /</ParametersListItem>
<ParametersListItem name="ReductionsBufferTy">The StructTy for the reductions buffer. /</ParametersListItem>
<ParametersListItem name="FuncAttrs">Optional param to specify any function attributes that / need to be copied to the new function. / /</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
The ListToGlobalCopy function. <a href="/docs/api/classes/llvm/function">Function</a> &#42;emitListToGlobalCopyFunction(<a href="/docs/api/classes/llvm/arrayref">ArrayRef&lt;ReductionInfo&gt;</a> ReductionInfos, <a href="/docs/api/classes/llvm/type">Type</a> &#42;ReductionsBufferTy, AttributeList FuncAttrs);
</SectionUser>

/ This function emits a helper that copies all the reduction variables from / the team into the provided global buffer for the reduction variables. / / void list&#95;to&#95;global&#95;copy&#95;func(void &#42;buffer, int Idx, void &#42;reduce&#95;data) / For all data entries D in reduce&#95;data: / Copy buffer.D&#91;Idx&#93; to local D; / /
<ParametersList title="Parameters">
<ParametersListItem name="ReductionInfos">Array type containing the ReductionOps. /</ParametersListItem>
<ParametersListItem name="ReductionsBufferTy">The StructTy for the reductions buffer. /</ParametersListItem>
<ParametersListItem name="FuncAttrs">Optional param to specify any function attributes that / need to be copied to the new function. / /</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
The GlobalToList function. <a href="/docs/api/classes/llvm/function">Function</a> &#42;emitGlobalToListCopyFunction(<a href="/docs/api/classes/llvm/arrayref">ArrayRef&lt;ReductionInfo&gt;</a> ReductionInfos, <a href="/docs/api/classes/llvm/type">Type</a> &#42;ReductionsBufferTy, AttributeList FuncAttrs);
</SectionUser>

/ This function emits a helper that reduces all the reduction variables from / the team into the provided global buffer for the reduction variables. / / void list&#95;to&#95;global&#95;reduce&#95;func(void &lt;em&gt;buffer, int Idx, void &#42;reduce&#95;data) / void &#42;GlobPtrs&#91;&#93;; / GlobPtrs&#91;0&#93; = (void)&amp;buffer.D0&#91;Idx&#93;; / ... / GlobPtrs&#91;N&#93; = (void&#42;)&amp;buffer.DN&#91;Idx&#93;; / reduce&#95;function(GlobPtrs, reduce&#95;data); / /
<ParametersList title="Parameters">
<ParametersListItem name="ReductionInfos">Array type containing the ReductionOps. /</ParametersListItem>
<ParametersListItem name="ReduceFn">The reduction function. /</ParametersListItem>
<ParametersListItem name="ReductionsBufferTy">The StructTy for the reductions buffer. /</ParametersListItem>
<ParametersListItem name="FuncAttrs">Optional param to specify any function attributes that / need to be copied to the new function. / /</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
The ListToGlobalReduce function. <a href="/docs/api/classes/llvm/function">Function</a> &#42; emitListToGlobalReduceFunction(ArrayRef&lt;ReductionInfo&gt; ReductionInfos,
                                 Function &#42;ReduceFn, Type &#42;ReductionsBufferTy,
                                 AttributeList FuncAttrs);
</SectionUser>

/ This function emits a helper that reduces all the reduction variables from / the team into the provided global buffer for the reduction variables. / / void global&#95;to&#95;list&#95;reduce&#95;func(void &lt;em&gt;buffer, int Idx, void &#42;reduce&#95;data) / void &#42;GlobPtrs&#91;&#93;; / GlobPtrs&#91;0&#93; = (void)&amp;buffer.D0&#91;Idx&#93;; / ... / GlobPtrs&#91;N&#93; = (void&#42;)&amp;buffer.DN&#91;Idx&#93;; / reduce&#95;function(reduce&#95;data, GlobPtrs); / /
<ParametersList title="Parameters">
<ParametersListItem name="ReductionInfos">Array type containing the ReductionOps. /</ParametersListItem>
<ParametersListItem name="ReduceFn">The reduction function. /</ParametersListItem>
<ParametersListItem name="ReductionsBufferTy">The StructTy for the reductions buffer. /</ParametersListItem>
<ParametersListItem name="FuncAttrs">Optional param to specify any function attributes that / need to be copied to the new function. / /</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
The GlobalToListReduce function. <a href="/docs/api/classes/llvm/function">Function</a> &#42; emitGlobalToListReduceFunction(ArrayRef&lt;ReductionInfo&gt; ReductionInfos,
                                 Function &#42;ReduceFn, Type &#42;ReductionsBufferTy,
                                 AttributeList FuncAttrs);
</SectionUser>

/ Get the function name of a reduction function. std::string getReductionFuncName(StringRef Name) const;

/ Emits reduction function. /
<ParametersList title="Parameters">
<ParametersListItem name="ReducerName">Name of the function calling the reduction. /</ParametersListItem>
<ParametersListItem name="ReductionInfos">Array type containing the ReductionOps. /</ParametersListItem>
<ParametersListItem name="ReductionGenCBKind">Optional param to specify Clang or MLIR / CodeGenCB kind. /</ParametersListItem>
<ParametersListItem name="FuncAttrs">Optional param to specify any function attributes that / need to be copied to the new function. / /</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
The reduction function. <a href="/docs/api/classes/llvm/expected">Expected&lt;Function &#42;&gt;</a> createReductionFunction( <a href="/docs/api/classes/llvm/stringref">StringRef</a> ReducerName, <a href="/docs/api/classes/llvm/arrayref">ArrayRef&lt;ReductionInfo&gt;</a> ReductionInfos, ReductionGenCBKind ReductionGenCBKind = ReductionGenCBKind::MLIR, AttributeList FuncAttrs = &#123;&#125;);
</SectionUser>

public: / / Design of OpenMP reductions on the GPU / / Consider a typical OpenMP program with one or more reduction / clauses: / / float foo; / double bar; / #pragma omp target teams distribute parallel for \\ / reduction(+:foo) <a href="/docs/api/files/lib/lib/transforms/lib/transforms/scalar/straightlinestrengthreduce-cpp/#a7b51b9df5e7db582597e8556087c71ce">reduction(&#42;:bar)</a> / for (int i = 0; i &lt; N; i++) &#123; / foo += A&#91;i&#93;; bar &#42;= B&#91;i&#93;; / &#125; / / where &#39;foo&#39; and &#39;bar&#39; are reduced across all OpenMP threads in / all teams. In our OpenMP implementation on the <a href="/docs/api/namespaces/llvm/nvptx">NVPTX</a> device an / OpenMP team is mapped to a CUDA threadblock and OpenMP threads / within a team are mapped to CUDA threads within a threadblock. / Our goal is to efficiently aggregate values across all OpenMP / threads such that: / / - the compiler and runtime are logically concise, and / - the reduction is performed efficiently in a hierarchical / manner as follows: within OpenMP threads in the same warp, / across warps in a threadblock, and finally across teams on / the <a href="/docs/api/namespaces/llvm/nvptx">NVPTX</a> device. / / Introduction to Decoupling / / We would like to decouple the compiler and the runtime so that the / latter is ignorant of the reduction variables (number, data types) / and the reduction operators. This allows a simpler interface / and implementation while still attaining good performance. / / Pseudocode for the aforementioned OpenMP program generated by the / compiler is as follows: / / 1. Create private copies of reduction variables on each OpenMP / thread: &#39;foo&#95;private&#39;, &#39;bar&#95;private&#39; / 2. Each OpenMP thread reduces the chunk of &#39;A&#39; and &#39;B&#39; assigned / to it and writes the result in &#39;foo&#95;private&#39; and &#39;bar&#95;private&#39; / respectively. / 3. Call the OpenMP runtime on the GPU to reduce within a team / and store the result on the team master: / / &#95;&#95;kmpc&#95;nvptx&#95;parallel&#95;reduce&#95;nowait&#95;v2(..., / reduceData, shuffleReduceFn, interWarpCpyFn) / / where: / struct ReduceData &#123; / double &#42;foo; / double &#42;bar; / &#125; reduceData / reduceData.foo = &amp;foo&#95;private / reduceData.bar = &amp;bar&#95;private / / &#39;shuffleReduceFn&#39; and &#39;interWarpCpyFn&#39; are pointers to two / auxiliary functions generated by the compiler that operate on / variables of type &#39;ReduceData&#39;. They aid the runtime perform / algorithmic steps in a data agnostic manner. / / &#39;shuffleReduceFn&#39; is a pointer to a function that reduces data / of type &#39;ReduceData&#39; across two OpenMP threads (lanes) in the / same warp. It takes the following arguments as input: / / a. variable of type &#39;ReduceData&#39; on the calling lane, / b. its lane&#95;id, / c. an offset relative to the current lane&#95;id to generate a / remote&#95;lane&#95;id. The remote lane contains the second / variable of type &#39;ReduceData&#39; that is to be reduced. / d. an algorithm version parameter determining which reduction / algorithm to use. / / &#39;shuffleReduceFn&#39; retrieves data from the remote lane using / efficient GPU shuffle intrinsics and reduces, using the / algorithm specified by the 4th parameter, the two operands / element-wise. The result is written to the first operand. / / Different reduction algorithms are implemented in different / runtime functions, all calling &#39;shuffleReduceFn&#39; to perform / the essential reduction step. Therefore, based on the 4th / parameter, this function behaves slightly differently to / cooperate with the runtime to ensure correctness under / different circumstances. / / &#39;InterWarpCpyFn&#39; is a pointer to a function that transfers / reduced variables across warps. It tunnels, through CUDA / shared memory, the thread-private data of type &#39;ReduceData&#39; / from lane 0 of each warp to a lane in the first warp. / 4. Call the OpenMP runtime on the GPU to reduce across teams. / The last team writes the global reduced value to memory. / / ret = &#95;&#95;kmpc&#95;nvptx&#95;teams&#95;reduce&#95;nowait(..., / reduceData, shuffleReduceFn, interWarpCpyFn, / scratchpadCopyFn, loadAndReduceFn) / / &#39;scratchpadCopyFn&#39; is a helper that stores reduced / data from the team master to a scratchpad array in / global memory. / / &#39;loadAndReduceFn&#39; is a helper that loads data from / the scratchpad array and reduces it with the input / operand. / / These compiler generated functions hide address / calculation and alignment information from the runtime. / 5. if ret == 1: / The team master of the last team stores the reduced / result to the globals in memory. / foo += reduceData.foo; bar &#42;= reduceData.bar / / / Warp Reduction Algorithms / / On the warp level, we have three algorithms implemented in the / OpenMP runtime depending on the number of active lanes: / / Full Warp Reduction / / The reduce algorithm within a warp where all lanes are active / is implemented in the runtime as follows: / / full&#95;warp&#95;reduce(void &#42;reduce&#95;data, / kmp&#95;ShuffleReductFctPtr ShuffleReduceFn) &#123; / for (int offset = WARPSIZE/2; offset &gt; 0; offset /= 2) / ShuffleReduceFn(reduce&#95;data, 0, offset, 0); / &#125; / / The algorithm completes in log(2, WARPSIZE) steps. / / &#39;ShuffleReduceFn&#39; is used here with lane&#95;id set to 0 because it is / not used therefore we save instructions by not retrieving lane&#95;id / from the corresponding special registers. The 4th parameter, which / represents the version of the algorithm being used, is set to 0 to / signify full warp reduction. / / In this version, &#39;ShuffleReduceFn&#39; behaves, per element, as follows: / / #reduce&#95;elem refers to an element in the local lane&#39;s data structure / #remote&#95;elem is retrieved from a remote lane / remote&#95;elem = shuffle&#95;down(reduce&#95;elem, offset, WARPSIZE); / reduce&#95;elem = reduce&#95;elem REDUCE&#95;OP remote&#95;elem; / / Contiguous Partial Warp Reduction / / This reduce algorithm is used within a warp where only the first / &#39;n&#39; (n &lt;= WARPSIZE) lanes are active. It is typically used when the / number of OpenMP threads in a parallel region is not a multiple of / WARPSIZE. The algorithm is implemented in the runtime as follows: / / void / contiguous&#95;partial&#95;reduce(void &#42;reduce&#95;data, / kmp&#95;ShuffleReductFctPtr ShuffleReduceFn, / int size, int lane&#95;id) &#123; / int curr&#95;size; / int offset; / curr&#95;size = size; / mask = curr&#95;size/2; / while (offset&gt;0) &#123; / ShuffleReduceFn(reduce&#95;data, lane&#95;id, offset, 1); / curr&#95;size = (curr&#95;size+1)/2; / offset = curr&#95;size/2; / &#125; / &#125; / / In this version, &#39;ShuffleReduceFn&#39; behaves, per element, as follows: / / remote&#95;elem = shuffle&#95;down(reduce&#95;elem, offset, WARPSIZE); / if (lane&#95;id &lt; offset) / reduce&#95;elem = reduce&#95;elem REDUCE&#95;OP remote&#95;elem / else / reduce&#95;elem = remote&#95;elem / / This algorithm assumes that the data to be reduced are located in a / contiguous subset of lanes starting from the first. When there is / an odd number of active lanes, the data in the last lane is not / aggregated with any other lane&#39;s dat but is instead copied over. / / Dispersed Partial Warp Reduction / / This algorithm is used within a warp when any discontiguous subset of / lanes are active. It is used to implement the reduction operation / across lanes in an OpenMP simd region or in a nested parallel region. / / void / dispersed&#95;partial&#95;reduce(void &#42;reduce&#95;data, / kmp&#95;ShuffleReductFctPtr ShuffleReduceFn) &#123; / int size, remote&#95;id; / int logical&#95;lane&#95;id = number&#95;of&#95;active&#95;lanes&#95;before&#95;me() &#42; 2; / do &#123; / remote&#95;id = next&#95;active&#95;lane&#95;id&#95;right&#95;after&#95;me(); / # the above function returns 0 of no active lane / # is present right after the current lane. / size = number&#95;of&#95;active&#95;lanes&#95;in&#95;this&#95;warp(); / logical&#95;lane&#95;id /= 2; / ShuffleReduceFn(reduce&#95;data, logical&#95;lane&#95;id, / remote&#95;id-1-threadIdx.x, 2); / &#125; while (logical&#95;lane&#95;id % 2 == 0 &amp;&amp; size &gt; 1); / &#125; / / There is no assumption made about the initial state of the reduction. / <a href="/docs/api/classes/llvm/any">Any</a> number of lanes (&gt;=1) could be active at any position. The reduction / result is returned in the first active lane. / / In this version, &#39;ShuffleReduceFn&#39; behaves, per element, as follows: / / remote&#95;elem = shuffle&#95;down(reduce&#95;elem, offset, WARPSIZE); / if (lane&#95;id % 2 == 0 &amp;&amp; offset &gt; 0) / reduce&#95;elem = reduce&#95;elem REDUCE&#95;OP remote&#95;elem / else / reduce&#95;elem = remote&#95;elem / / / Intra-Team Reduction / / This function, as implemented in the runtime call / &#39;&#95;&#95;kmpc&#95;nvptx&#95;parallel&#95;reduce&#95;nowait&#95;v2&#39;, aggregates data across OpenMP / threads in a team. It first reduces within a warp using the / aforementioned algorithms. We then proceed to gather all such / reduced values at the first warp. / / The runtime makes use of the function &#39;InterWarpCpyFn&#39;, which copies / data from each of the &quot;warp master&quot; (zeroth lane of each warp, where / warp-reduced data is held) to the zeroth warp. This step reduces (in / a mathematical sense) the problem of reduction across warp masters in / a block to the problem of warp reduction. / / / Inter-Team Reduction / / Once a team has reduced its data to a single value, it is stored in / a global scratchpad array. Since each team has a distinct slot, this / can be done without locking. / / The last team to write to the scratchpad array proceeds to reduce the / scratchpad array. One or more workers in the last team use the helper / &#39;loadAndReduceDataFn&#39; to load and reduce values from the array, i.e., / the k&#39;th worker reduces every k&#39;th element. / / Finally, a call is made to &#39;&#95;&#95;kmpc&#95;nvptx&#95;parallel&#95;reduce&#95;nowait&#95;v2&#39; to / reduce across workers and compute a globally reduced value. / /
<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The location where the reduction was / encountered. Must be within the associate / directive and after the last local access to the / reduction variables. /</ParametersListItem>
<ParametersListItem name="AllocaIP">An insertion point suitable for allocas usable / in reductions. /</ParametersListItem>
<ParametersListItem name="CodeGenIP">An insertion point suitable for code / generation.</ParametersListItem>
<ParametersListItem name="ReductionInfos">A list of info on each reduction / variable.</ParametersListItem>
<ParametersListItem name="IsNoWait">Optional flag set if the reduction is / marked as / nowait. /</ParametersListItem>
<ParametersListItem name="IsTeamsReduction">Optional flag set if it is a teams / reduction. /</ParametersListItem>
<ParametersListItem name="HasDistribute">Optional flag set if it is a / distribute reduction. /</ParametersListItem>
<ParametersListItem name="GridValue">Optional GPU grid value. /</ParametersListItem>
<ParametersListItem name="ReductionBufNum">Optional OpenMPCUDAReductionBufNumValue to be / used for teams reduction. /</ParametersListItem>
<ParametersListItem name="SrcLocInfo">Source location information global. <a href="#af24d1c61cec57095ced3b08a6dd99ee8">InsertPointOrErrorTy</a> createReductionsGPU( const <a href="/docs/api/structs/llvm/openmpirbuilder/locationdescription">LocationDescription</a> &amp;<a href="/docs/api/namespaces/llvm/loc">Loc</a>, <a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> AllocaIP, <a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> CodeGenIP, <a href="/docs/api/classes/llvm/arrayref">ArrayRef&lt;ReductionInfo&gt;</a> ReductionInfos, bool IsNoWait = false, bool IsTeamsReduction = false, bool HasDistribute = false, ReductionGenCBKind ReductionGenCBKind = ReductionGenCBKind::MLIR, std::optional&lt;omp::GV&gt; GridValue = &#123;&#125;, unsigned ReductionBufNum = 1024, <a href="/docs/api/classes/llvm/value">Value</a> &#42;SrcLocInfo = nullptr);</ParametersListItem>
</ParametersList>
TODO: provide atomic and non-atomic reduction generators for reduction operators defined by the OpenMP specification.

/ Generator for &#39;<a href="/docs/api/namespaces/llvm/omp">omp</a> reduction&#39;. / / Emits the IR instructing the runtime to perform the specific kind of / reductions. Expects reduction variables to have been privatized and / initialized to reduction-neutral values separately. Emits the calls to / runtime functions as well as the reduction function and the basic blocks / performing the reduction atomically and non-atomically. / / The code emitted for the following: / / 
<ProgramListing>

<CodeLine><span class="doxyHighlightComment">///   type var&#95;1;</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///   type var&#95;2;</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///   #pragma omp &lt;directive&gt; reduction(reduction-op:var&#95;1,var&#95;2)</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///   /&#42; body &#42;/;</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">/// </span></CodeLine>

</ProgramListing>
 / / corresponds to the following sketch. / / 
<ProgramListing>

<CodeLine><span class="doxyHighlightComment">/// void &#95;outlined&#95;par() &#123;</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///   // N is the number of different reductions.</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///   void &#42;red&#95;array&#91;&#93; = &#123;privatized&#95;var&#95;1, privatized&#95;var&#95;2, ...&#125;;</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///   switch(&#95;&#95;kmpc&#95;reduce(..., N, /&#42;size of data in red array&#42;/, red&#95;array,</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///                        &#95;omp&#95;reduction&#95;func,</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///                        &#95;gomp&#95;critical&#95;user.reduction.var)) &#123;</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///   case 1: &#123;</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///     var&#95;1 = var&#95;1 &lt;reduction-op&gt; privatized&#95;var&#95;1;</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///     var&#95;2 = var&#95;2 &lt;reduction-op&gt; privatized&#95;var&#95;2;</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///     // ...</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///    &#95;&#95;kmpc&#95;end&#95;reduce(...);</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///     break;</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///   &#125;</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///   case 2: &#123;</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///     &#95;Atomic&lt;ReductionOp&gt;(var&#95;1, privatized&#95;var&#95;1);</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///     &#95;Atomic&lt;ReductionOp&gt;(var&#95;2, privatized&#95;var&#95;2);</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///     // ...</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///     break;</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///   &#125;</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///   default: break;</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///   &#125;</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">/// &#125;</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">/// void &#95;omp&#95;reduction&#95;func(void &#42;&#42;lhs, void &#42;&#42;rhs) &#123;</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///   &#42;(type &#42;)lhs&#91;0&#93; = &#42;(type &#42;)lhs&#91;0&#93; &lt;reduction-op&gt; &#42;(type &#42;)rhs&#91;0&#93;;</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///   &#42;(type &#42;)lhs&#91;1&#93; = &#42;(type &#42;)lhs&#91;1&#93; &lt;reduction-op&gt; &#42;(type &#42;)rhs&#91;1&#93;;</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///   // ...</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">/// &#125;</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">/// </span></CodeLine>

</ProgramListing>
 / /
<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The location where the reduction was / encountered. Must be within the associate / directive and after the last local access to the / reduction variables. /</ParametersListItem>
<ParametersListItem name="AllocaIP">An insertion point suitable for allocas usable / in reductions. /</ParametersListItem>
<ParametersListItem name="ReductionInfos">A list of info on each reduction variable. /</ParametersListItem>
<ParametersListItem name="IsNoWait">A flag set if the reduction is marked as nowait. /</ParametersListItem>
<ParametersListItem name="IsByRef">A flag set if the reduction is using reference / or direct value. <a href="#af24d1c61cec57095ced3b08a6dd99ee8">InsertPointOrErrorTy</a> createReductions(const <a href="/docs/api/structs/llvm/openmpirbuilder/locationdescription">LocationDescription</a> &amp;<a href="/docs/api/namespaces/llvm/loc">Loc</a>, <a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> AllocaIP, <a href="/docs/api/classes/llvm/arrayref">ArrayRef&lt;ReductionInfo&gt;</a> ReductionInfos, <a href="/docs/api/classes/llvm/arrayref">ArrayRef&lt;bool&gt;</a> IsByRef, bool IsNoWait = false);</ParametersListItem>
</ParametersList>
/&#125;

/ Return the insertion point used by the underlying <a href="/docs/api/classes/llvm/irbuilder">IRBuilder</a>. <a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> getInsertionPoint() &#123; return Builder.saveIP(); &#125;

/ Update the internal location to <code><a href="/docs/api/namespaces/llvm/loc">Loc</a></code>. bool updateToLocation(const LocationDescription &amp;Loc) &#123; Builder.restoreIP(Loc.IP); Builder.SetCurrentDebugLocation(Loc.DL); return Loc.IP.getBlock() != nullptr; &#125;

/ Return the function declaration for the runtime function with <code>FnID</code>. <a href="/docs/api/classes/llvm/functioncallee">FunctionCallee</a> getOrCreateRuntimeFunction(Module &amp;M,
                                            omp::RuntimeFunction FnID);

<a href="/docs/api/classes/llvm/function">Function</a> &#42;getOrCreateRuntimeFunctionPtr(<a href="/docs/api/namespaces/llvm/omp/#a4c503140c7f851151906d85b515330e9">omp::RuntimeFunction</a> FnID);

/ Return the (LLVM-IR) string describing the source location <code>LocStr</code>. <a href="/docs/api/classes/llvm/constant">Constant</a> &#42;getOrCreateSrcLocStr(<a href="/docs/api/classes/llvm/stringref">StringRef</a> LocStr, uint32&#95;t &amp;SrcLocStrSize);

/ Return the (LLVM-IR) string describing the default source location. <a href="/docs/api/classes/llvm/constant">Constant</a> &#42;getOrCreateDefaultSrcLocStr(uint32&#95;t &amp;SrcLocStrSize);

/ Return the (LLVM-IR) string describing the source location identified by / the arguments. <a href="/docs/api/classes/llvm/constant">Constant</a> &#42;getOrCreateSrcLocStr(<a href="/docs/api/classes/llvm/stringref">StringRef</a> FunctionName, <a href="/docs/api/classes/llvm/stringref">StringRef</a> FileName, unsigned Line, unsigned Column, uint32&#95;t &amp;SrcLocStrSize);

/ Return the (LLVM-IR) string describing the <a href="/docs/api/classes/llvm/debugloc">DebugLoc</a> <code>DL</code>. <a href="/docs/api/classes/llvm/use">Use</a> <code>F</code> as / fallback if <code>DL</code> does not specify the function name. <a href="/docs/api/classes/llvm/constant">Constant</a> &#42;getOrCreateSrcLocStr(<a href="/docs/api/classes/llvm/debugloc">DebugLoc</a> DL, uint32&#95;t &amp;SrcLocStrSize, <a href="/docs/api/classes/llvm/function">Function</a> &#42;F = nullptr);

/ Return the (LLVM-IR) string describing the source location <code><a href="/docs/api/namespaces/llvm/loc">Loc</a></code>. <a href="/docs/api/classes/llvm/constant">Constant</a> &#42;getOrCreateSrcLocStr(const <a href="/docs/api/structs/llvm/openmpirbuilder/locationdescription">LocationDescription</a> &amp;<a href="/docs/api/namespaces/llvm/loc">Loc</a>, uint32&#95;t &amp;SrcLocStrSize);

/ Return an ident&#95;t&#42; encoding the source location <code>SrcLocStr</code> and <code>Flags</code>. / TODO: Create a enum class for the Reserve2Flags <a href="/docs/api/classes/llvm/constant">Constant</a> &#42;getOrCreateIdent(<a href="/docs/api/classes/llvm/constant">Constant</a> &#42;SrcLocStr, uint32&#95;t SrcLocStrSize, <a href="/docs/api/namespaces/llvm/omp/#a0e821d8251c97d66ca185efe2f8ffde2">omp::IdentFlag</a> Flags = <a href="/docs/api/namespaces/llvm/omp/#a0e821d8251c97d66ca185efe2f8ffde2">omp::IdentFlag(0)</a>, unsigned Reserve2Flags = 0);

/ Create a hidden global flag <code>Name</code> in the module with initial value <code>/</code> <a href="/docs/api/classes/llvm/value">Value</a>. <a href="/docs/api/classes/llvm/globalvalue">GlobalValue</a> &#42;createGlobalFlag(unsigned <a href="/docs/api/classes/llvm/value">Value</a>, <a href="/docs/api/classes/llvm/stringref">StringRef</a> Name);

/ Emit the llvm.used metadata. void emitUsed(StringRef Name, ArrayRef&lt;llvm::WeakTrackingVH&gt; List);

/ Emit the kernel execution mode. <a href="/docs/api/classes/llvm/globalvariable">GlobalVariable</a> &#42;emitKernelExecutionMode(<a href="/docs/api/classes/llvm/stringref">StringRef</a> KernelName, <a href="/docs/api/namespaces/llvm/omp/#aa0c0d79dafb0d22308ce48808689f430">omp::OMPTgtExecModeFlags</a> Mode);

/ Generate control flow and cleanup for cancellation. / /
<ParametersList title="Parameters">
<ParametersListItem name="CancelFlag">Flag indicating if the cancellation is performed. /</ParametersListItem>
<ParametersListItem name="CanceledDirective">The kind of directive that is cancled. /</ParametersListItem>
<ParametersListItem name="ExitCB">Extra code to be generated in the exit block. / /</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
an error, if any were triggered during execution. <a href="/docs/api/classes/llvm/error">Error</a> emitCancelationCheckImpl(<a href="/docs/api/classes/llvm/value">Value</a> &#42;CancelFlag, omp::Directive CanceledDirective, <a href="#a0c571620ff53fdb78e7404f5261dbd23">FinalizeCallbackTy</a> ExitCB = &#123;&#125;);
</SectionUser>

/ Generate a target region entry call. / /
<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The location at which the request originated and is fulfilled. /</ParametersListItem>
<ParametersListItem name="AllocaIP">The insertion point to be used for alloca instructions. /</ParametersListItem>
<ParametersListItem name="Return">Return value of the created function returned by reference. /</ParametersListItem>
<ParametersListItem name="DeviceID">Identifier for the device via the &#39;device&#39; clause. /</ParametersListItem>
<ParametersListItem name="NumTeams">Numer of teams for the region via the &#39;num&#95;teams&#39; clause / or 0 if unspecified and -1 if there is no &#39;teams&#39; clause. /</ParametersListItem>
<ParametersListItem name="NumThreads">Number of threads via the &#39;thread&#95;limit&#39; clause. /</ParametersListItem>
<ParametersListItem name="HostPtr">Pointer to the host-side pointer of the target kernel. /</ParametersListItem>
<ParametersListItem name="KernelArgs">
Array of arguments to the kernel. <a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> emitTargetKernel(const LocationDescription &amp;Loc,
                                 InsertPointTy AllocaIP, Value &#42;&amp;Return,
                                 Value &#42;Ident, Value &#42;DeviceID, Value &#42;NumTeams,
                                 Value &#42;NumThreads, Value &#42;HostPtr,
                                 ArrayRef&lt;Value &#42;&gt; KernelArgs);
</ParametersListItem>
</ParametersList>
/ Generate a flush runtime call. / /
<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The location at which the request originated and is fulfilled. void emitFlush(const LocationDescription &amp;Loc);</ParametersListItem>
</ParametersList>
/ The finalization stack made up of finalize callbacks currently in-flight, / wrapped into <a href="/docs/api/structs/llvm/openmpirbuilder/finalizationinfo">FinalizationInfo</a> objects that reference also the finalization / target block and the kind of cancellable directive. <a href="/docs/api/classes/llvm/smallvector">SmallVector&lt;FinalizationInfo, 8&gt;</a> FinalizationStack;

/ Return true if the last entry in the finalization stack is of kind <code>DK</code> / and cancellable. bool isLastFinalizationInfoCancellable(omp::Directive DK) &#123; return !FinalizationStack.empty() &amp;&amp; FinalizationStack.back().IsCancellable &amp;&amp; FinalizationStack.back().DK == DK; &#125;

/ Generate a taskwait runtime call. / /
<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The location at which the request originated and is fulfilled. void emitTaskwaitImpl(const LocationDescription &amp;Loc);</ParametersListItem>
</ParametersList>
/ Generate a taskyield runtime call. / /
<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The location at which the request originated and is fulfilled. void emitTaskyieldImpl(const LocationDescription &amp;Loc);</ParametersListItem>
</ParametersList>
/ Return the current thread <a href="/docs/api/namespaces/llvm/callingconv/#abdf8cf606905c10634e831390981b0ed">ID</a>. / /
<ParametersList title="Parameters">
<ParametersListItem name="Ident">The ident (ident&#95;t&#42;) describing the query origin. <a href="/docs/api/classes/llvm/value">Value</a> &#42;getOrCreateThreadID(<a href="/docs/api/classes/llvm/value">Value</a> &#42;Ident);</ParametersListItem>
</ParametersList>
/ The <a href="/docs/api/classes/llvm/openmpirbuilder">OpenMPIRBuilder</a> Configuration <a href="/docs/api/classes/llvm/openmpirbuilderconfig">OpenMPIRBuilderConfig</a> Config;

/ The underlying LLVM-IR module <a href="/docs/api/classes/llvm/module">Module</a> &amp;M;

/ The LLVM-IR Builder used to create IR. <a href="/docs/api/classes/llvm/irbuilder">IRBuilder&lt;&gt;</a> Builder;

/ Map to remember source location strings <a href="/docs/api/classes/llvm/stringmap">StringMap&lt;Constant &#42;&gt;</a> SrcLocStrMap;

/ Map to remember existing ident&#95;t&#42;. <a href="/docs/api/classes/llvm/densemap">DenseMap</a>&lt;std::pair&lt;Constant &#42;, uint64&#95;t&gt;, <a href="/docs/api/classes/llvm/constant">Constant</a> &#42;&gt; IdentMap;

/ Info manager to keep track of target regions. <a href="/docs/api/classes/llvm/offloadentriesinfomanager">OffloadEntriesInfoManager</a> OffloadInfoManager;

/ The target triple of the underlying module. const <a href="/docs/api/classes/llvm/triple">Triple</a> T;

/ Helper that contains information about regions we need to outline / during finalization. struct OutlineInfo &#123; using PostOutlineCBTy = std::function&lt;void(Function &amp;)&gt;; PostOutlineCBTy PostOutlineCB; <a href="/docs/api/classes/llvm/basicblock">BasicBlock</a> &#42;EntryBB, &#42;ExitBB, &#42;OuterAllocaBB; <a href="/docs/api/classes/llvm/smallvector">SmallVector&lt;Value &#42;, 2&gt;</a> ExcludeArgsFromAggregate;

/ Collect all blocks in between EntryBB and ExitBB in both the given / vector and set. void collectBlocks(SmallPtrSetImpl&lt;BasicBlock &#42;&gt; &amp;BlockSet,
                       SmallVectorImpl&lt;BasicBlock &#42;&gt; &amp;BlockVector);

/ Return the function that contains the region to be outlined. <a href="/docs/api/classes/llvm/function">Function</a> &#42;getFunction() const &#123; return EntryBB-&gt;<a href="/docs/api/files/lib/lib/analysis/basicaliasanalysis-cpp/#a1b8850f1ed44c12bc3501175a71c251c">getParent()</a>; &#125; &#125;;

/ Collection of regions that need to be outlined during finalization. <a href="/docs/api/classes/llvm/smallvector">SmallVector&lt;OutlineInfo, 16&gt;</a> OutlineInfos;

/ A collection of candidate target functions that&#39;s constant allocas will / attempt to be raised on a call of finalize after all currently enqueued / outline info&#39;s have been processed. <a href="/docs/api/classes/llvm/smallvector">SmallVector&lt;llvm::Function &#42;, 16&gt;</a> ConstantAllocaRaiseCandidates;

/ Collection of owned canonical loop objects that eventually need to be / free&#39;d. std::forward&#95;list&lt;CanonicalLoopInfo&gt; LoopInfos;

/ Add a new region that will be outlined later. void addOutlineInfo(OutlineInfo &amp;&amp;OI) &#123; OutlineInfos.emplace&#95;back(OI); &#125;

/ An ordered map of auto-generated variables to their unique names. / It stores variables with the following names: 1) &quot;.gomp&#95;critical&#95;user&#95;&quot; + / &lt;critical&#95;section&#95;name&gt; + &quot;.var&quot; for &quot;omp critical&quot; directives; 2) / &lt;mangled&#95;name&#95;for&#95;global&#95;var&gt; + &quot;.cache.&quot; for cache for threadprivate / variables. <a href="/docs/api/classes/llvm/stringmap">StringMap&lt;GlobalVariable &#42;, BumpPtrAllocator&gt;</a> InternalVars;

/ Computes the size of type in bytes. <a href="/docs/api/classes/llvm/value">Value</a> &#42;getSizeInBytes(<a href="/docs/api/classes/llvm/value">Value</a> &#42;BasePtr);

Emit a branch from the current block to the <a href="/docs/api/classes/llvm/target">Target</a> block only if the current block has a terminator. void emitBranch(BasicBlock &#42;Target);

If BB has no use then delete it and return. Else place BB after the current block, if possible, or else at the end of the function. Also add a branch from current block to BB if current block does not have a terminator. void emitBlock(<a href="/docs/api/classes/llvm/basicblock">BasicBlock</a> &#42;BB, <a href="/docs/api/classes/llvm/function">Function</a> &#42;CurFn, bool IsFinished = false);

/ Emits code for OpenMP &#39;if&#39; clause using specified <em><a href="#a49e35e3ee470add16efcde1ab5d5556b">BodyGenCallbackTy</a></em> / Here is the logic: / if (Cond) &#123; / ThenGen(); / &#125; else &#123; / ElseGen(); / &#125; / / 
<SectionUser title="Returns">
an error, if any were triggered during execution. <a href="/docs/api/classes/llvm/error">Error</a> emitIfClause(<a href="/docs/api/classes/llvm/value">Value</a> &#42;Cond, <a href="#a49e35e3ee470add16efcde1ab5d5556b">BodyGenCallbackTy</a> ThenGen, <a href="#a49e35e3ee470add16efcde1ab5d5556b">BodyGenCallbackTy</a> ElseGen, <a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> AllocaIP = &#123;&#125;);
</SectionUser>

/ Create the global variable holding the offload mappings information. <a href="/docs/api/classes/llvm/globalvariable">GlobalVariable</a> &#42;createOffloadMaptypes(<a href="/docs/api/classes/llvm/smallvectorimpl">SmallVectorImpl&lt;uint64&#95;t&gt;</a> &amp;Mappings, std::string VarName);

/ Create the global variable holding the offload names information. <a href="/docs/api/classes/llvm/globalvariable">GlobalVariable</a> &#42; createOffloadMapnames(SmallVectorImpl&lt;llvm::Constant &#42;&gt; &amp;Names,
                        std::string VarName);

struct MapperAllocas &#123; <a href="/docs/api/classes/llvm/allocainst">AllocaInst</a> &#42;ArgsBase = nullptr; <a href="/docs/api/classes/llvm/allocainst">AllocaInst</a> &#42;Args = nullptr; <a href="/docs/api/classes/llvm/allocainst">AllocaInst</a> &#42;ArgSizes = nullptr; &#125;;

/ Create the allocas instruction used in call to mapper functions. void createMapperAllocas(const LocationDescription &amp;Loc,
                           InsertPointTy AllocaIP, unsigned NumOperands,
                           struct MapperAllocas &amp;MapperAllocas);

/ Create the call for the target mapper function. /
<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The source location description. /</ParametersListItem>
<ParametersListItem name="MapperFunc"><a href="/docs/api/classes/llvm/function">Function</a> to be called. /</ParametersListItem>
<ParametersListItem name="SrcLocInfo">Source location information global. /</ParametersListItem>
<ParametersListItem name="MaptypesArg">The argument types. /</ParametersListItem>
<ParametersListItem name="MapnamesArg">The argument names. /</ParametersListItem>
<ParametersListItem name="MapperAllocas">The <a href="/docs/api/classes/llvm/allocainst">AllocaInst</a> used for the call. /</ParametersListItem>
<ParametersListItem name="DeviceID">Device <a href="/docs/api/namespaces/llvm/callingconv/#abdf8cf606905c10634e831390981b0ed">ID</a> for the call. /</ParametersListItem>
<ParametersListItem name="NumOperands">
Number of operands in the call. void emitMapperCall(const LocationDescription &amp;Loc, Function &#42;MapperFunc,
                      Value &#42;SrcLocInfo, Value &#42;MaptypesArg, Value &#42;MapnamesArg,
                      struct MapperAllocas &amp;MapperAllocas, int64&#95;t DeviceID,
                      unsigned NumOperands);
</ParametersListItem>
</ParametersList>
/ Container for the arguments used to pass data to the runtime library. struct TargetDataRTArgs &#123; / The array of base pointer passed to the runtime library. <a href="/docs/api/classes/llvm/value">Value</a> &#42;BasePointersArray = nullptr; / The array of section pointers passed to the runtime library. <a href="/docs/api/classes/llvm/value">Value</a> &#42;PointersArray = nullptr; / The array of sizes passed to the runtime library. <a href="/docs/api/classes/llvm/value">Value</a> &#42;SizesArray = nullptr; / The array of map types passed to the runtime library for the beginning / of the region or for the entire region if there are no separate map / types for the region end. <a href="/docs/api/classes/llvm/value">Value</a> &#42;MapTypesArray = nullptr; / The array of map types passed to the runtime library for the end of the / region, or nullptr if there are no separate map types for the region / end. <a href="/docs/api/classes/llvm/value">Value</a> &#42;MapTypesArrayEnd = nullptr; / The array of user-defined mappers passed to the runtime library. <a href="/docs/api/classes/llvm/value">Value</a> &#42;MappersArray = nullptr; / The array of original declaration names of mapped pointers sent to the / runtime library for debugging <a href="/docs/api/classes/llvm/value">Value</a> &#42;MapNamesArray = nullptr;

explicit TargetDataRTArgs() &#123;&#125; explicit TargetDataRTArgs(Value &#42;BasePointersArray, Value &#42;PointersArray,
                              Value &#42;SizesArray, Value &#42;MapTypesArray,
                              Value &#42;MapTypesArrayEnd, Value &#42;MappersArray,
                              Value &#42;MapNamesArray) : BasePointersArray(BasePointersArray), PointersArray(PointersArray), SizesArray(SizesArray), MapTypesArray(MapTypesArray), MapTypesArrayEnd(MapTypesArrayEnd), MappersArray(MappersArray), MapNamesArray(MapNamesArray) &#123;&#125; &#125;;

/ Container to pass the default attributes with which a kernel must be / launched, used to set kernel attributes and populate associated static / structures. / / For max values, &lt; 0 means unset, == 0 means set but unknown at compile / time. The number of max values will be 1 except for the case where / ompx&#95;bare is set. struct TargetKernelDefaultAttrs &#123; <a href="/docs/api/namespaces/llvm/omp/#aa0c0d79dafb0d22308ce48808689f430">omp::OMPTgtExecModeFlags</a> ExecFlags = <a href="/docs/api/namespaces/llvm/omp/#aa0c0d79dafb0d22308ce48808689f430afa583a38ff705195c9bce9dec0c5eff8">omp::OMPTgtExecModeFlags::OMP&#95;TGT&#95;EXEC&#95;MODE&#95;GENERIC</a>; <a href="/docs/api/classes/llvm/smallvector">SmallVector&lt;int32&#95;t, 3&gt;</a> MaxTeams = &#123;-1&#125;; int32&#95;t MinTeams = 1; <a href="/docs/api/classes/llvm/smallvector">SmallVector&lt;int32&#95;t, 3&gt;</a> MaxThreads = &#123;-1&#125;; int32&#95;t MinThreads = 1; &#125;;

/ Container to pass LLVM IR runtime values or constants related to the / number of teams and threads with which the kernel must be launched, as / well as the trip count of the loop, if it is an SPMD or Generic-SPMD / kernel. These must be defined in the host prior to the call to the kernel / launch OpenMP RTL function. struct TargetKernelRuntimeAttrs &#123; <a href="/docs/api/classes/llvm/smallvector">SmallVector&lt;Value &#42;, 3&gt;</a> MaxTeams = &#123;nullptr&#125;; <a href="/docs/api/classes/llvm/value">Value</a> &#42;MinTeams = nullptr; <a href="/docs/api/classes/llvm/smallvector">SmallVector&lt;Value &#42;, 3&gt;</a> TargetThreadLimit = &#123;nullptr&#125;; <a href="/docs/api/classes/llvm/smallvector">SmallVector&lt;Value &#42;, 3&gt;</a> TeamsThreadLimit = &#123;nullptr&#125;;

/ &#39;parallel&#39; construct &#39;num&#95;threads&#39; clause value, if present and it is an / SPMD kernel. <a href="/docs/api/classes/llvm/value">Value</a> &#42;MaxThreads = nullptr;

/ Total number of iterations of the SPMD or Generic-SPMD kernel or null if / it is a generic kernel. <a href="/docs/api/classes/llvm/value">Value</a> &#42;LoopTripCount = nullptr; &#125;;

/ Data structure that contains the needed information to construct the / kernel args vector. struct TargetKernelArgs &#123; / Number of arguments passed to the runtime library. unsigned NumTargetItems = 0; / Arguments passed to the runtime library TargetDataRTArgs RTArgs; / The number of iterations <a href="/docs/api/classes/llvm/value">Value</a> &#42;NumIterations = nullptr; / The number of teams. <a href="/docs/api/classes/llvm/arrayref">ArrayRef&lt;Value &#42;&gt;</a> NumTeams; / The number of threads. <a href="/docs/api/classes/llvm/arrayref">ArrayRef&lt;Value &#42;&gt;</a> NumThreads; / The size of the dynamic shared memory. <a href="/docs/api/classes/llvm/value">Value</a> &#42;DynCGGroupMem = nullptr; / True if the kernel has &#39;no wait&#39; clause. bool HasNoWait = false;

Constructors for TargetKernelArgs. TargetKernelArgs() &#123;&#125; TargetKernelArgs(unsigned NumTargetItems, TargetDataRTArgs RTArgs,
                     Value &#42;NumIterations, ArrayRef&lt;Value &#42;&gt; NumTeams,
                     ArrayRef&lt;Value &#42;&gt; NumThreads, Value &#42;DynCGGroupMem,
                     bool HasNoWait) : NumTargetItems(NumTargetItems), RTArgs(RTArgs), NumIterations(NumIterations), NumTeams(NumTeams), NumThreads(NumThreads), DynCGGroupMem(DynCGGroupMem), HasNoWait(HasNoWait) &#123;&#125; &#125;;

/ Create the kernel args vector used by emitTargetKernel. This function / creates various constant values that are used in the resulting args / vector. static void getKernelArgsVector(TargetKernelArgs &amp;KernelArgs,
                                  IRBuilderBase &amp;Builder,
                                  SmallVector&lt;Value &#42;&gt; &amp;ArgsVector);

/ Struct that keeps the information that should be kept throughout / a &#39;target data&#39; region. class TargetDataInfo &#123; / Set to true if device pointer information have to be obtained. bool RequiresDevicePointerInfo = false; / Set to true if Clang emits separate runtime calls for the beginning and / end of the region. These calls might have separate map type arrays. bool SeparateBeginEndCalls = false;

public: TargetDataRTArgs RTArgs;

<a href="/docs/api/structs/llvm/smallmapvector">SmallMapVector</a>&lt;const <a href="/docs/api/classes/llvm/value">Value</a> &#42;, std::pair&lt;Value &#42;, Value &#42;&gt;, 4&gt; DevicePtrInfoMap;

/ Indicate whether any user-defined mapper exists. bool HasMapper = false; / The total number of pointers passed to the runtime library. unsigned NumberOfPtrs = 0u;

bool EmitDebug = false;

/ Whether the <code>target ... data</code> directive has a <code>nowait</code> clause. bool HasNoWait = false;

explicit TargetDataInfo() &#123;&#125; explicit TargetDataInfo(bool RequiresDevicePointerInfo,
                            bool SeparateBeginEndCalls) : RequiresDevicePointerInfo(RequiresDevicePointerInfo), SeparateBeginEndCalls(SeparateBeginEndCalls) &#123;&#125; / Clear information about the data arrays. void clearArrayInfo() &#123; RTArgs = TargetDataRTArgs(); HasMapper = false; NumberOfPtrs = 0u; &#125; / Return true if the current target data information has valid arrays. bool <a href="/docs/api/files/lib/lib/demangle/rustdemangle-cpp/#a103d8cfe62c1651cd70e181746f8a840">isValid()</a> &#123; return RTArgs.BasePointersArray &amp;&amp; RTArgs.PointersArray &amp;&amp; RTArgs.SizesArray &amp;&amp; RTArgs.MapTypesArray &amp;&amp; (!HasMapper || RTArgs.MappersArray) &amp;&amp; NumberOfPtrs; &#125; bool requiresDevicePointerInfo() &#123; return RequiresDevicePointerInfo; &#125; bool separateBeginEndCalls() &#123; return SeparateBeginEndCalls; &#125; &#125;;

enum class DeviceInfoTy &#123; None, Pointer, Address &#125;; using MapValuesArrayTy = <a href="/docs/api/classes/llvm/smallvector">SmallVector&lt;Value &#42;, 4&gt;</a>; using MapDeviceInfoArrayTy = <a href="/docs/api/classes/llvm/smallvector">SmallVector&lt;DeviceInfoTy, 4&gt;</a>; using MapFlagsArrayTy = <a href="/docs/api/classes/llvm/smallvector">SmallVector&lt;omp::OpenMPOffloadMappingFlags, 4&gt;</a>; using MapNamesArrayTy = <a href="/docs/api/classes/llvm/smallvector">SmallVector&lt;Constant &#42;, 4&gt;</a>; using MapDimArrayTy = <a href="/docs/api/classes/llvm/smallvector">SmallVector&lt;uint64&#95;t, 4&gt;</a>; using MapNonContiguousArrayTy = <a href="/docs/api/classes/llvm/smallvector">SmallVector&lt;MapValuesArrayTy, 4&gt;</a>;

/ This structure contains combined information generated for mappable / clauses, including base pointers, pointers, sizes, map types, user-defined / mappers, and non-contiguous information. struct MapInfosTy &#123; struct StructNonContiguousInfo &#123; bool IsNonContiguous = false; MapDimArrayTy Dims; MapNonContiguousArrayTy Offsets; MapNonContiguousArrayTy Counts; MapNonContiguousArrayTy Strides; &#125;; MapValuesArrayTy BasePointers; MapValuesArrayTy Pointers; MapDeviceInfoArrayTy DevicePointers; MapValuesArrayTy Sizes; MapFlagsArrayTy Types; MapNamesArrayTy Names; StructNonContiguousInfo NonContigInfo;

/ Append arrays in <em>CurInfo</em>. void append(MapInfosTy &amp;CurInfo) &#123; BasePointers.append(CurInfo.BasePointers.begin(), CurInfo.BasePointers.end()); Pointers.append(CurInfo.Pointers.begin(), CurInfo.Pointers.end()); DevicePointers.append(CurInfo.DevicePointers.begin(), CurInfo.DevicePointers.end()); Sizes.append(CurInfo.Sizes.begin(), CurInfo.Sizes.end()); Types.append(CurInfo.Types.begin(), CurInfo.Types.end()); Names.append(CurInfo.Names.begin(), CurInfo.Names.end()); NonContigInfo.Dims.append(CurInfo.NonContigInfo.Dims.begin(), CurInfo.NonContigInfo.Dims.end()); NonContigInfo.Offsets.append(CurInfo.NonContigInfo.Offsets.begin(), CurInfo.NonContigInfo.Offsets.end()); NonContigInfo.Counts.append(CurInfo.NonContigInfo.Counts.begin(), CurInfo.NonContigInfo.Counts.end()); NonContigInfo.Strides.append(CurInfo.NonContigInfo.Strides.begin(), CurInfo.NonContigInfo.Strides.end()); &#125; &#125;;

/ Callback function type for functions emitting the host fallback code that / is executed when the kernel launch fails. It takes an insertion point as / parameter where the code should be emitted. It returns an insertion point / that points right after after the emitted code. using EmitFallbackCallbackTy = <a href="/docs/api/classes/llvm/function-ref">function&#95;ref&lt;InsertPointOrErrorTy(InsertPointTy)&gt;</a>;

/ Generate a target region entry call and host fallback call. / /
<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The location at which the request originated and is fulfilled. /</ParametersListItem>
<ParametersListItem name="OutlinedFnID">The ooulined function <a href="/docs/api/namespaces/llvm/callingconv/#abdf8cf606905c10634e831390981b0ed">ID</a>. /</ParametersListItem>
<ParametersListItem name="EmitTargetCallFallbackCB">Call back function to generate host / fallback code. /</ParametersListItem>
<ParametersListItem name="Args">Data structure holding information about the kernel arguments. /</ParametersListItem>
<ParametersListItem name="DeviceID">Identifier for the device via the &#39;device&#39; clause. /</ParametersListItem>
<ParametersListItem name="RTLoc">Source location identifier /</ParametersListItem>
<ParametersListItem name="AllocaIP">
The insertion point to be used for alloca instructions. <a href="#af24d1c61cec57095ced3b08a6dd99ee8">InsertPointOrErrorTy</a> emitKernelLaunch(const LocationDescription &amp;Loc, Value &#42;OutlinedFnID,
                   EmitFallbackCallbackTy EmitTargetCallFallbackCB,
                   TargetKernelArgs &amp;Args, Value &#42;DeviceID, Value &#42;RTLoc,
                   InsertPointTy AllocaIP);
</ParametersListItem>
</ParametersList>
/ Callback type for generating the bodies of device directives that require / outer target tasks (e.g. in case of having <code>nowait</code> or <code>depend</code> clauses). / /
<ParametersList title="Parameters">
<ParametersListItem name="DeviceID">The <a href="/docs/api/namespaces/llvm/callingconv/#abdf8cf606905c10634e831390981b0ed">ID</a> of the device on which the target region will / execute. /</ParametersListItem>
<ParametersListItem name="RTLoc">Source location identifier / \\Param TargetTaskAllocaIP Insertion point for the alloca block of the / generated task. / /</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
an error, if any were triggered during execution. using TargetTaskBodyCallbackTy = <a href="/docs/api/classes/llvm/function-ref">function&#95;ref</a>&lt;<a href="/docs/api/namespaces/llvm/#ac226f3d2b9ca090171a8e0a8cb92c343a902b0d55fddef6f8d651fe1035b7d4bd">Error(Value &#42;DeviceID, Value &#42;RTLoc,
                         IRBuilderBase::InsertPoint TargetTaskAllocaIP)</a>&gt;;
</SectionUser>

/ Generate a target-task for the target construct / /
<ParametersList title="Parameters">
<ParametersListItem name="TaskBodyCB">Callback to generate the actual body of the target task. /</ParametersListItem>
<ParametersListItem name="DeviceID">Identifier for the device via the &#39;device&#39; clause. /</ParametersListItem>
<ParametersListItem name="RTLoc">Source location identifier /</ParametersListItem>
<ParametersListItem name="AllocaIP">The insertion point to be used for alloca instructions. /</ParametersListItem>
<ParametersListItem name="Dependencies">Vector of <a href="/docs/api/structs/llvm/openmpirbuilder/dependdata">DependData</a> objects holding information of / dependencies as specified by the &#39;depend&#39; clause. /</ParametersListItem>
<ParametersListItem name="HasNoWait">
True if the target construct had &#39;nowait&#39; on it, false / otherwise <a href="#af24d1c61cec57095ced3b08a6dd99ee8">InsertPointOrErrorTy</a> emitTargetTask(
      TargetTaskBodyCallbackTy TaskBodyCB, Value &#42;DeviceID, Value &#42;RTLoc,
      OpenMPIRBuilder::InsertPointTy AllocaIP,
      const SmallVector&lt;llvm::OpenMPIRBuilder::DependData&gt; &amp;Dependencies,
      bool HasNoWait);
</ParametersListItem>
</ParametersList>
/ Emit the arguments to be passed to the runtime library based on the / arrays of base pointers, pointers, sizes, map types, and mappers. If / ForEndCall, emit map types to be passed for the end of the region instead / of the beginning. void emitOffloadingArraysArgument(<a href="/docs/api/classes/llvm/irbuilderbase">IRBuilderBase</a> &amp;Builder, OpenMPIRBuilder::TargetDataRTArgs &amp;RTArgs, OpenMPIRBuilder::TargetDataInfo &amp;Info, bool ForEndCall = false);

/ Emit an array of struct descriptors to be assigned to the offload args. void emitNonContiguousDescriptor(InsertPointTy AllocaIP,
                                   InsertPointTy CodeGenIP,
                                   MapInfosTy &amp;CombinedInfo,
                                   TargetDataInfo &amp;Info);

/ Emit the arrays used to pass the captures and map information to the / offloading runtime library. If there is no map or capture information, / return nullptr by reference. Accepts a reference to a MapInfosTy object / that contains information generated for mappable clauses, / including base pointers, pointers, sizes, map types, user-defined mappers. void emitOffloadingArrays( <a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> AllocaIP, <a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> CodeGenIP, MapInfosTy &amp;CombinedInfo, TargetDataInfo &amp;Info, bool IsNonContiguous = false, <a href="/docs/api/classes/llvm/function-ref">function&#95;ref&lt;void(unsigned int, Value &#42;)&gt;</a> DeviceAddrCB = nullptr, <a href="/docs/api/classes/llvm/function-ref">function&#95;ref&lt;Value &#42;(unsigned int)&gt;</a> CustomMapperCB = nullptr);

/ Allocates memory for and populates the arrays required for offloading / (offload&#95;&#123;baseptrs|ptrs|mappers|sizes|maptypes|mapnames&#125;). Then, it / emits their base addresses as arguments to be passed to the runtime / library. In essence, this function is a combination of / emitOffloadingArrays and emitOffloadingArraysArgument and should arguably / be preferred by clients of <a href="/docs/api/classes/llvm/openmpirbuilder">OpenMPIRBuilder</a>. void emitOffloadingArraysAndArgs( <a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> AllocaIP, <a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> CodeGenIP, TargetDataInfo &amp;Info, TargetDataRTArgs &amp;RTArgs, MapInfosTy &amp;CombinedInfo, bool IsNonContiguous = false, bool ForEndCall = false, <a href="/docs/api/classes/llvm/function-ref">function&#95;ref&lt;void(unsigned int, Value &#42;)&gt;</a> DeviceAddrCB = nullptr, <a href="/docs/api/classes/llvm/function-ref">function&#95;ref&lt;Value &#42;(unsigned int)&gt;</a> CustomMapperCB = nullptr);

/ Creates offloading entry for the provided entry <a href="/docs/api/namespaces/llvm/callingconv/#abdf8cf606905c10634e831390981b0ed">ID</a> <em><a href="/docs/api/namespaces/llvm/callingconv/#abdf8cf606905c10634e831390981b0ed">ID</a></em>, address <em>/</em> Addr, size <em>Size</em>, and flags <em>Flags</em>. void createOffloadEntry(<a href="/docs/api/classes/llvm/constant">Constant</a> &#42;ID, <a href="/docs/api/classes/llvm/constant">Constant</a> &#42;Addr, uint64&#95;t Size, int32&#95;t Flags, <a href="/docs/api/classes/llvm/globalvalue/#aedfa75f0c85c4aa85b257f066fbea57c">GlobalValue::LinkageTypes</a>, <a href="/docs/api/classes/llvm/stringref">StringRef</a> Name = &quot;&quot;);

/ The kind of errors that can occur when emitting the offload entries and / metadata. enum EmitMetadataErrorKind &#123; EMIT&#95;MD&#95;TARGET&#95;REGION&#95;ERROR, EMIT&#95;MD&#95;DECLARE&#95;TARGET&#95;ERROR, EMIT&#95;MD&#95;GLOBAL&#95;VAR&#95;LINK&#95;ERROR &#125;;

/ Callback function type using EmitMetadataErrorReportFunctionTy = std::function&lt;void(EmitMetadataErrorKind, TargetRegionEntryInfo)&gt;;

Emit the offloading entries and metadata so that the device codegen side can easily figure out what to emit. The produced metadata looks like this:

!omp&#95;offload.info = !&#123;!1, ...&#125;

We only generate metadata for function that contain target regions. void createOffloadEntriesAndInfoMetadata(
      EmitMetadataErrorReportFunctionTy &amp;ErrorReportFunction);

public: / Generator for &#95;&#95;kmpc&#95;copyprivate / /
<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The source location description. /</ParametersListItem>
<ParametersListItem name="BufSize">Number of elements in the buffer. /</ParametersListItem>
<ParametersListItem name="CpyBuf">List of pointers to data to be copied. /</ParametersListItem>
<ParametersListItem name="CpyFn">function to call for copying data. /</ParametersListItem>
<ParametersListItem name="DidIt">flag variable; 1 for &#39;single&#39; thread, 0 otherwise. / /</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
The insertion position <em>after</em> the CopyPrivate call.
</SectionUser>

<a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> createCopyPrivate(const LocationDescription &amp;Loc,
                                  llvm::Value &#42;BufSize, llvm::Value &#42;CpyBuf,
                                  llvm::Value &#42;CpyFn, llvm::Value &#42;DidIt);

/ Generator for &#39;<a href="/docs/api/namespaces/llvm/omp">omp</a> single&#39; / /
<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The source location description. /</ParametersListItem>
<ParametersListItem name="BodyGenCB">Callback that will generate the region code. /</ParametersListItem>
<ParametersListItem name="FiniCB">Callback to finalize variable copies. /</ParametersListItem>
<ParametersListItem name="IsNowait">If false, a barrier is emitted. /</ParametersListItem>
<ParametersListItem name="CPVars">copyprivate variables. /</ParametersListItem>
<ParametersListItem name="CPFuncs">copy functions to use for each copyprivate variable. / /</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
The insertion position <em>after</em> the single call. <a href="#af24d1c61cec57095ced3b08a6dd99ee8">InsertPointOrErrorTy</a> createSingle(const <a href="/docs/api/structs/llvm/openmpirbuilder/locationdescription">LocationDescription</a> &amp;<a href="/docs/api/namespaces/llvm/loc">Loc</a>, <a href="#a49e35e3ee470add16efcde1ab5d5556b">BodyGenCallbackTy</a> BodyGenCB, <a href="#a0c571620ff53fdb78e7404f5261dbd23">FinalizeCallbackTy</a> FiniCB, bool IsNowait, <a href="/docs/api/classes/llvm/arrayref">ArrayRef&lt;llvm::Value &#42;&gt;</a> CPVars = &#123;&#125;, <a href="/docs/api/classes/llvm/arrayref">ArrayRef&lt;llvm::Function &#42;&gt;</a> CPFuncs = &#123;&#125;);
</SectionUser>

/ Generator for &#39;<a href="/docs/api/namespaces/llvm/omp">omp</a> master&#39; / /
<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The insert and source location description. /</ParametersListItem>
<ParametersListItem name="BodyGenCB">Callback that will generate the region code. /</ParametersListItem>
<ParametersListItem name="FiniCB">Callback to finalize variable copies. / /</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
The insertion position <em>after</em> the master. <a href="#af24d1c61cec57095ced3b08a6dd99ee8">InsertPointOrErrorTy</a> createMaster(const LocationDescription &amp;Loc,
                                    BodyGenCallbackTy BodyGenCB,
                                    FinalizeCallbackTy FiniCB);
</SectionUser>

/ Generator for &#39;<a href="/docs/api/namespaces/llvm/omp">omp</a> masked&#39; / /
<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The insert and source location description. /</ParametersListItem>
<ParametersListItem name="BodyGenCB">Callback that will generate the region code. /</ParametersListItem>
<ParametersListItem name="FiniCB">Callback to finialize variable copies. / /</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
The insertion position <em>after</em> the masked. <a href="#af24d1c61cec57095ced3b08a6dd99ee8">InsertPointOrErrorTy</a> createMasked(const LocationDescription &amp;Loc,
                                    BodyGenCallbackTy BodyGenCB,
                                    FinalizeCallbackTy FiniCB, Value &#42;Filter);
</SectionUser>

/ Generator for &#39;<a href="/docs/api/namespaces/llvm/omp">omp</a> critical&#39; / /
<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The insert and source location description. /</ParametersListItem>
<ParametersListItem name="BodyGenCB">Callback that will generate the region body code. /</ParametersListItem>
<ParametersListItem name="FiniCB">Callback to finalize variable copies. /</ParametersListItem>
<ParametersListItem name="CriticalName">name of the lock used by the critical directive /</ParametersListItem>
<ParametersListItem name="HintInst">Hint <a href="/docs/api/classes/llvm/instruction">Instruction</a> for hint clause associated with critical / /</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
The insertion position <em>after</em> the critical. <a href="#af24d1c61cec57095ced3b08a6dd99ee8">InsertPointOrErrorTy</a> createCritical(const LocationDescription &amp;Loc,
                                      BodyGenCallbackTy BodyGenCB,
                                      FinalizeCallbackTy FiniCB,
                                      StringRef CriticalName, Value &#42;HintInst);
</SectionUser>

/ Generator for &#39;<a href="/docs/api/namespaces/llvm/omp">omp</a> ordered depend (source | sink)&#39; / /
<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The insert and source location description. /</ParametersListItem>
<ParametersListItem name="AllocaIP">The insertion point to be used for alloca instructions. /</ParametersListItem>
<ParametersListItem name="NumLoops">The number of loops in depend clause. /</ParametersListItem>
<ParametersListItem name="StoreValues">The value will be stored in vector address. /</ParametersListItem>
<ParametersListItem name="Name">The name of alloca instruction. /</ParametersListItem>
<ParametersListItem name="IsDependSource">If true, depend source; otherwise, depend sink. / /</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
The insertion position <em>after</em> the ordered. <a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> createOrderedDepend(const LocationDescription &amp;Loc,
                                    InsertPointTy AllocaIP, unsigned NumLoops,
                                    ArrayRef&lt;llvm::Value &#42;&gt; StoreValues,
                                    const Twine &amp;Name, bool IsDependSource);
</SectionUser>

/ Generator for &#39;<a href="/docs/api/namespaces/llvm/omp">omp</a> ordered &#91;threads | simd&#93;&#39; / /
<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The insert and source location description. /</ParametersListItem>
<ParametersListItem name="BodyGenCB">Callback that will generate the region code. /</ParametersListItem>
<ParametersListItem name="FiniCB">Callback to finalize variable copies. /</ParametersListItem>
<ParametersListItem name="IsThreads">If true, with threads clause or without clause; / otherwise, with simd clause; / /</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
The insertion position <em>after</em> the ordered. <a href="#af24d1c61cec57095ced3b08a6dd99ee8">InsertPointOrErrorTy</a> createOrderedThreadsSimd(const LocationDescription &amp;Loc,
                                                BodyGenCallbackTy BodyGenCB,
                                                FinalizeCallbackTy FiniCB,
                                                bool IsThreads);
</SectionUser>

/ Generator for &#39;<a href="/docs/api/namespaces/llvm/omp">omp</a> sections&#39; / /
<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The insert and source location description. /</ParametersListItem>
<ParametersListItem name="AllocaIP">The insertion points to be used for alloca instructions. /</ParametersListItem>
<ParametersListItem name="SectionCBs">Callbacks that will generate body of each section. /</ParametersListItem>
<ParametersListItem name="PrivCB">Callback to copy a given variable (think copy constructor). /</ParametersListItem>
<ParametersListItem name="FiniCB">Callback to finalize variable copies. /</ParametersListItem>
<ParametersListItem name="IsCancellable">Flag to indicate a cancellable parallel region. /</ParametersListItem>
<ParametersListItem name="IsNowait">If true, barrier - to ensure all sections are executed / before moving forward will not be generated. /</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
The insertion position <em>after</em> the sections. <a href="#af24d1c61cec57095ced3b08a6dd99ee8">InsertPointOrErrorTy</a> createSections(const LocationDescription &amp;Loc, InsertPointTy AllocaIP,
                 ArrayRef&lt;StorableBodyGenCallbackTy&gt; SectionCBs,
                 PrivatizeCallbackTy PrivCB, FinalizeCallbackTy FiniCB,
                 bool IsCancellable, bool IsNowait);
</SectionUser>

/ Generator for &#39;<a href="/docs/api/namespaces/llvm/omp">omp</a> section&#39; / /
<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The insert and source location description. /</ParametersListItem>
<ParametersListItem name="BodyGenCB">Callback that will generate the region body code. /</ParametersListItem>
<ParametersListItem name="FiniCB">Callback to finalize variable copies. /</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
The insertion position <em>after</em> the section. <a href="#af24d1c61cec57095ced3b08a6dd99ee8">InsertPointOrErrorTy</a> createSection(const LocationDescription &amp;Loc,
                                     BodyGenCallbackTy BodyGenCB,
                                     FinalizeCallbackTy FiniCB);
</SectionUser>

/ Generator for <code>#omp teams</code> / /
<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The location where the teams construct was encountered. /</ParametersListItem>
<ParametersListItem name="BodyGenCB">Callback that will generate the region code. /</ParametersListItem>
<ParametersListItem name="NumTeamsLower">Lower bound on number of teams. If this is nullptr, / it is as if lower bound is specified as equal to upperbound. If / this is non-null, then upperbound must also be non-null. /</ParametersListItem>
<ParametersListItem name="NumTeamsUpper">Upper bound on the number of teams. /</ParametersListItem>
<ParametersListItem name="ThreadLimit">on the number of threads that may participate in a / contention group created by each team. /</ParametersListItem>
<ParametersListItem name="IfExpr">is the integer argument value of the if condition on the / teams clause. <a href="#af24d1c61cec57095ced3b08a6dd99ee8">InsertPointOrErrorTy</a> createTeams(const <a href="/docs/api/structs/llvm/openmpirbuilder/locationdescription">LocationDescription</a> &amp;<a href="/docs/api/namespaces/llvm/loc">Loc</a>, <a href="#a49e35e3ee470add16efcde1ab5d5556b">BodyGenCallbackTy</a> BodyGenCB, <a href="/docs/api/classes/llvm/value">Value</a> &#42;NumTeamsLower = nullptr, <a href="/docs/api/classes/llvm/value">Value</a> &#42;NumTeamsUpper = nullptr, <a href="/docs/api/classes/llvm/value">Value</a> &#42;ThreadLimit = nullptr, <a href="/docs/api/classes/llvm/value">Value</a> &#42;IfExpr = nullptr);</ParametersListItem>
</ParametersList>
/ Generate conditional branch and relevant BasicBlocks through which private / threads copy the &#39;copyin&#39; variables from Master copy to threadprivate / copies. / /
<ParametersList title="Parameters">
<ParametersListItem name="IP">insertion block for copyin conditional /</ParametersListItem>
<ParametersListItem name="MasterVarPtr">a pointer to the master variable /</ParametersListItem>
<ParametersListItem name="PrivateVarPtr">a pointer to the threadprivate variable /</ParametersListItem>
<ParametersListItem name="IntPtrTy">Pointer size type /</ParametersListItem>
<ParametersListItem name="BranchtoEnd">Create a branch between the copyin.not.master blocks and copy.in.end block / /</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
The insertion point where copying operation to be emitted. <a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> createCopyinClauseBlocks(<a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> IP, <a href="/docs/api/classes/llvm/value">Value</a> &#42;MasterAddr, <a href="/docs/api/classes/llvm/value">Value</a> &#42;PrivateAddr, <a href="/docs/api/classes/llvm/integertype">llvm::IntegerType</a> &#42;IntPtrTy, bool BranchtoEnd = true);
</SectionUser>

/ Create a runtime call for kmpc&#95;Alloc / /
<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The insert and source location description. /</ParametersListItem>
<ParametersListItem name="Size">Size of allocated memory space /</ParametersListItem>
<ParametersListItem name="Allocator">Allocator information instruction /</ParametersListItem>
<ParametersListItem name="Name">Name of call <a href="/docs/api/classes/llvm/instruction">Instruction</a> for OMP&#95;alloc / /</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
<a href="/docs/api/classes/llvm/callinst">CallInst</a> to the OMP&#95;Alloc call <a href="/docs/api/classes/llvm/callinst">CallInst</a> &#42;createOMPAlloc(const <a href="/docs/api/structs/llvm/openmpirbuilder/locationdescription">LocationDescription</a> &amp;<a href="/docs/api/namespaces/llvm/loc">Loc</a>, <a href="/docs/api/classes/llvm/value">Value</a> &#42;Size, <a href="/docs/api/classes/llvm/value">Value</a> &#42;Allocator, std::string Name = &quot;&quot;);
</SectionUser>

/ Create a runtime call for kmpc&#95;free / /
<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The insert and source location description. /</ParametersListItem>
<ParametersListItem name="Addr">Address of memory space to be freed /</ParametersListItem>
<ParametersListItem name="Allocator">Allocator information instruction /</ParametersListItem>
<ParametersListItem name="Name">Name of call <a href="/docs/api/classes/llvm/instruction">Instruction</a> for OMP&#95;Free / /</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
<a href="/docs/api/classes/llvm/callinst">CallInst</a> to the OMP&#95;Free call <a href="/docs/api/classes/llvm/callinst">CallInst</a> &#42;createOMPFree(const <a href="/docs/api/structs/llvm/openmpirbuilder/locationdescription">LocationDescription</a> &amp;<a href="/docs/api/namespaces/llvm/loc">Loc</a>, <a href="/docs/api/classes/llvm/value">Value</a> &#42;Addr, <a href="/docs/api/classes/llvm/value">Value</a> &#42;Allocator, std::string Name = &quot;&quot;);
</SectionUser>

/ Create a runtime call for kmpc&#95;threadprivate&#95;cached / /
<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The insert and source location description. /</ParametersListItem>
<ParametersListItem name="Pointer">pointer to data to be cached /</ParametersListItem>
<ParametersListItem name="Size">size of data to be cached /</ParametersListItem>
<ParametersListItem name="Name">Name of call <a href="/docs/api/classes/llvm/instruction">Instruction</a> for callinst / /</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
<a href="/docs/api/classes/llvm/callinst">CallInst</a> to the thread private cache call. <a href="/docs/api/classes/llvm/callinst">CallInst</a> &#42;createCachedThreadPrivate(const <a href="/docs/api/structs/llvm/openmpirbuilder/locationdescription">LocationDescription</a> &amp;<a href="/docs/api/namespaces/llvm/loc">Loc</a>, <a href="/docs/api/classes/llvm/value">llvm::Value</a> &#42;Pointer, <a href="/docs/api/classes/llvm/constantint">llvm::ConstantInt</a> &#42;Size, const <a href="/docs/api/classes/llvm/twine">llvm::Twine</a> &amp;Name = <a href="/docs/api/classes/llvm/twine">Twine</a>(&quot;&quot;));
</SectionUser>

/ Create a runtime call for &#95;&#95;tgt&#95;interop&#95;init / /
<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The insert and source location description. /</ParametersListItem>
<ParametersListItem name="InteropVar">variable to be allocated /</ParametersListItem>
<ParametersListItem name="InteropType">type of interop operation /</ParametersListItem>
<ParametersListItem name="Device">devide to which offloading will occur /</ParametersListItem>
<ParametersListItem name="NumDependences">number of dependence variables /</ParametersListItem>
<ParametersListItem name="DependenceAddress">pointer to dependence variables /</ParametersListItem>
<ParametersListItem name="HaveNowaitClause">does nowait clause exist / /</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
<a href="/docs/api/classes/llvm/callinst">CallInst</a> to the &#95;&#95;tgt&#95;interop&#95;init call <a href="/docs/api/classes/llvm/callinst">CallInst</a> &#42;createOMPInteropInit(const <a href="/docs/api/structs/llvm/openmpirbuilder/locationdescription">LocationDescription</a> &amp;<a href="/docs/api/namespaces/llvm/loc">Loc</a>, <a href="/docs/api/classes/llvm/value">Value</a> &#42;InteropVar, <a href="/docs/api/namespaces/llvm/omp/#afeaad9a7fc12d9246c2e42578fddc718">omp::OMPInteropType</a> InteropType, <a href="/docs/api/classes/llvm/value">Value</a> &#42;Device, <a href="/docs/api/classes/llvm/value">Value</a> &#42;NumDependences, <a href="/docs/api/classes/llvm/value">Value</a> &#42;DependenceAddress, bool HaveNowaitClause);
</SectionUser>

/ Create a runtime call for &#95;&#95;tgt&#95;interop&#95;destroy / /
<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The insert and source location description. /</ParametersListItem>
<ParametersListItem name="InteropVar">variable to be allocated /</ParametersListItem>
<ParametersListItem name="Device">devide to which offloading will occur /</ParametersListItem>
<ParametersListItem name="NumDependences">number of dependence variables /</ParametersListItem>
<ParametersListItem name="DependenceAddress">pointer to dependence variables /</ParametersListItem>
<ParametersListItem name="HaveNowaitClause">does nowait clause exist / /</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
<a href="/docs/api/classes/llvm/callinst">CallInst</a> to the &#95;&#95;tgt&#95;interop&#95;destroy call <a href="/docs/api/classes/llvm/callinst">CallInst</a> &#42;createOMPInteropDestroy(const <a href="/docs/api/structs/llvm/openmpirbuilder/locationdescription">LocationDescription</a> &amp;<a href="/docs/api/namespaces/llvm/loc">Loc</a>, <a href="/docs/api/classes/llvm/value">Value</a> &#42;InteropVar, <a href="/docs/api/classes/llvm/value">Value</a> &#42;Device, <a href="/docs/api/classes/llvm/value">Value</a> &#42;NumDependences, <a href="/docs/api/classes/llvm/value">Value</a> &#42;DependenceAddress, bool HaveNowaitClause);
</SectionUser>

/ Create a runtime call for &#95;&#95;tgt&#95;interop&#95;use / /
<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The insert and source location description. /</ParametersListItem>
<ParametersListItem name="InteropVar">variable to be allocated /</ParametersListItem>
<ParametersListItem name="Device">devide to which offloading will occur /</ParametersListItem>
<ParametersListItem name="NumDependences">number of dependence variables /</ParametersListItem>
<ParametersListItem name="DependenceAddress">pointer to dependence variables /</ParametersListItem>
<ParametersListItem name="HaveNowaitClause">does nowait clause exist / /</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
<a href="/docs/api/classes/llvm/callinst">CallInst</a> to the &#95;&#95;tgt&#95;interop&#95;use call <a href="/docs/api/classes/llvm/callinst">CallInst</a> &#42;createOMPInteropUse(const <a href="/docs/api/structs/llvm/openmpirbuilder/locationdescription">LocationDescription</a> &amp;<a href="/docs/api/namespaces/llvm/loc">Loc</a>, <a href="/docs/api/classes/llvm/value">Value</a> &#42;InteropVar, <a href="/docs/api/classes/llvm/value">Value</a> &#42;Device, <a href="/docs/api/classes/llvm/value">Value</a> &#42;NumDependences, <a href="/docs/api/classes/llvm/value">Value</a> &#42;DependenceAddress, bool HaveNowaitClause);
</SectionUser>

/ The <code>omp target</code> interface / / For more information about the usage of this interface, / 
<SectionUser title="See Also">
openmp/libomptarget/deviceRTLs/common/include/target.h / /&#123;
</SectionUser>

/ Create a runtime call for kmpc&#95;target&#95;init / /
<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The insert and source location description. /</ParametersListItem>
<ParametersListItem name="Attrs">
Structure containing the default attributes, including / numbers of threads and teams to launch the kernel with. <a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> createTargetInit(
      const LocationDescription &amp;Loc,
      const llvm::OpenMPIRBuilder::TargetKernelDefaultAttrs &amp;Attrs);
</ParametersListItem>
</ParametersList>
/ Create a runtime call for kmpc&#95;target&#95;deinit / /
<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The insert and source location description. /</ParametersListItem>
<ParametersListItem name="TeamsReductionDataSize">The maximal size of all the reduction data / for teams reduction. /</ParametersListItem>
<ParametersListItem name="TeamsReductionBufferLength">The number of elements (each of up to / <code>TeamsReductionDataSize</code> size), in the teams reduction buffer. void createTargetDeinit(const <a href="/docs/api/structs/llvm/openmpirbuilder/locationdescription">LocationDescription</a> &amp;<a href="/docs/api/namespaces/llvm/loc">Loc</a>, int32&#95;t TeamsReductionDataSize = 0, int32&#95;t TeamsReductionBufferLength = 1024);</ParametersListItem>
</ParametersList>
/&#125;

/ Helpers to read/write kernel annotations from the IR. / /&#123;

/ Read/write a bounds on threads for <code>Kernel</code>. Read will return 0 if none / is set. static std::pair&lt;int32&#95;t, int32&#95;t&gt; readThreadBoundsForKernel(const Triple &amp;T, Function &amp;Kernel); static void writeThreadBoundsForKernel(const Triple &amp;T, Function &amp;Kernel,
                                         int32&#95;t LB, int32&#95;t UB);

/ Read/write a bounds on teams for <code>Kernel</code>. Read will return 0 if none / is set. static std::pair&lt;int32&#95;t, int32&#95;t&gt; readTeamBoundsForKernel(const Triple &amp;T,
                                                             Function &amp;Kernel); static void writeTeamsForKernel(const Triple &amp;T, Function &amp;Kernel, int32&#95;t LB,
                                  int32&#95;t UB); /&#125;

private: Sets the function attributes expected for the outlined function void setOutlinedTargetRegionFunctionAttributes(Function &#42;OutlinedFn);

Creates the function ID/Address for the given outlined function. In the case of an embedded device function the address of the function is used, in the case of a non-offload function a constant is created. <a href="/docs/api/classes/llvm/constant">Constant</a> &#42;createOutlinedFunctionID(<a href="/docs/api/classes/llvm/function">Function</a> &#42;OutlinedFn, <a href="/docs/api/classes/llvm/stringref">StringRef</a> EntryFnIDName);

Creates the region entry address for the outlined function <a href="/docs/api/classes/llvm/constant">Constant</a> &#42;createTargetRegionEntryAddr(<a href="/docs/api/classes/llvm/function">Function</a> &#42;OutlinedFunction, <a href="/docs/api/classes/llvm/stringref">StringRef</a> EntryFnName);

public: / Functions used to generate a function with the given name. using FunctionGenCallback = std::function&lt;Expected&lt;Function &#42;&gt;(StringRef FunctionName)&gt;;

/ Create a unique name for the entry function using the source location / information of the current target region. The name will be something like: / / &#95;&#95;omp&#95;offloading&#95;DD&#95;FFFF&#95;PP&#95;lBB&#91;&#95;CC&#93; / / where DD&#95;FFFF is an <a href="/docs/api/namespaces/llvm/callingconv/#abdf8cf606905c10634e831390981b0ed">ID</a> unique to the file (device and file IDs), PP is the / mangled name of the function that encloses the target region and BB is the / line number of the target region. CC is a count added when more than one / region is located at the same location. / / If this target outline function is not an offload entry, we don&#39;t need to / register it. This may happen if it is guarded by an if clause that is / false at compile time, or no target archs have been specified. / / The created target region <a href="/docs/api/namespaces/llvm/callingconv/#abdf8cf606905c10634e831390981b0ed">ID</a> is used by the runtime library to identify / the current target region, so it only has to be unique and not / necessarily point to anything. It could be the pointer to the outlined / function that implements the target region, but we aren&#39;t using that so / that the compiler doesn&#39;t need to keep that, and could therefore inline / the host function if proven worthwhile during optimization. In the other / hand, if emitting code for the device, the <a href="/docs/api/namespaces/llvm/callingconv/#abdf8cf606905c10634e831390981b0ed">ID</a> has to be the function / address so that it can retrieved from the offloading entry and launched / by the runtime library. We also mark the outlined function to have / external linkage in case we are emitting code for the device, because / these functions will be entry points to the device. / /
<ParametersList title="Parameters">
<ParametersListItem name="InfoManager">The info manager keeping track of the offload entries /</ParametersListItem>
<ParametersListItem name="EntryInfo">The entry information about the function /</ParametersListItem>
<ParametersListItem name="GenerateFunctionCallback">The callback function to generate the code /</ParametersListItem>
<ParametersListItem name="OutlinedFunction">Pointer to the outlined function /</ParametersListItem>
<ParametersListItem name="EntryFnIDName">
Name of the <a href="/docs/api/namespaces/llvm/callingconv/#abdf8cf606905c10634e831390981b0ed">ID</a> o be created <a href="/docs/api/classes/llvm/error">Error</a> emitTargetRegionFunction(TargetRegionEntryInfo &amp;EntryInfo,
                                 FunctionGenCallback &amp;GenerateFunctionCallback,
                                 bool IsOffloadEntry, Function &#42;&amp;OutlinedFn,
                                 Constant &#42;&amp;OutlinedFnID);
</ParametersListItem>
</ParametersList>
/ Registers the given function and sets up the attribtues of the function / Returns the FunctionID. / /
<ParametersList title="Parameters">
<ParametersListItem name="InfoManager">The info manager keeping track of the offload entries /</ParametersListItem>
<ParametersListItem name="EntryInfo">The entry information about the function /</ParametersListItem>
<ParametersListItem name="OutlinedFunction">Pointer to the outlined function /</ParametersListItem>
<ParametersListItem name="EntryFnName">Name of the outlined function /</ParametersListItem>
<ParametersListItem name="EntryFnIDName">Name of the <a href="/docs/api/namespaces/llvm/callingconv/#abdf8cf606905c10634e831390981b0ed">ID</a> o be created <a href="/docs/api/classes/llvm/constant">Constant</a> &#42;registerTargetRegionFunction(<a href="/docs/api/structs/llvm/targetregionentryinfo">TargetRegionEntryInfo</a> &amp;EntryInfo, <a href="/docs/api/classes/llvm/function">Function</a> &#42;OutlinedFunction, <a href="/docs/api/classes/llvm/stringref">StringRef</a> EntryFnName, <a href="/docs/api/classes/llvm/stringref">StringRef</a> EntryFnIDName);</ParametersListItem>
</ParametersList>
/ <a href="/docs/api/classes/llvm/type">Type</a> of BodyGen to use for region codegen / / Priv: If device pointer privatization is required, emit the body of the / region here. It will have to be duplicated: with and without / privatization. / DupNoPriv: If we need device pointer privatization, we need / to emit the body of the region with no privatization in the &#39;else&#39; branch / of the conditional. / NoPriv: If we don&#39;t require privatization of device / pointers, we emit the body in between the runtime calls. This avoids / duplicating the body code. enum BodyGenTy &#123; Priv, DupNoPriv, NoPriv &#125;;

/ Callback type for creating the map infos for the kernel parameters. /
<ParametersList title="Parameters">
<ParametersListItem name="CodeGenIP">is the insertion point where code should be generated, / if any. using GenMapInfoCallbackTy = <a href="/docs/api/classes/llvm/function-ref">function&#95;ref&lt;MapInfosTy &amp;(InsertPointTy CodeGenIP)&gt;</a>;</ParametersListItem>
</ParametersList>
private: / Emit the array initialization or deletion portion for user-defined mapper / code generation. First, it evaluates whether an array section is mapped / and whether the <em>MapType</em> instructs to delete this section. If <em>IsInit</em> / is true, and <em>MapType</em> indicates to not delete this array, array / initialization code is generated. If <em>IsInit</em> is false, and <em>MapType</em> / indicates to delete this array, array deletion code is generated. void emitUDMapperArrayInitOrDel(Function &#42;MapperFn, llvm::Value &#42;MapperHandle,
                                  llvm::Value &#42;Base, llvm::Value &#42;Begin,
                                  llvm::Value &#42;Size, llvm::Value &#42;MapType,
                                  llvm::Value &#42;MapName, TypeSize ElementSize,
                                  llvm::BasicBlock &#42;ExitBB, bool IsInit);

public: / Emit the user-defined mapper function. The code generation follows the / pattern in the example below. / 
<ProgramListing>

<CodeLine><span class="doxyHighlightComment">/// void .omp&#95;mapper.&lt;type&#95;name&gt;.&lt;mapper&#95;id&gt;.(void &#42;rt&#95;mapper&#95;handle,</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///                                           void &#42;base, void &#42;begin,</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///                                           int64&#95;t size, int64&#95;t type,</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///                                           void &#42;name = nullptr) &#123;</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///   // Allocate space for an array section first or add a base/begin for</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///   // pointer dereference.</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///   if ((size &gt; 1 || (base != begin &amp;&amp; maptype.IsPtrAndObj)) &amp;&amp;</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///       !maptype.IsDelete)</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///     &#95;&#95;tgt&#95;push&#95;mapper&#95;component(rt&#95;mapper&#95;handle, base, begin,</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///                                 size&#42;sizeof(Ty), clearToFromMember(type));</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///   // Map members.</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///   for (unsigned i = 0; i &lt; size; i++) &#123;</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///     // For each component specified by this mapper:</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///     for (auto c : begin&#91;i&#93;-&gt;all&#95;components) &#123;</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///       if (c.hasMapper())</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///         (&#42;c.Mapper())(rt&#95;mapper&#95;handle, c.arg&#95;base, c.arg&#95;begin,</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///         c.arg&#95;size,</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///                       c.arg&#95;type, c.arg&#95;name);</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///       else</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///         &#95;&#95;tgt&#95;push&#95;mapper&#95;component(rt&#95;mapper&#95;handle, c.arg&#95;base,</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///                                     c.arg&#95;begin, c.arg&#95;size, c.arg&#95;type,</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///                                     c.arg&#95;name);</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///     &#125;</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///   &#125;</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///   // Delete the array section.</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///   if (size &gt; 1 &amp;&amp; maptype.IsDelete)</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///     &#95;&#95;tgt&#95;push&#95;mapper&#95;component(rt&#95;mapper&#95;handle, base, begin,</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">///                                 size&#42;sizeof(Ty), clearToFromMember(type));</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">/// &#125;</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">/// </span></CodeLine>

</ProgramListing>
 / /
<ParametersList title="Parameters">
<ParametersListItem name="PrivAndGenMapInfoCB">Callback that privatizes code and populates the / MapInfos and returns. /</ParametersListItem>
<ParametersListItem name="ElemTy">DeclareMapper element type. /</ParametersListItem>
<ParametersListItem name="FuncName">Optional param to specify mapper function name. /</ParametersListItem>
<ParametersListItem name="CustomMapperCB">Optional callback to generate code related to / custom mappers. <a href="/docs/api/classes/llvm/function">Function</a> &#42;emitUserDefinedMapper( <a href="/docs/api/classes/llvm/function-ref">function&#95;ref</a>&lt;MapInfosTy &amp;(<a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> CodeGenIP, <a href="/docs/api/classes/llvm/value">llvm::Value</a> &#42;PtrPHI, <a href="/docs/api/classes/llvm/value">llvm::Value</a> &#42;BeginArg)&gt; PrivAndGenMapInfoCB, <a href="/docs/api/classes/llvm/type">llvm::Type</a> &#42;ElemTy, <a href="/docs/api/classes/llvm/stringref">StringRef</a> FuncName, <a href="/docs/api/classes/llvm/function-ref">function&#95;ref&lt;bool(unsigned int, Function &#42;&#42;)&gt;</a> CustomMapperCB = nullptr);</ParametersListItem>
</ParametersList>
/ Generator for &#39;<a href="/docs/api/namespaces/llvm/omp">omp</a> target data&#39; / /
<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The location where the target data construct was encountered. /</ParametersListItem>
<ParametersListItem name="AllocaIP">The insertion points to be used for alloca instructions. /</ParametersListItem>
<ParametersListItem name="CodeGenIP">The insertion point at which the target directive code / should be placed. /</ParametersListItem>
<ParametersListItem name="IsBegin">If true then emits begin mapper call otherwise emits / end mapper call. /</ParametersListItem>
<ParametersListItem name="DeviceID">Stores the DeviceID from the device clause. /</ParametersListItem>
<ParametersListItem name="IfCond"><a href="/docs/api/classes/llvm/value">Value</a> which corresponds to the if clause condition. /</ParametersListItem>
<ParametersListItem name="Info">Stores all information realted to the <a href="/docs/api/classes/llvm/target">Target</a> Data directive. /</ParametersListItem>
<ParametersListItem name="GenMapInfoCB">Callback that populates the MapInfos and returns. /</ParametersListItem>
<ParametersListItem name="BodyGenCB">Optional Callback to generate the region code. /</ParametersListItem>
<ParametersListItem name="DeviceAddrCB">Optional callback to generate code related to / use&#95;device&#95;ptr and use&#95;device&#95;addr. /</ParametersListItem>
<ParametersListItem name="CustomMapperCB">
Optional callback to generate code related to / custom mappers. <a href="#af24d1c61cec57095ced3b08a6dd99ee8">InsertPointOrErrorTy</a> createTargetData( const <a href="/docs/api/structs/llvm/openmpirbuilder/locationdescription">LocationDescription</a> &amp;<a href="/docs/api/namespaces/llvm/loc">Loc</a>, <a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> AllocaIP, <a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> CodeGenIP, <a href="/docs/api/classes/llvm/value">Value</a> &#42;DeviceID, <a href="/docs/api/classes/llvm/value">Value</a> &#42;IfCond, TargetDataInfo &amp;Info, GenMapInfoCallbackTy GenMapInfoCB, <a href="/docs/api/namespaces/llvm/omp/#a4c503140c7f851151906d85b515330e9">omp::RuntimeFunction</a> &#42;MapperFunc = nullptr, <a href="/docs/api/classes/llvm/function-ref">function&#95;ref</a>&lt;<a href="#af24d1c61cec57095ced3b08a6dd99ee8">InsertPointOrErrorTy(InsertPointTy CodeGenIP,
                                        BodyGenTy BodyGenType)</a>&gt; BodyGenCB = nullptr, <a href="/docs/api/classes/llvm/function-ref">function&#95;ref&lt;void(unsigned int, Value &#42;)&gt;</a> DeviceAddrCB = nullptr, <a href="/docs/api/classes/llvm/function-ref">function&#95;ref&lt;Value &#42;(unsigned int)&gt;</a> CustomMapperCB = nullptr, <a href="/docs/api/classes/llvm/value">Value</a> &#42;SrcLocInfo = nullptr);
</ParametersListItem>
</ParametersList>
using TargetBodyGenCallbackTy = <a href="/docs/api/classes/llvm/function-ref">function&#95;ref</a>&lt;<a href="#af24d1c61cec57095ced3b08a6dd99ee8">InsertPointOrErrorTy(
      InsertPointTy AllocaIP, InsertPointTy CodeGenIP)</a>&gt;;

using TargetGenArgAccessorsCallbackTy = <a href="/docs/api/classes/llvm/function-ref">function&#95;ref</a>&lt;<a href="#af24d1c61cec57095ced3b08a6dd99ee8">InsertPointOrErrorTy(
      Argument &amp;Arg, Value &#42;Input, Value &#42;&amp;RetVal, InsertPointTy AllocaIP,
      InsertPointTy CodeGenIP)</a>&gt;;

/ Generator for &#39;<a href="/docs/api/namespaces/llvm/omp">omp</a> target&#39; / /
<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">where the target data construct was encountered. /</ParametersListItem>
<ParametersListItem name="IsOffloadEntry">whether it is an offload entry. /</ParametersListItem>
<ParametersListItem name="CodeGenIP">The insertion point where the call to the outlined / function should be emitted. /</ParametersListItem>
<ParametersListItem name="EntryInfo">The entry information about the function. /</ParametersListItem>
<ParametersListItem name="DefaultAttrs">Structure containing the default attributes, including / numbers of threads and teams to launch the kernel with. /</ParametersListItem>
<ParametersListItem name="RuntimeAttrs">Structure containing the runtime numbers of threads / and teams to launch the kernel with. /</ParametersListItem>
<ParametersListItem name="IfCond">value of the <code>if</code> clause. /</ParametersListItem>
<ParametersListItem name="Inputs">The input values to the region that will be passed. / as arguments to the outlined function. /</ParametersListItem>
<ParametersListItem name="BodyGenCB">Callback that will generate the region code. /</ParametersListItem>
<ParametersListItem name="ArgAccessorFuncCB">Callback that will generate accessors / instructions for passed in target arguments where neccessary /</ParametersListItem>
<ParametersListItem name="Dependencies">A vector of <a href="/docs/api/structs/llvm/openmpirbuilder/dependdata">DependData</a> objects that carry / dependency information as passed in the depend clause /</ParametersListItem>
<ParametersListItem name="HasNowait">Whether the target construct has a <code>nowait</code> clause or / not. <a href="#af24d1c61cec57095ced3b08a6dd99ee8">InsertPointOrErrorTy</a> createTarget( const <a href="/docs/api/structs/llvm/openmpirbuilder/locationdescription">LocationDescription</a> &amp;<a href="/docs/api/namespaces/llvm/loc">Loc</a>, bool IsOffloadEntry, <a href="#aafc1886793b898052f87edd7e9fdbaa3">OpenMPIRBuilder::InsertPointTy</a> AllocaIP, <a href="#aafc1886793b898052f87edd7e9fdbaa3">OpenMPIRBuilder::InsertPointTy</a> CodeGenIP, <a href="/docs/api/structs/llvm/targetregionentryinfo">TargetRegionEntryInfo</a> &amp;EntryInfo, const TargetKernelDefaultAttrs &amp;DefaultAttrs, const TargetKernelRuntimeAttrs &amp;RuntimeAttrs, <a href="/docs/api/classes/llvm/value">Value</a> &#42;IfCond, <a href="/docs/api/classes/llvm/smallvectorimpl">SmallVectorImpl&lt;Value &#42;&gt;</a> &amp;Inputs, GenMapInfoCallbackTy GenMapInfoCB, TargetBodyGenCallbackTy BodyGenCB, TargetGenArgAccessorsCallbackTy ArgAccessorFuncCB, <a href="/docs/api/classes/llvm/smallvector">SmallVector&lt;DependData&gt;</a> Dependencies = &#123;&#125;, bool HasNowait = false);</ParametersListItem>
</ParametersList>
/ Returns &#95;&#95;kmpc&#95;for&#95;static&#95;init&#95;&#42; runtime function for the specified / size <em>IVSize</em> and sign <em>IVSigned</em>. Will create a distribute call / &#95;&#95;kmpc&#95;distribute&#95;static&#95;init&#42; if <em>IsGPUDistribute</em> is set. <a href="/docs/api/classes/llvm/functioncallee">FunctionCallee</a> createForStaticInitFunction(unsigned IVSize, bool IVSigned,
                                             bool IsGPUDistribute);

/ Returns &#95;&#95;kmpc&#95;dispatch&#95;init&#95;&#42; runtime function for the specified / size <em>IVSize</em> and sign <em>IVSigned</em>. <a href="/docs/api/classes/llvm/functioncallee">FunctionCallee</a> createDispatchInitFunction(unsigned IVSize, bool IVSigned);

/ Returns &#95;&#95;kmpc&#95;dispatch&#95;next&#95;&#42; runtime function for the specified / size <em>IVSize</em> and sign <em>IVSigned</em>. <a href="/docs/api/classes/llvm/functioncallee">FunctionCallee</a> createDispatchNextFunction(unsigned IVSize, bool IVSigned);

/ Returns &#95;&#95;kmpc&#95;dispatch&#95;fini&#95;&#42; runtime function for the specified / size <em>IVSize</em> and sign <em>IVSigned</em>. <a href="/docs/api/classes/llvm/functioncallee">FunctionCallee</a> createDispatchFiniFunction(unsigned IVSize, bool IVSigned);

/ Returns &#95;&#95;kmpc&#95;dispatch&#95;deinit runtime function. <a href="/docs/api/classes/llvm/functioncallee">FunctionCallee</a> createDispatchDeinitFunction();

/ Declarations for LLVM-IR types (simple, array, function and structure) are / generated below. Their names are defined and used in OpenMPKinds.def. Here / we provide the declarations, the initializeTypes function will provide the / values. / /&#123; #define <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#afd21bf6bbf67e4d7213a29ade471a8ee">OMP&#95;TYPE(VarName, InitValue)</a> 

 #define <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#aafa57f1c2700b16129c83badeb165f9c">OMP&#95;ARRAY&#95;TYPE(VarName, ElemTy, ArraySize)</a> \\ \\

#define <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#ad08bb874382ad7ded92c133a57714c49">OMP&#95;FUNCTION&#95;TYPE(VarName, IsVarArg, ReturnType, ...)</a> \\ \\

#define <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#ae4b3b7ecfcc7dcb96f3d5d57cea7a022">OMP&#95;STRUCT&#95;TYPE(VarName, StrName, ...)</a> \\ \\

/&#125;

private: / Create all simple and struct types exposed by the runtime and remember / the llvm::PointerTypes of them for easy access later. void initializeTypes(Module &amp;M);

/ Common interface for generating entry calls for OMP Directives. / if the directive has a region/body, It will set the insertion / point to the body / /
<ParametersList title="Parameters">
<ParametersListItem name="OMPD"><a href="/docs/api/classes/llvm/directive">Directive</a> to generate entry blocks for /</ParametersListItem>
<ParametersListItem name="EntryCall">Call to the entry OMP Runtime <a href="/docs/api/classes/llvm/function">Function</a> /</ParametersListItem>
<ParametersListItem name="ExitBB">block where the region ends. /</ParametersListItem>
<ParametersListItem name="Conditional">indicate if the entry call result will be used / to evaluate a conditional of whether a thread will execute / body code or not. / /</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
The insertion position in exit block <a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> emitCommonDirectiveEntry(omp::Directive OMPD, <a href="/docs/api/classes/llvm/value">Value</a> &#42;EntryCall, <a href="/docs/api/classes/llvm/basicblock">BasicBlock</a> &#42;ExitBB, bool Conditional = false);
</SectionUser>

/ Common interface to finalize the region / /
<ParametersList title="Parameters">
<ParametersListItem name="OMPD"><a href="/docs/api/classes/llvm/directive">Directive</a> to generate exiting code for /</ParametersListItem>
<ParametersListItem name="FinIP">Insertion point for emitting Finalization code and exit call /</ParametersListItem>
<ParametersListItem name="ExitCall">Call to the ending OMP Runtime <a href="/docs/api/classes/llvm/function">Function</a> /</ParametersListItem>
<ParametersListItem name="HasFinalize">indicate if the directive will require finalization / and has a finalization callback in the stack that / should be called. / /</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
The insertion position in exit block <a href="#af24d1c61cec57095ced3b08a6dd99ee8">InsertPointOrErrorTy</a> emitCommonDirectiveExit(omp::Directive OMPD, <a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> FinIP, <a href="/docs/api/classes/llvm/instruction">Instruction</a> &#42;ExitCall, bool HasFinalize = true);
</SectionUser>

/ Common Interface to generate OMP inlined regions / /
<ParametersList title="Parameters">
<ParametersListItem name="OMPD"><a href="/docs/api/classes/llvm/directive">Directive</a> to generate inlined region for /</ParametersListItem>
<ParametersListItem name="EntryCall">Call to the entry OMP Runtime <a href="/docs/api/classes/llvm/function">Function</a> /</ParametersListItem>
<ParametersListItem name="ExitCall">Call to the ending OMP Runtime <a href="/docs/api/classes/llvm/function">Function</a> /</ParametersListItem>
<ParametersListItem name="BodyGenCB">Body code generation callback. /</ParametersListItem>
<ParametersListItem name="FiniCB">Finalization Callback. Will be called when finalizing region /</ParametersListItem>
<ParametersListItem name="Conditional">indicate if the entry call result will be used / to evaluate a conditional of whether a thread will execute / body code or not. /</ParametersListItem>
<ParametersListItem name="HasFinalize">indicate if the directive will require finalization / and has a finalization callback in the stack that / should be called. /</ParametersListItem>
<ParametersListItem name="IsCancellable">if HasFinalize is set to true, indicate if the / the directive should be cancellable. /</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
The insertion point after the region <a href="#af24d1c61cec57095ced3b08a6dd99ee8">InsertPointOrErrorTy</a> EmitOMPInlinedRegion(omp::Directive OMPD, <a href="/docs/api/classes/llvm/instruction">Instruction</a> &#42;EntryCall, <a href="/docs/api/classes/llvm/instruction">Instruction</a> &#42;ExitCall, <a href="#a49e35e3ee470add16efcde1ab5d5556b">BodyGenCallbackTy</a> BodyGenCB, <a href="#a0c571620ff53fdb78e7404f5261dbd23">FinalizeCallbackTy</a> FiniCB, bool Conditional = false, bool HasFinalize = true, bool IsCancellable = false);
</SectionUser>

/ Get the platform-specific name separator. /
<ParametersList title="Parameters">
<ParametersListItem name="Parts">different parts of the final name that needs separation /</ParametersListItem>
<ParametersListItem name="FirstSeparator">First separator used between the initial two / parts of the name. /</ParametersListItem>
<ParametersListItem name="Separator">
separator used between all of the rest consecutive / parts of the name static std::string getNameWithSeparators(ArrayRef&lt;StringRef&gt; Parts,
                                           StringRef FirstSeparator,
                                           StringRef Separator);
</ParametersListItem>
</ParametersList>
/ Returns corresponding lock object for the specified critical region / name. If the lock object does not exist it is created, otherwise the / reference to the existing copy is returned. /
<ParametersList title="Parameters">
<ParametersListItem name="CriticalName">Name of the critical region. / <a href="/docs/api/classes/llvm/value">Value</a> &#42;getOMPCriticalRegionLock(<a href="/docs/api/classes/llvm/stringref">StringRef</a> CriticalName);</ParametersListItem>
</ParametersList>
/ Callback type for Atomic <a href="/docs/api/classes/llvm/expression">Expression</a> update / ex: / 
<ProgramListing extension="cpp">

<CodeLine><span class="doxyHighlightComment">/// unsigned x = 0;</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">/// #pragma omp atomic update</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">/// x = Expr(x&#95;old);  //Expr() is any legal operation</span></CodeLine>
<CodeLine><span class="doxyHighlightComment">/// </span></CodeLine>

</ProgramListing>
 / /
<ParametersList title="Parameters">
<ParametersListItem name="XOld">the value of the atomic memory address to use for update /</ParametersListItem>
<ParametersListItem name="IRB">reference to the <a href="/docs/api/classes/llvm/irbuilder">IRBuilder</a> to use / /</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
<a href="/docs/api/classes/llvm/value">Value</a> to update X to. using AtomicUpdateCallbackTy = const <a href="/docs/api/classes/llvm/function-ref">function&#95;ref</a>&lt;Expected&lt;Value &#42;&gt;(Value &#42;XOld, IRBuilder&lt;&gt; &amp;IRB)&gt;;
</SectionUser>

private: enum AtomicKind &#123; Read, Write, Update, Capture, Compare &#125;;

/ Determine whether to emit flush or not / /
<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The insert and source location description. /</ParametersListItem>
<ParametersListItem name="AO">The required atomic ordering /</ParametersListItem>
<ParametersListItem name="AK">The OpenMP atomic operation kind used. / /</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
wether a flush was emitted or not bool checkAndEmitFlushAfterAtomic(const LocationDescription &amp;Loc,
                                    AtomicOrdering AO, AtomicKind AK);
</SectionUser>

/ Emit atomic update for constructs: X = X BinOp Expr ,or X = Expr BinOp X / For complex Operations: X = UpdateOp(X) =&gt; CmpExch X, old&#95;X, UpdateOp(X) / Only Scalar data types. / /
<ParametersList title="Parameters">
<ParametersListItem name="AllocaIP">The insertion point to be used for alloca / instructions. /</ParametersListItem>
<ParametersListItem name="X">The target atomic pointer to be updated /</ParametersListItem>
<ParametersListItem name="XElemTy">The element type of the atomic pointer. /</ParametersListItem>
<ParametersListItem name="Expr">The value to update X with. /</ParametersListItem>
<ParametersListItem name="AO">Atomic ordering of the generated atomic / instructions. /</ParametersListItem>
<ParametersListItem name="RMWOp">The binary operation used for update. If / operation is not supported by atomicRMW, / or belong to &#123;FADD, FSUB, BAD&#95;BINOP&#125;. / Then a <code>cmpExch</code> based atomic will be generated. /</ParametersListItem>
<ParametersListItem name="UpdateOp">Code generator for complex expressions that cannot be / expressed through atomicrmw instruction. /</ParametersListItem>
<ParametersListItem name="VolatileX">true if <em>X</em> volatile? /</ParametersListItem>
<ParametersListItem name="IsXBinopExpr">true if <em>X</em> is Left H.S. in Right H.S. part of the / update expression, false otherwise. / (e.g. true for X = X BinOp Expr) / /</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
A pair of the old value of X before the update, and the value / used for the update. <a href="/docs/api/classes/llvm/expected">Expected&lt;std::pair&lt;Value &#42;, Value &#42;&gt;&gt;</a> emitAtomicUpdate(InsertPointTy AllocaIP, Value &#42;X, Type &#42;XElemTy, Value &#42;Expr,
                   AtomicOrdering AO, AtomicRMWInst::BinOp RMWOp,
                   AtomicUpdateCallbackTy &amp;UpdateOp, bool VolatileX,
                   bool IsXBinopExpr);
</SectionUser>

/ Emit the binary op. described by <code>RMWOp</code>, using <code>Src1</code> and <code>Src2</code> . / / \\Return The instruction <a href="/docs/api/classes/llvm/value">Value</a> &#42;emitRMWOpAsInstruction(<a href="/docs/api/classes/llvm/value">Value</a> &#42;Src1, <a href="/docs/api/classes/llvm/value">Value</a> &#42;Src2, <a href="/docs/api/classes/llvm/atomicrmwinst/#a461cfbbb5c7a57ab73210498923cf615">AtomicRMWInst::BinOp</a> RMWOp);

public: / a struct to pack relevant information while generating atomic Ops struct AtomicOpValue &#123; <a href="/docs/api/classes/llvm/value">Value</a> &#42;Var = nullptr; <a href="/docs/api/classes/llvm/type">Type</a> &#42;ElemTy = nullptr; bool IsSigned = false; bool IsVolatile = false; &#125;;

/ Emit atomic Read for : V = X — Only Scalar data types. / /
<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The insert and source location description. /</ParametersListItem>
<ParametersListItem name="X">The target pointer to be atomically read /</ParametersListItem>
<ParametersListItem name="V"><a href="/docs/api/classes/llvm/sys/memory">Memory</a> address where to store atomically read / value /</ParametersListItem>
<ParametersListItem name="AO">Atomic ordering of the generated atomic / instructions. / /</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
Insertion point after generated atomic read IR. <a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> createAtomicRead(const LocationDescription &amp;Loc,
                                 AtomicOpValue &amp;X, AtomicOpValue &amp;V,
                                 AtomicOrdering AO);
</SectionUser>

/ Emit atomic write for : X = Expr — Only Scalar data types. / /
<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The insert and source location description. /</ParametersListItem>
<ParametersListItem name="X">The target pointer to be atomically written to /</ParametersListItem>
<ParametersListItem name="Expr">The value to store. /</ParametersListItem>
<ParametersListItem name="AO">Atomic ordering of the generated atomic / instructions. / /</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
Insertion point after generated atomic Write IR. <a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> createAtomicWrite(const LocationDescription &amp;Loc,
                                  AtomicOpValue &amp;X, Value &#42;Expr,
                                  AtomicOrdering AO);
</SectionUser>

/ Emit atomic update for constructs: X = X BinOp Expr ,or X = Expr BinOp X / For complex Operations: X = UpdateOp(X) =&gt; CmpExch X, old&#95;X, UpdateOp(X) / Only Scalar data types. / /
<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The insert and source location description. /</ParametersListItem>
<ParametersListItem name="AllocaIP">The insertion point to be used for alloca instructions. /</ParametersListItem>
<ParametersListItem name="X">The target atomic pointer to be updated /</ParametersListItem>
<ParametersListItem name="Expr">The value to update X with. /</ParametersListItem>
<ParametersListItem name="AO">Atomic ordering of the generated atomic instructions. /</ParametersListItem>
<ParametersListItem name="RMWOp">The binary operation used for update. If operation / is not supported by atomicRMW, or belong to / &#123;FADD, FSUB, BAD&#95;BINOP&#125;. Then a <code>cmpExch</code> based atomic will be generated.</ParametersListItem>
<ParametersListItem name="UpdateOp">Code generator for complex expressions that cannot be expressed through atomicrmw instruction.</ParametersListItem>
<ParametersListItem name="IsXBinopExpr">true if <em>X</em> is Left H.S. in Right H.S. part of the update expression, false otherwise. (e.g. true for X = X BinOp Expr)</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
Insertion point after generated atomic update IR.
</SectionUser>

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l03264">3264</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>, definition at line <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp/#l08574">8574</a> of file <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp">OMPIRBuilder.cpp</a>.
</MemberDefinition>

### createBarrier() {#abca6530c9099bd1b1c3e0a5c32381f07}

<MemberDefinition
  prototype={<>OpenMPIRBuilder::InsertPointOrErrorTy OpenMPIRBuilder::createBarrier (<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/structs/llvm/openmpirbuilder/locationdescription">LocationDescription</a> &amp; Loc, omp::Directive Kind, bool ForceSimpleCall=false, bool CheckCancelFlag=<a href="/docs/api/files/lib/lib/analysis/basicaliasanalysis-cpp/#af6d5cafbdfc5313e65d990120021a3ec">true</a>)</>}>
Emitter methods for OpenMP directives.

&#123; Generator for &#39;<a href="/docs/api/namespaces/llvm/omp">omp</a> barrier&#39;


<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The location where the barrier directive was encountered.</ParametersListItem>
<ParametersListItem name="Kind">The kind of directive that caused the barrier.</ParametersListItem>
<ParametersListItem name="ForceSimpleCall">Flag to force a simple (=non-cancellation) barrier.</ParametersListItem>
<ParametersListItem name="CheckCancelFlag">Flag to indicate a cancel barrier return value should be checked and acted upon.</ParametersListItem>
<ParametersListItem name="ThreadID">Optional parameter to pass in any existing ThreadID value.</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
The insertion point after the barrier.
</SectionUser>

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l00669">669</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>, definition at line <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp/#l01007">1007</a> of file <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp">OMPIRBuilder.cpp</a>.
</MemberDefinition>

### createCancel() {#a04285415a321e48322c08f3b9185540e}

<MemberDefinition
  prototype={<>OpenMPIRBuilder::InsertPointOrErrorTy OpenMPIRBuilder::createCancel (<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/structs/llvm/openmpirbuilder/locationdescription">LocationDescription</a> &amp; Loc, <a href="/docs/api/classes/llvm/value">Value</a> &#42; IfCondition, omp::Directive CanceledDirective)</>}>
Generator for &#39;<a href="/docs/api/namespaces/llvm/omp">omp</a> cancel&#39;.

<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The location where the directive was encountered.</ParametersListItem>
<ParametersListItem name="IfCondition">The evaluated &#39;if&#39; clause expression, if any.</ParametersListItem>
<ParametersListItem name="CanceledDirective">The kind of directive that is cancled.</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
The insertion point after the barrier.
</SectionUser>

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l00681">681</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>, definition at line <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp/#l01060">1060</a> of file <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp">OMPIRBuilder.cpp</a>.
</MemberDefinition>

### createCanonicalLoop() {#ae0287686a5ffe03bc264972c862726ea}

<MemberDefinition
  prototype={<>Expected&lt; CanonicalLoopInfo &#42; &gt; OpenMPIRBuilder::createCanonicalLoop (<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/structs/llvm/openmpirbuilder/locationdescription">LocationDescription</a> &amp; Loc, <a href="#a296d2e28bddf1051d614f48b61005899">LoopBodyGenCallbackTy</a> BodyGenCB, <a href="/docs/api/classes/llvm/value">Value</a> &#42; TripCount, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/classes/llvm/twine">Twine</a> &amp; Name=&quot;loop&quot;)</>}>
Generator for the control flow structure of an OpenMP canonical loop.

This generator operates on the logical iteration space of the loop, i.e. the caller only has to provide a loop trip count of the loop as defined by base language semantics. The trip count is interpreted as an unsigned integer. The induction variable passed to <code>BodyGenCB</code> will be of the same type and run from 0 to <code>TripCount</code> - 1. It is up to the callback to convert the logical iteration variable to the loop counter variable in the loop body.


<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The insert and source location description. The insert location can be between two instructions or the end of a degenerate block (e.g. a BB under construction).</ParametersListItem>
<ParametersListItem name="BodyGenCB">Callback that will generate the loop body code.</ParametersListItem>
<ParametersListItem name="TripCount">Number of iterations the loop body is executed.</ParametersListItem>
<ParametersListItem name="Name">Base name used to derive BB and instruction names.</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
An object representing the created control flow structure which can be used for loop-associated directives.
</SectionUser>

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l00725">725</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>, definition at line <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp/#l04025">4025</a> of file <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp">OMPIRBuilder.cpp</a>.
</MemberDefinition>

### createCanonicalLoop() {#ac669acbd0f638c6ef32977575362052e}

<MemberDefinition
  prototype={<>Expected&lt; CanonicalLoopInfo &#42; &gt; OpenMPIRBuilder::createCanonicalLoop (<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/structs/llvm/openmpirbuilder/locationdescription">LocationDescription</a> &amp; Loc, <a href="#a296d2e28bddf1051d614f48b61005899">LoopBodyGenCallbackTy</a> BodyGenCB, <a href="/docs/api/classes/llvm/value">Value</a> &#42; Start, <a href="/docs/api/classes/llvm/value">Value</a> &#42; Stop, <a href="/docs/api/classes/llvm/value">Value</a> &#42; Step, bool IsSigned, bool InclusiveStop, <a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> ComputeIP=&#123;&#125;, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/classes/llvm/twine">Twine</a> &amp; Name=&quot;loop&quot;)</>}>
Generator for the control flow structure of an OpenMP canonical loop.

Instead of a logical iteration space, this allows specifying user-defined loop counter values using increment, upper- and lower bounds. To disambiguate the terminology when counting downwards, instead of lower bounds we use <code>Start</code> for the loop counter value in the first body iteration.

Consider the following limitations:


<ul>
<li>A loop counter space over all integer values of its bit-width cannot be represented. E.g using uint8&#95;t, its loop trip count of 256 cannot be stored into an 8 bit integer):
DO I = 0, 255, 1</li>
<li>Unsigned wrapping is only supported when wrapping only &quot;once&quot;; E.g. effectively counting downwards:
for (uint8&#95;t i = 100u; i &gt; 0; i += 127u)</li>
</ul>


TODO: May need to add additional parameters to represent:


<ul>
<li>Allow representing downcounting with unsigned integers.</li>
<li>Sign of the step and the comparison operator might disagree:
for (int i = 0; i &lt; 42; i -= 1u) 
<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The insert and source location description.</ParametersListItem>
<ParametersListItem name="BodyGenCB">Callback that will generate the loop body code.</ParametersListItem>
<ParametersListItem name="Start"><a href="/docs/api/classes/llvm/value">Value</a> of the loop counter for the first iterations.</ParametersListItem>
<ParametersListItem name="Stop"><a href="/docs/api/classes/llvm/loop">Loop</a> counter values past this will stop the loop.</ParametersListItem>
<ParametersListItem name="Step"><a href="/docs/api/classes/llvm/loop">Loop</a> counter increment after each iteration; negative means counting down.</ParametersListItem>
<ParametersListItem name="IsSigned">Whether Start, Stop and Step are signed integers.</ParametersListItem>
<ParametersListItem name="InclusiveStop">Whether <code>Stop</code> itself is a valid value for the loop counter.</ParametersListItem>
<ParametersListItem name="ComputeIP">Insertion point for instructions computing the trip count. Can be used to ensure the trip count is available at the outermost loop of a loop nest. If not set, defaults to the preheader of the generated loop.</ParametersListItem>
<ParametersListItem name="Name">Base name used to derive BB and instruction names.</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
An object representing the created control flow structure which can be used for loop-associated directives.
</SectionUser></li>
</ul>

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l00777">777</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>, definition at line <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp/#l04055">4055</a> of file <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp">OMPIRBuilder.cpp</a>.
</MemberDefinition>

### createFlush() {#afc2cc623eda981e1b3fbb61a44e80ef8}

<MemberDefinition
  prototype={<>void OpenMPIRBuilder::createFlush (<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/structs/llvm/openmpirbuilder/locationdescription">LocationDescription</a> &amp; Loc)</>}>
Generator for &#39;<a href="/docs/api/namespaces/llvm/omp">omp</a> flush&#39;.

<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The location where the flush directive was encountered</ParametersListItem>
</ParametersList>

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l01227">1227</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>, definition at line <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp/#l01766">1766</a> of file <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp">OMPIRBuilder.cpp</a>.
</MemberDefinition>

### createLoopSkeleton() {#a445fa52d77040bccb16bfea111234a2e}

<MemberDefinition
  prototype={<>CanonicalLoopInfo &#42; OpenMPIRBuilder::createLoopSkeleton (<a href="/docs/api/classes/llvm/debugloc">DebugLoc</a> DL, <a href="/docs/api/classes/llvm/value">Value</a> &#42; TripCount, <a href="/docs/api/classes/llvm/function">Function</a> &#42; F, <a href="/docs/api/classes/llvm/basicblock">BasicBlock</a> &#42; PreInsertBefore, <a href="/docs/api/classes/llvm/basicblock">BasicBlock</a> &#42; PostInsertBefore, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/classes/llvm/twine">Twine</a> &amp; Name=&#123;&#125;)</>}>
Create the control flow structure of a canonical OpenMP loop.

The emitted loop will be disconnected, i.e. no edge to the loop&#39;s preheader and no terminator in the AfterBB. The <a href="/docs/api/classes/llvm/openmpirbuilder">OpenMPIRBuilder</a>&#39;s <a href="/docs/api/classes/llvm/irbuilder">IRBuilder</a> location is not preserved.


<ParametersList title="Parameters">
<ParametersListItem name="DL"><a href="/docs/api/classes/llvm/debugloc">DebugLoc</a> used for the instructions in the skeleton.</ParametersListItem>
<ParametersListItem name="TripCount"><a href="/docs/api/classes/llvm/value">Value</a> to be used for the trip count.</ParametersListItem>
<ParametersListItem name="F"><a href="/docs/api/classes/llvm/function">Function</a> in which to insert the BasicBlocks.</ParametersListItem>
<ParametersListItem name="PreInsertBefore">Where to insert BBs that execute before the body, typically the body itself.</ParametersListItem>
<ParametersListItem name="PostInsertBefore">Where to insert BBs that execute after the body.</ParametersListItem>
<ParametersListItem name="Name">Base name used to derive BB and instruction names.</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
The <a href="/docs/api/classes/llvm/canonicalloopinfo">CanonicalLoopInfo</a> that represents the emitted loop.
</SectionUser>

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l03379">3379</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>, definition at line <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp/#l03958">3958</a> of file <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp">OMPIRBuilder.cpp</a>.
</MemberDefinition>

### createParallel() {#a4f81b9940e1869e146636dc533455929}

<MemberDefinition
  prototype={<>OpenMPIRBuilder::InsertPointOrErrorTy OpenMPIRBuilder::createParallel (<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/structs/llvm/openmpirbuilder/locationdescription">LocationDescription</a> &amp; Loc, <a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> AllocaIP, <a href="#a49e35e3ee470add16efcde1ab5d5556b">BodyGenCallbackTy</a> BodyGenCB, <a href="#a71b5ba020f68829f5a1fd99f48b63d42">PrivatizeCallbackTy</a> PrivCB, <a href="#a0c571620ff53fdb78e7404f5261dbd23">FinalizeCallbackTy</a> FiniCB, <a href="/docs/api/classes/llvm/value">Value</a> &#42; IfCondition, <a href="/docs/api/classes/llvm/value">Value</a> &#42; NumThreads, omp::ProcBindKind ProcBind, bool IsCancellable)</>}>
Generator for &#39;<a href="/docs/api/namespaces/llvm/omp">omp</a> parallel&#39;.

<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The insert and source location description.</ParametersListItem>
<ParametersListItem name="AllocaIP">The insertion points to be used for alloca instructions.</ParametersListItem>
<ParametersListItem name="BodyGenCB">Callback that will generate the region code.</ParametersListItem>
<ParametersListItem name="PrivCB">Callback to copy a given variable (think copy constructor).</ParametersListItem>
<ParametersListItem name="FiniCB">Callback to finalize variable copies.</ParametersListItem>
<ParametersListItem name="IfCondition">The evaluated &#39;if&#39; clause expression, if any.</ParametersListItem>
<ParametersListItem name="NumThreads">The evaluated &#39;num&#95;threads&#39; clause expression, if any.</ParametersListItem>
<ParametersListItem name="ProcBind">The value of the &#39;proc&#95;bind&#39; clause (see ProcBindKind).</ParametersListItem>
<ParametersListItem name="IsCancellable">Flag to indicate a cancellable parallel region.</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
The insertion position <em>after</em> the parallel.
</SectionUser>

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l00699">699</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>, definition at line <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp/#l01427">1427</a> of file <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp">OMPIRBuilder.cpp</a>.
</MemberDefinition>

### createPlatformSpecificName() {#a488c861f8a68e5f78ceca8b57acd8be5}

<MemberDefinition
  prototype={<>std::string OpenMPIRBuilder::createPlatformSpecificName (<a href="/docs/api/classes/llvm/arrayref">ArrayRef</a>&lt; <a href="/docs/api/classes/llvm/stringref">StringRef</a> &gt; Parts) const</>}>
Get the create a name using the platform specific separators.

<ParametersList title="Parameters">
<ParametersListItem name="Parts">parts of the final name that needs separation The created name has a first separator between the first and second part and a second separator between all other parts. E.g. with FirstSeparator &quot;$&quot; and Separator &quot;.&quot; and parts: &quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;, &quot;p4&quot; The resulting name is &quot;p1$p2.p3.p4&quot; The separators are retrieved from the <a href="/docs/api/classes/llvm/openmpirbuilderconfig">OpenMPIRBuilderConfig</a>.</ParametersListItem>
</ParametersList>

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l00533">533</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>, definition at line <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp/#l07636">7636</a> of file <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp">OMPIRBuilder.cpp</a>.
</MemberDefinition>

### createTaskwait() {#a419ffad9e4d59275e299ce1ad3c73cd4}

<MemberDefinition
  prototype={<>void OpenMPIRBuilder::createTaskwait (<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/structs/llvm/openmpirbuilder/locationdescription">LocationDescription</a> &amp; Loc)</>}>
Generator for &#39;<a href="/docs/api/namespaces/llvm/omp">omp</a> taskwait&#39;.

<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The location where the taskwait directive was encountered.</ParametersListItem>
</ParametersList>

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l01232">1232</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>, definition at line <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp/#l01785">1785</a> of file <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp">OMPIRBuilder.cpp</a>.
</MemberDefinition>

### createTaskyield() {#a0b0ed7f600549e4239bf10b5b85de66c}

<MemberDefinition
  prototype={<>void OpenMPIRBuilder::createTaskyield (<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/structs/llvm/openmpirbuilder/locationdescription">LocationDescription</a> &amp; Loc)</>}>
Generator for &#39;<a href="/docs/api/namespaces/llvm/omp">omp</a> taskyield&#39;.

<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/namespaces/llvm/loc&quot;>Loc</a>">The location where the taskyield directive was encountered.</ParametersListItem>
</ParametersList>

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l01237">1237</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>, definition at line <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp/#l01803">1803</a> of file <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp">OMPIRBuilder.cpp</a>.
</MemberDefinition>

### finalize() {#a784adc2347b72f745ff1239aef3a3c26}

<MemberDefinition
  prototype={<>void OpenMPIRBuilder::finalize (<a href="/docs/api/classes/llvm/function">Function</a> &#42; Fn=nullptr)</>}>
Finalize the underlying module, e.g., by outlining regions.

<ParametersList title="Parameters">
<ParametersListItem name="Fn">The function to be finalized. If not used, all functions are finalized.</ParametersListItem>
</ParametersList>

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l00514">514</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>, definition at line <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp/#l00701">701</a> of file <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp">OMPIRBuilder.cpp</a>.
</MemberDefinition>

### getAddrOfDeclareTargetVar() {#afdc1b8675a946ce055c64607ba75af3a}

<MemberDefinition
  prototype={<>Constant &#42; OpenMPIRBuilder::getAddrOfDeclareTargetVar (<a href="/docs/api/classes/llvm/offloadentriesinfomanager/#ab9575c71365de4083a7be6ef6572d534">OffloadEntriesInfoManager::OMPTargetGlobalVarEntryKind</a> CaptureClause, <a href="/docs/api/classes/llvm/offloadentriesinfomanager/#a2dc9d099b77ee3b8db3b00ad9273823d">OffloadEntriesInfoManager::OMPTargetDeviceClauseKind</a> DeviceClause, bool IsDeclaration, bool IsExternallyVisible, <a href="/docs/api/structs/llvm/targetregionentryinfo">TargetRegionEntryInfo</a> EntryInfo, <a href="/docs/api/classes/llvm/stringref">StringRef</a> MangledName, std::vector&lt; <a href="/docs/api/classes/llvm/globalvariable">GlobalVariable</a> &#42; &gt; &amp; GeneratedRefs, bool OpenMPSIMD, std::vector&lt; <a href="/docs/api/classes/llvm/triple">Triple</a> &gt; TargetTriple, <a href="/docs/api/classes/llvm/type">Type</a> &#42; LlvmPtrTy, std::function&lt; <a href="/docs/api/classes/llvm/constant">Constant</a> &#42;()&gt; GlobalInitializer, std::function&lt; <a href="/docs/api/classes/llvm/globalvalue/#aedfa75f0c85c4aa85b257f066fbea57c">GlobalValue::LinkageTypes</a>()&gt; VariableLinkage)</>}>
Retrieve (or create if non-existent) the address of a declare target variable, used in conjunction with registerTargetGlobalVariable to create declare target global variables.

<ParametersList title="Parameters">
<ParametersListItem name="CaptureClause">- enumerator corresponding to the OpenMP capture clause used in conjunction with the variable being registered (link, to, enter).</ParametersListItem>
<ParametersListItem name="DeviceClause">- enumerator corresponding to the OpenMP capture clause used in conjunction with the variable being registered (nohost, host, any)</ParametersListItem>
<ParametersListItem name="IsDeclaration">- boolean stating if the variable being registered is a declaration-only and not a definition</ParametersListItem>
<ParametersListItem name="IsExternallyVisible">- boolean stating if the variable is externally visible</ParametersListItem>
<ParametersListItem name="EntryInfo">- Unique entry information for the value generated using getTargetEntryUniqueInfo, used to name generated pointer references to the declare target variable</ParametersListItem>
<ParametersListItem name="MangledName">- the mangled name of the variable being registered</ParametersListItem>
<ParametersListItem name="GeneratedRefs">- references generated by invocations of registerTargetGlobalVariable invoked from getAddrOfDeclareTargetVar, these are required by Clang for book keeping.</ParametersListItem>
<ParametersListItem name="OpenMPSIMD">- if OpenMP SIMD mode is currently enabled</ParametersListItem>
<ParametersListItem name="TargetTriple">- The OpenMP device target triple we are compiling for</ParametersListItem>
<ParametersListItem name="LlvmPtrTy">- The type of the variable we are generating or retrieving an address for</ParametersListItem>
<ParametersListItem name="GlobalInitializer">- a lambda function which creates a constant used for initializing a pointer reference to the variable in certain cases. If a nullptr is passed, it will default to utilising the original variable to initialize the pointer reference.</ParametersListItem>
<ParametersListItem name="VariableLinkage">- a lambda function which returns the variables linkage type, if unspecified and a nullptr is given, it will instead utilise the linkage stored on the existing global variable in the LLVMModule.</ParametersListItem>
</ParametersList>

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l00887">887</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>, definition at line <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp/#l09475">9475</a> of file <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp">OMPIRBuilder.cpp</a>.
</MemberDefinition>

### getFlagMemberOffset() {#ac86b562509588cbc00fbdc441c615bd3}

<MemberDefinition
  prototype="unsigned OpenMPIRBuilder::getFlagMemberOffset ()">
Get the offset of the OMP&#95;MAP&#95;MEMBER&#95;OF field.

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l00943">943</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>, definition at line <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp/#l09439">9439</a> of file <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp">OMPIRBuilder.cpp</a>.
</MemberDefinition>

### getMemberOfFlag() {#a4f82182a8cc23f854efdbd453f685086}

<MemberDefinition
  prototype="omp::OpenMPOffloadMappingFlags OpenMPIRBuilder::getMemberOfFlag (unsigned Position)">
Get OMP&#95;MAP&#95;MEMBER&#95;OF flag with extra bits reserved based on the position given.

<ParametersList title="Parameters">
<ParametersListItem name="Position">- A value indicating the position of the parent of the member in the kernel argument structure, often retrieved by the parents position in the combined information vectors used to generate the structure itself. Multiple children (member&#39;s of) with the same parent will use the same returned member flag.</ParametersListItem>
</ParametersList>

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l00952">952</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>, definition at line <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp/#l09450">9450</a> of file <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp">OMPIRBuilder.cpp</a>.
</MemberDefinition>

### getOrCreateInternalVariable() {#aa5ef00e5a7487cc6c5bfed0f301fa1cc}

<MemberDefinition
  prototype={<>GlobalVariable &#42; OpenMPIRBuilder::getOrCreateInternalVariable (<a href="/docs/api/classes/llvm/type">Type</a> &#42; Ty, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/classes/llvm/stringref">StringRef</a> &amp; Name, unsigned AddressSpace=0)</>}>
Gets (if variable with the given name already exist) or creates internal global variable with the specified Name.

The created variable has linkage CommonLinkage by default and is initialized by null value. 
<ParametersList title="Parameters">
<ParametersListItem name="Ty"><a href="/docs/api/classes/llvm/type">Type</a> of the global variable. If it is exist already the type must be the same.</ParametersListItem>
<ParametersListItem name="Name">Name of the variable.</ParametersListItem>
</ParametersList>

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l03410">3410</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>, definition at line <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp/#l07642">7642</a> of file <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp">OMPIRBuilder.cpp</a>.
</MemberDefinition>

### initialize() {#a1af99f6f33b0db83a3e941fcb819fa29}

<MemberDefinition
  prototype="void OpenMPIRBuilder::initialize ()">
Initialize the internal state, this will put structures types and potentially other helpers into the underlying module.

Must be called before any other method and only once! This internal state includes types used in the <a href="/docs/api/classes/llvm/openmpirbuilder">OpenMPIRBuilder</a> generated from OMPKinds.def.

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l00507">507</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>, definition at line <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp/#l00676">676</a> of file <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp">OMPIRBuilder.cpp</a>.
</MemberDefinition>

### loadOffloadInfoMetadata() {#a2242b144e54fa6203dae5c5b27fff17c}

<MemberDefinition
  prototype={<>void OpenMPIRBuilder::loadOffloadInfoMetadata (<a href="/docs/api/classes/llvm/module">Module</a> &amp; M)</>}>
Loads all the offload entries information from the host IR metadata.

This function is only meant to be used with device code generation.


<ParametersList title="Parameters">
<ParametersListItem name="M"><a href="/docs/api/classes/llvm/module">Module</a> to load <a href="/docs/api/classes/llvm/metadata">Metadata</a> info from. <a href="/docs/api/classes/llvm/module">Module</a> passed maybe loaded from bitcode file, i.e, different from OpenMPIRBuilder::M module.</ParametersListItem>
</ParametersList>

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l03393">3393</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>, definition at line <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp/#l09612">9612</a> of file <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp">OMPIRBuilder.cpp</a>.
</MemberDefinition>

### loadOffloadInfoMetadata() {#ac6293b7ea84a4deac85481dd10dad437}

<MemberDefinition
  prototype={<>void OpenMPIRBuilder::loadOffloadInfoMetadata (<a href="/docs/api/classes/llvm/stringref">StringRef</a> HostFilePath)</>}>
Loads all the offload entries information from the host IR metadata read from the file passed in as the HostFilePath argument.

This function is only meant to be used with device code generation.


<ParametersList title="Parameters">
<ParametersListItem name="HostFilePath">The path to the host IR file, used to load in offload metadata for the device, allowing host and device to maintain the same metadata mapping.</ParametersListItem>
</ParametersList>

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l03402">3402</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>, definition at line <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp/#l09658">9658</a> of file <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp">OMPIRBuilder.cpp</a>.
</MemberDefinition>

### popFinalizationCB() {#af2e7210874149ecbd52c8ce44ca4f416}

<MemberDefinition
  prototype="void llvm::OpenMPIRBuilder::popFinalizationCB ()"
  labels = {["inline"]}>
Pop the last finalization callback from the finalization stack.

NOTE: Temporary solution until Clang CG is gone.

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l00568">568</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>.
</MemberDefinition>

### pushFinalizationCB() {#a977f2477d245a9d554642492fedd049a}

<MemberDefinition
  prototype={<>void llvm::OpenMPIRBuilder::pushFinalizationCB (<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/structs/llvm/openmpirbuilder/finalizationinfo">FinalizationInfo</a> &amp; FI)</>}
  labels = {["inline"]}>
Push a finalization callback on the finalization stack.

NOTE: Temporary solution until Clang CG is gone.

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l00561">561</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>.
</MemberDefinition>

### registerTargetGlobalVariable() {#ae327be8503a76bd4dccfff4713a38553}

<MemberDefinition
  prototype={<>void OpenMPIRBuilder::registerTargetGlobalVariable (<a href="/docs/api/classes/llvm/offloadentriesinfomanager/#ab9575c71365de4083a7be6ef6572d534">OffloadEntriesInfoManager::OMPTargetGlobalVarEntryKind</a> CaptureClause, <a href="/docs/api/classes/llvm/offloadentriesinfomanager/#a2dc9d099b77ee3b8db3b00ad9273823d">OffloadEntriesInfoManager::OMPTargetDeviceClauseKind</a> DeviceClause, bool IsDeclaration, bool IsExternallyVisible, <a href="/docs/api/structs/llvm/targetregionentryinfo">TargetRegionEntryInfo</a> EntryInfo, <a href="/docs/api/classes/llvm/stringref">StringRef</a> MangledName, std::vector&lt; <a href="/docs/api/classes/llvm/globalvariable">GlobalVariable</a> &#42; &gt; &amp; GeneratedRefs, bool OpenMPSIMD, std::vector&lt; <a href="/docs/api/classes/llvm/triple">Triple</a> &gt; TargetTriple, std::function&lt; <a href="/docs/api/classes/llvm/constant">Constant</a> &#42;()&gt; GlobalInitializer, std::function&lt; <a href="/docs/api/classes/llvm/globalvalue/#aedfa75f0c85c4aa85b257f066fbea57c">GlobalValue::LinkageTypes</a>()&gt; VariableLinkage, <a href="/docs/api/classes/llvm/type">Type</a> &#42; LlvmPtrTy, <a href="/docs/api/classes/llvm/constant">Constant</a> &#42; Addr)</>}>
Registers a target variable for device or host.

<ParametersList title="Parameters">
<ParametersListItem name="CaptureClause">- enumerator corresponding to the OpenMP capture clause used in conjunction with the variable being registered (link, to, enter).</ParametersListItem>
<ParametersListItem name="DeviceClause">- enumerator corresponding to the OpenMP capture clause used in conjunction with the variable being registered (nohost, host, any)</ParametersListItem>
<ParametersListItem name="IsDeclaration">- boolean stating if the variable being registered is a declaration-only and not a definition</ParametersListItem>
<ParametersListItem name="IsExternallyVisible">- boolean stating if the variable is externally visible</ParametersListItem>
<ParametersListItem name="EntryInfo">- Unique entry information for the value generated using getTargetEntryUniqueInfo, used to name generated pointer references to the declare target variable</ParametersListItem>
<ParametersListItem name="MangledName">- the mangled name of the variable being registered</ParametersListItem>
<ParametersListItem name="GeneratedRefs">- references generated by invocations of registerTargetGlobalVariable these are required by Clang for book keeping.</ParametersListItem>
<ParametersListItem name="OpenMPSIMD">- if OpenMP SIMD mode is currently enabled</ParametersListItem>
<ParametersListItem name="TargetTriple">- The OpenMP device target triple we are compiling for</ParametersListItem>
<ParametersListItem name="GlobalInitializer">- a lambda function which creates a constant used for initializing a pointer reference to the variable in certain cases. If a nullptr is passed, it will default to utilising the original variable to initialize the pointer reference.</ParametersListItem>
<ParametersListItem name="VariableLinkage">- a lambda function which returns the variables linkage type, if unspecified and a nullptr is given, it will instead utilise the linkage stored on the existing global variable in the LLVMModule.</ParametersListItem>
<ParametersListItem name="LlvmPtrTy">- The type of the variable we are generating or retrieving an address for</ParametersListItem>
<ParametersListItem name="Addr">- the original llvm value (addr) of the variable to be registered</ParametersListItem>
</ParametersList>

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l00931">931</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>, definition at line <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp/#l09531">9531</a> of file <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp">OMPIRBuilder.cpp</a>.
</MemberDefinition>

### setConfig() {#a3cf3a832c89fb823f696ce21ecf37b9b}

<MemberDefinition
  prototype={<>void llvm::OpenMPIRBuilder::setConfig (<a href="/docs/api/classes/llvm/openmpirbuilderconfig">OpenMPIRBuilderConfig</a> C)</>}
  labels = {["inline"]}>

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l00509">509</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>.
</MemberDefinition>

### setCorrectMemberOfFlag() {#abeea5a3df7d0266470cd04bb721db70e}

<MemberDefinition
  prototype={<>void OpenMPIRBuilder::setCorrectMemberOfFlag (<a href="/docs/api/namespaces/llvm/omp/#a02d7a52c47f2d71a111aef9d4fb70ecb">omp::OpenMPOffloadMappingFlags</a> &amp; Flags, <a href="/docs/api/namespaces/llvm/omp/#a02d7a52c47f2d71a111aef9d4fb70ecb">omp::OpenMPOffloadMappingFlags</a> MemberOfFlag)</>}>
Given an initial flag set, this function modifies it to contain the passed in MemberOfFlag generated from the getMemberOfFlag function.

The results are dependent on the existing flag bits set in the original flag set. 
<ParametersList title="Parameters">
<ParametersListItem name="Flags">- The original set of flags to be modified with the passed in MemberOfFlag.</ParametersListItem>
<ParametersListItem name="MemberOfFlag">- A modified OMP&#95;MAP&#95;MEMBER&#95;OF flag, adjusted slightly based on the getMemberOfFlag which adjusts the flag bits based on the members position in its parent.</ParametersListItem>
</ParametersList>

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l00963">963</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>, definition at line <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp/#l09456">9456</a> of file <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp">OMPIRBuilder.cpp</a>.
</MemberDefinition>

### tileLoops() {#a76e12ec076e7af4be7b8b77a5d53d3fc}

<MemberDefinition
  prototype={<>std::vector&lt; CanonicalLoopInfo &#42; &gt; OpenMPIRBuilder::tileLoops (<a href="/docs/api/classes/llvm/debugloc">DebugLoc</a> DL, <a href="/docs/api/classes/llvm/arrayref">ArrayRef</a>&lt; <a href="/docs/api/classes/llvm/canonicalloopinfo">CanonicalLoopInfo</a> &#42; &gt; Loops, <a href="/docs/api/classes/llvm/arrayref">ArrayRef</a>&lt; <a href="/docs/api/classes/llvm/value">Value</a> &#42; &gt; TileSizes)</>}>
Tile a loop nest.

Tiles the loops of <code>Loops</code> by the tile sizes in <code>TileSizes</code>. Loops in <code></code>/ Loops must be perfectly nested, from outermost to innermost loop (i.e. Loops.front() is the outermost loop). The trip count <a href="/docs/api/classes/llvm/value">llvm::Value</a> of every loop and every tile sizes must be usable in the outermost loop&#39;s preheader. This implies that the loop nest is rectangular.

Example: 
<ProgramListing>

<CodeLine><span class="doxyHighlightKeywordFlow">for</span><span class="doxyHighlight"> (</span><span class="doxyHighlightKeywordType">int</span><span class="doxyHighlight"> i = 0; i &lt; 15; ++i) </span><span class="doxyHighlightComment">// Canonical loop &quot;i&quot;</span></CodeLine>
<CodeLine><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">for</span><span class="doxyHighlight"> (</span><span class="doxyHighlightKeywordType">int</span><span class="doxyHighlight"> j = 0; <a href="/docs/api/namespaces/llvm/m68k/#ab3a288f2953d8eca3e363959fc2cf38ea363b122c528f54df4a0446b6bab05515">j</a> &lt; 14; ++<a href="/docs/api/namespaces/llvm/m68k/#ab3a288f2953d8eca3e363959fc2cf38ea363b122c528f54df4a0446b6bab05515">j</a>) </span><span class="doxyHighlightComment">// Canonical loop &quot;j&quot;</span></CodeLine>
<CodeLine><span class="doxyHighlight">      body(i, j);</span></CodeLine>

</ProgramListing>


After tiling with Loops=&#123;i,j&#125; and TileSizes=&#123;5,7&#125;, the loop is changed to 
<ProgramListing>

<CodeLine><span class="doxyHighlightKeywordFlow">for</span><span class="doxyHighlight"> (</span><span class="doxyHighlightKeywordType">int</span><span class="doxyHighlight"> i1 = 0; i1 &lt; 3; ++i1)</span></CodeLine>
<CodeLine><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">for</span><span class="doxyHighlight"> (</span><span class="doxyHighlightKeywordType">int</span><span class="doxyHighlight"> j1 = 0; j1 &lt; 2; ++j1)</span></CodeLine>
<CodeLine><span class="doxyHighlight">    </span><span class="doxyHighlightKeywordFlow">for</span><span class="doxyHighlight"> (</span><span class="doxyHighlightKeywordType">int</span><span class="doxyHighlight"> i2 = 0; i2 &lt; 5; ++i2)</span></CodeLine>
<CodeLine><span class="doxyHighlight">      </span><span class="doxyHighlightKeywordFlow">for</span><span class="doxyHighlight"> (</span><span class="doxyHighlightKeywordType">int</span><span class="doxyHighlight"> j2 = 0; j2 &lt; 7; ++j2)</span></CodeLine>
<CodeLine><span class="doxyHighlight">        body(i1&#42;3+i2, j1&#42;3+j2);</span></CodeLine>

</ProgramListing>


The returned vector are the loops &#123;i1,j1,i2,j2&#125;. The loops i1 and j1 are referred to the floor, and the loops i2 and j2 are the tiles. Tiling also handles non-constant trip counts, non-constant tile sizes and trip counts that are not multiples of the tile size. In the latter case the tile loop of the last floor-loop iteration will have fewer iterations than specified as its tile size.


<ParametersList title="Parameters">
<ParametersListItem name="DL">Debug location for instructions added by tiling, for instance the floor- and tile trip count computation.</ParametersListItem>
<ParametersListItem name="Loops">Loops to tile. The <a href="/docs/api/classes/llvm/canonicalloopinfo">CanonicalLoopInfo</a> objects are invalidated by this method, i.e. should not used after tiling.</ParametersListItem>
<ParametersListItem name="TileSizes">For each loop in <code>Loops</code>, the tile size for that dimensions.</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
A list of generated loops. Contains twice as many loops as the input loop nest; the first half are the floor loops and the second half are the tile loops.
</SectionUser>

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l01161">1161</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>, definition at line <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp/#l05015">5015</a> of file <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp">OMPIRBuilder.cpp</a>.
</MemberDefinition>

### unrollLoopFull() {#a28a2a9806d828609fe107f766d2dd569}

<MemberDefinition
  prototype={<>void OpenMPIRBuilder::unrollLoopFull (<a href="/docs/api/classes/llvm/debugloc">DebugLoc</a> DL, <a href="/docs/api/classes/llvm/canonicalloopinfo">CanonicalLoopInfo</a> &#42; Loop)</>}>
Fully unroll a loop.

Instead of unrolling the loop immediately (and duplicating its body instructions), it is deferred to LLVM&#39;s <a href="/docs/api/classes/llvm/loopunrollpass">LoopUnrollPass</a> by adding loop metadata.


<ParametersList title="Parameters">
<ParametersListItem name="DL">Debug location for instructions added by unrolling.</ParametersListItem>
<ParametersListItem name="<a href=&quot;/docs/api/classes/llvm/loop&quot;>Loop</a>">The loop to unroll. The loop will be invalidated.</ParametersListItem>
</ParametersList>

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l01172">1172</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>, definition at line <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp/#l05254">5254</a> of file <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp">OMPIRBuilder.cpp</a>.
</MemberDefinition>

### unrollLoopHeuristic() {#a4ca0068cb6a50615c74ecdb8f23839e0}

<MemberDefinition
  prototype={<>void OpenMPIRBuilder::unrollLoopHeuristic (<a href="/docs/api/classes/llvm/debugloc">DebugLoc</a> DL, <a href="/docs/api/classes/llvm/canonicalloopinfo">CanonicalLoopInfo</a> &#42; Loop)</>}>
Fully or partially unroll a loop.

How the loop is unrolled is determined using LLVM&#39;s <a href="/docs/api/classes/llvm/loopunrollpass">LoopUnrollPass</a>.


<ParametersList title="Parameters">
<ParametersListItem name="DL">Debug location for instructions added by unrolling.</ParametersListItem>
<ParametersListItem name="<a href=&quot;/docs/api/classes/llvm/loop&quot;>Loop</a>">The loop to unroll. The loop will be invalidated.</ParametersListItem>
</ParametersList>

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l01179">1179</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>, definition at line <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp/#l05261">5261</a> of file <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp">OMPIRBuilder.cpp</a>.
</MemberDefinition>

### unrollLoopPartial() {#a5e2b7ac5f48193117a340aa15b085719}

<MemberDefinition
  prototype={<>void OpenMPIRBuilder::unrollLoopPartial (<a href="/docs/api/classes/llvm/debugloc">DebugLoc</a> DL, <a href="/docs/api/classes/llvm/canonicalloopinfo">CanonicalLoopInfo</a> &#42; Loop, int32&#95;t Factor, <a href="/docs/api/classes/llvm/canonicalloopinfo">CanonicalLoopInfo</a> &#42;&#42; UnrolledCLI)</>}>
Partially unroll a loop.

The <a href="/docs/api/classes/llvm/canonicalloopinfo">CanonicalLoopInfo</a> of the unrolled loop for use with chained loop-associated directive can be requested using <code>UnrolledCLI</code>. Not needing the <a href="/docs/api/classes/llvm/canonicalloopinfo">CanonicalLoopInfo</a> allows more efficient code generation by deferring the actual unrolling to the <a href="/docs/api/classes/llvm/loopunrollpass">LoopUnrollPass</a> using loop metadata. A loop-associated directive applied to the unrolled loop needs to know the new trip count which means that if using a heuristically determined unroll factor (<code>Factor</code> == 0), that factor must be computed immediately. We are using the same logic as the <a href="/docs/api/classes/llvm/loopunrollpass">LoopUnrollPass</a> to derived the unroll factor, but which assumes that some canonicalization has taken place (e.g. Mem2Reg, LICM, GVN, Inlining, etc.). That is, the heuristic will perform better when the unrolled loop&#39;s <a href="/docs/api/classes/llvm/canonicalloopinfo">CanonicalLoopInfo</a> is not needed.


<ParametersList title="Parameters">
<ParametersListItem name="DL">Debug location for instructions added by unrolling.</ParametersListItem>
<ParametersListItem name="<a href=&quot;/docs/api/classes/llvm/loop&quot;>Loop</a>">The loop to unroll. The loop will be invalidated.</ParametersListItem>
<ParametersListItem name="Factor">The factor to unroll the loop by. A factor of 0 indicates that a heuristic should be used to determine the unroll-factor.</ParametersListItem>
<ParametersListItem name="UnrolledCLI">If non-null, receives the <a href="/docs/api/classes/llvm/canonicalloopinfo">CanonicalLoopInfo</a> of the partially unrolled loop. Otherwise, uses loop metadata to defer unrolling to the <a href="/docs/api/classes/llvm/loopunrollpass">LoopUnrollPass</a>.</ParametersListItem>
</ParametersList>

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l01203">1203</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>, definition at line <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp/#l05612">5612</a> of file <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp">OMPIRBuilder.cpp</a>.
</MemberDefinition>

</SectionDefinition>

<SectionDefinition>

## Private Member Functions

### applyDynamicWorkshareLoop() {#a040fad70b742c2d5fb4df1006b8e2fe4}

<MemberDefinition
  prototype={<>OpenMPIRBuilder::InsertPointOrErrorTy OpenMPIRBuilder::applyDynamicWorkshareLoop (<a href="/docs/api/classes/llvm/debugloc">DebugLoc</a> DL, <a href="/docs/api/classes/llvm/canonicalloopinfo">CanonicalLoopInfo</a> &#42; CLI, <a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> AllocaIP, <a href="/docs/api/namespaces/llvm/omp/#a231ea6a9a0009e38969a20d4293119c7">omp::OMPScheduleType</a> SchedType, bool NeedsBarrier, <a href="/docs/api/classes/llvm/value">Value</a> &#42; Chunk=nullptr)</>}>
Modifies the canonical loop to be a dynamically-scheduled workshare loop.

This takes a <code><a href="/docs/api/classes/llvm/loopinfo">LoopInfo</a></code> representing a canonical loop, such as the one created by <code>createCanonicalLoop</code> and emits additional instructions to turn it into a workshare loop. In particular, it calls to an OpenMP runtime function in the preheader to obtain, and then in each iteration to update the loop counter.


<ParametersList title="Parameters">
<ParametersListItem name="DL">Debug location for instructions added for the workshare-loop construct itself.</ParametersListItem>
<ParametersListItem name="CLI">A descriptor of the canonical loop to workshare.</ParametersListItem>
<ParametersListItem name="AllocaIP">An insertion point for Alloca instructions usable in the preheader of the loop.</ParametersListItem>
<ParametersListItem name="SchedType"><a href="/docs/api/classes/llvm/type">Type</a> of scheduling to be passed to the init function.</ParametersListItem>
<ParametersListItem name="NeedsBarrier">Indicates whether a barrier must be insterted after the loop.</ParametersListItem>
<ParametersListItem name="Chunk">The size of loop chunk considered as a unit when scheduling. If <code>nullptr</code>, defaults to 1.</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
Point where to insert code after the workshare construct.
</SectionUser>

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l01051">1051</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>, definition at line <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp/#l04723">4723</a> of file <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp">OMPIRBuilder.cpp</a>.
</MemberDefinition>

### applyStaticChunkedWorkshareLoop() {#ae5ac7c7120c51e85a0a9b107b278773f}

<MemberDefinition
  prototype={<>OpenMPIRBuilder::InsertPointOrErrorTy OpenMPIRBuilder::applyStaticChunkedWorkshareLoop (<a href="/docs/api/classes/llvm/debugloc">DebugLoc</a> DL, <a href="/docs/api/classes/llvm/canonicalloopinfo">CanonicalLoopInfo</a> &#42; CLI, <a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> AllocaIP, bool NeedsBarrier, <a href="/docs/api/classes/llvm/value">Value</a> &#42; ChunkSize)</>}>
Modifies the canonical loop a statically-scheduled workshare loop with a user-specified chunk size.

<ParametersList title="Parameters">
<ParametersListItem name="DL">Debug location for instructions added for the workshare-loop construct itself.</ParametersListItem>
<ParametersListItem name="CLI">A descriptor of the canonical loop to workshare.</ParametersListItem>
<ParametersListItem name="AllocaIP">An insertion point for Alloca instructions usable in the preheader of the loop.</ParametersListItem>
<ParametersListItem name="NeedsBarrier">Indicates whether a barrier must be inserted after the loop.</ParametersListItem>
<ParametersListItem name="ChunkSize">The user-specified chunk size.</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
Point where to insert code after the workshare construct.
</SectionUser>

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l01025">1025</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>, definition at line <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp/#l04235">4235</a> of file <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp">OMPIRBuilder.cpp</a>.
</MemberDefinition>

### applyStaticWorkshareLoop() {#a4844b18964505b7687f7261c6eccde30}

<MemberDefinition
  prototype={<>OpenMPIRBuilder::InsertPointOrErrorTy OpenMPIRBuilder::applyStaticWorkshareLoop (<a href="/docs/api/classes/llvm/debugloc">DebugLoc</a> DL, <a href="/docs/api/classes/llvm/canonicalloopinfo">CanonicalLoopInfo</a> &#42; CLI, <a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> AllocaIP, bool NeedsBarrier)</>}>
Modifies the canonical loop to be a statically-scheduled workshare loop.

This takes a <code><a href="/docs/api/classes/llvm/loopinfo">LoopInfo</a></code> representing a canonical loop, such as the one created by <code>createCanonicalLoop</code> and emits additional instructions to turn it into a workshare loop. In particular, it calls to an OpenMP runtime function in the preheader to obtain the loop bounds to be used in the current thread, updates the relevant instructions in the canonical loop and calls to an OpenMP runtime finalization function after the loop.


<ParametersList title="Parameters">
<ParametersListItem name="DL">Debug location for instructions added for the workshare-loop construct itself.</ParametersListItem>
<ParametersListItem name="CLI">A descriptor of the canonical loop to workshare.</ParametersListItem>
<ParametersListItem name="AllocaIP">An insertion point for Alloca instructions usable in the preheader of the loop.</ParametersListItem>
<ParametersListItem name="NeedsBarrier">Indicates whether a barrier must be inserted after the loop.</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
Point where to insert code after the workshare construct.
</SectionUser>

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l01007">1007</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>, definition at line <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp/#l04143">4143</a> of file <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp">OMPIRBuilder.cpp</a>.
</MemberDefinition>

### applyWorkshareLoopTarget() {#a3614ae5b7da8dfc1d3b6e74e3b114ae8}

<MemberDefinition
  prototype={<>OpenMPIRBuilder::InsertPointTy OpenMPIRBuilder::applyWorkshareLoopTarget (<a href="/docs/api/classes/llvm/debugloc">DebugLoc</a> DL, <a href="/docs/api/classes/llvm/canonicalloopinfo">CanonicalLoopInfo</a> &#42; CLI, <a href="#aafc1886793b898052f87edd7e9fdbaa3">InsertPointTy</a> AllocaIP, <a href="/docs/api/namespaces/llvm/omp/#ab6fb146c332fd3f3d677ee65081fe669">omp::WorksharingLoopType</a> LoopType)</>}>
Modifies the canonical loop to be a statically-scheduled workshare loop which is executed on the device.

This takes a <code>CLI</code> representing a canonical loop, such as the one created by 
<SectionUser title="See Also">
<a href="#ae0287686a5ffe03bc264972c862726ea">createCanonicalLoop</a> and emits additional <a href="/docs/api/namespaces/llvm/#a7e3e687ddfdcbacd404bcf17b917dd88">instructions</a> to turn it into a workshare loop. In particular, it calls to an OpenMP runtime <a href="/docs/api/files/lib/lib/analysis/regionprinter-cpp/#aa37fbbce2360106772fd97ed06455d55">function</a> in the <a href="/docs/api/files/lib/lib/target/lib/target/hexagon/hexagoncommongep-cpp/#aecea88f231914d2a6dc7ecf19a57f583">preheader</a> to call OpenMP device rtl <a href="/docs/api/files/lib/lib/analysis/regionprinter-cpp/#aa37fbbce2360106772fd97ed06455d55">function</a> which handles worksharing of loop body interations.
</SectionUser>


<ParametersList title="Parameters">
<ParametersListItem name="DL">Debug location for instructions added for the workshare-loop construct itself.</ParametersListItem>
<ParametersListItem name="CLI">A descriptor of the canonical loop to workshare.</ParametersListItem>
<ParametersListItem name="AllocaIP">An insertion point for Alloca instructions usable in the preheader of the loop.</ParametersListItem>
<ParametersListItem name="LoopType">Information about type of loop worksharing. It corresponds to type of loop workshare OpenMP pragma.</ParametersListItem>
</ParametersList>

<SectionUser title="Returns">
Point where to insert code after the workshare construct.
</SectionUser>

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l00985">985</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>, definition at line <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp/#l04528">4528</a> of file <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp">OMPIRBuilder.cpp</a>.
</MemberDefinition>

### createIfVersion() {#af94ce0ccebe00cffe61b5a50ba679eb8}

<MemberDefinition
  prototype={<>void OpenMPIRBuilder::createIfVersion (<a href="/docs/api/classes/llvm/canonicalloopinfo">CanonicalLoopInfo</a> &#42; Loop, <a href="/docs/api/classes/llvm/value">Value</a> &#42; IfCond, <a href="/docs/api/namespaces/llvm/#abf0f52ae29f87b5e0f2b95ff961cdae1">ValueToValueMapTy</a> &amp; VMap, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/classes/llvm/twine">Twine</a> &amp; NamePrefix=&quot;&quot;)</>}>
Create alternative version of the loop to support if clause.

OpenMP if clause can require to generate second loop. This loop will be executed when if clause condition is not met. createIfVersion adds branch instruction to the copied loop if <code>ifCond</code> is not met.


<ParametersList title="Parameters">
<ParametersListItem name="<a href=&quot;/docs/api/classes/llvm/loop&quot;>Loop</a>">Original loop which should be versioned.</ParametersListItem>
<ParametersListItem name="IfCond"><a href="/docs/api/classes/llvm/value">Value</a> which corresponds to if clause condition</ParametersListItem>
<ParametersListItem name="VMap"><a href="/docs/api/classes/llvm/value">Value</a> to value map to define relation between original and copied loop values and loop blocks.</ParametersListItem>
<ParametersListItem name="NamePrefix">Optional name prefix for if.then if.else blocks.</ParametersListItem>
</ParametersList>

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l01069">1069</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>, definition at line <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp/#l05269">5269</a> of file <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp">OMPIRBuilder.cpp</a>.
</MemberDefinition>

</SectionDefinition>

<SectionDefinition>

## Public Member Attributes

### ompOffloadInfoName {#aefadc356da16598ff8c210dafbf4a2b7}

<MemberDefinition
  prototype={<>const std::string llvm::OpenMPIRBuilder::ompOffloadInfoName = &quot;omp&#95;offload.info&quot;</>}>
OMP Offload Info <a href="/docs/api/classes/llvm/metadata">Metadata</a> name string.

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l03385">3385</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>.
</MemberDefinition>

</SectionDefinition>

<SectionDefinition>

## Public Static Functions

### getOpenMPDefaultSimdAlign() {#ac5b407054e7727d04053af9c3f1a5568}

<MemberDefinition
  prototype={<>unsigned OpenMPIRBuilder::getOpenMPDefaultSimdAlign (<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/classes/llvm/triple">Triple</a> &amp; TargetTriple, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/classes/llvm/stringmap">StringMap</a>&lt; bool &gt; &amp; Features)</>}
  labels = {["static"]}>
Get the default alignment value for given target.

<ParametersList title="Parameters">
<ParametersListItem name="TargetTriple"><a href="/docs/api/classes/llvm/target">Target</a> triple</ParametersListItem>
<ParametersListItem name="Features"><a href="/docs/api/classes/llvm/stringmap">StringMap</a> which describes extra CPU features</ParametersListItem>
</ParametersList>

Declaration at line <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h/#l00850">850</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a>, definition at line <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp/#l05326">5326</a> of file <a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp">OMPIRBuilder.cpp</a>.
</MemberDefinition>

</SectionDefinition>

<hr/>

The documentation for this class was generated from the following files:

<ul>
<li><a href="/docs/api/files/include/include/llvm/include/llvm/frontend/include/llvm/frontend/openmp/ompirbuilder-h">OMPIRBuilder.h</a></li>
<li><a href="/docs/api/files/lib/lib/frontend/lib/frontend/openmp/ompirbuilder-cpp">OMPIRBuilder.cpp</a></li>
</ul>

</DoxygenPage>
