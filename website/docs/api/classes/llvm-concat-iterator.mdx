---

# DO NOT EDIT!
# Automatically generated via docusaurus-plugin-doxygen by Doxygen.

slug: /api/classes/llvm/concat-iterator
custom_edit_url: null
keywords:
  - doxygen
  - reference
  - class
toc_max_heading_level: 3

---

import CodeBlock from '@theme/CodeBlock'

import DoxygenPage from '@xpack/docusaurus-plugin-doxygen/components/DoxygenPage'
import IncludesList from '@xpack/docusaurus-plugin-doxygen/components/IncludesList'
import IncludesListItem from '@xpack/docusaurus-plugin-doxygen/components/IncludesListItem'
import MemberDefinition from '@xpack/docusaurus-plugin-doxygen/components/MemberDefinition'
import MembersIndex from '@xpack/docusaurus-plugin-doxygen/components/MembersIndex'
import MembersIndexItem from '@xpack/docusaurus-plugin-doxygen/components/MembersIndexItem'
import SectionDefinition from '@xpack/docusaurus-plugin-doxygen/components/SectionDefinition'

import pluginConfig from '@site/docusaurus-plugin-doxygen-config.json'

# The `concat_iterator` Class Template Reference

<DoxygenPage pluginConfig={pluginConfig}>

Iterator wrapper that concatenates sequences together. <a href="#details">More...</a>

## Declaration

<CodeBlock>template &lt;typename ValueT, typename... IterTs&gt;
class llvm::concat_iterator&lt;ValueT, IterTs&gt;</CodeBlock>

## Included Headers

<IncludesList>
<IncludesListItem
  filePath="llvm/ADT/STLExtras.h"
  permalink="/docs/api/files/include/include/llvm/include/llvm/adt/stlextras-h"
  isLocal="true" />
</IncludesList>

## Base class

<MembersIndex>

<MembersIndexItem
  type="class"
  name={<><a href="/docs/api/classes/llvm/iterator-facade-base">iterator&#95;facade&#95;base&lt;DerivedT, IteratorCategoryT, T, DifferenceTypeT, PointerT, ReferenceT&gt;</a></>}>
CRTP base class which implements the entire standard iterator facade in terms of a minimal subset of the interface. <a href="/docs/api/classes/llvm/iterator-facade-base/#details">More...</a>
</MembersIndexItem>

</MembersIndex>

## Private Member Typedefs Index

<MembersIndex>

<MembersIndexItem
  template={<>template &lt;typename ValueT, typename... IterTs&gt;</>}
  type="using"
  name={<><a href="#a2127b4f8c6f96f9cfd4f9883c326fd08">BaseT</a> = typename concat&#95;iterator::iterator&#95;facade&#95;base</>}>
</MembersIndexItem>

<MembersIndexItem
  template={<>template &lt;typename ValueT, typename... IterTs&gt;</>}
  type="using"
  name={<><a href="#a767e224a758e1f7c3b80b79680b0dd06">handle&#95;type</a> = typename std::conditional&#95;t&lt; ReturnsByValue, std::optional&lt; ValueT &gt;, ValueT &#42; &gt;</>}>
</MembersIndexItem>

<MembersIndexItem
  template={<>template &lt;typename ValueT, typename... IterTs&gt;</>}
  type="using"
  name={<><a href="#a133bf7caa55511d1953efd6fa91ec53d">reference&#95;type</a> = typename std::conditional&#95;t&lt; ReturnsByValue, ValueT, ValueT &amp; &gt;</>}>
</MembersIndexItem>

</MembersIndex>

## Public Constructors Index

<MembersIndex>

<MembersIndexItem
  template={<>template &lt;typename... RangeTs&gt;</>}
  name={<><a href="#ac566cb13277fd8d2b3423537cbe733ef">concat&#95;iterator</a> (RangeTs &amp;&amp;... Ranges)</>}>
Constructs an iterator from a sequence of ranges. <a href="#ac566cb13277fd8d2b3423537cbe733ef">More...</a>
</MembersIndexItem>

</MembersIndex>

## Public Operators Index

<MembersIndex>

<MembersIndexItem
  template={<>template &lt;typename ValueT, typename... IterTs&gt;</>}
  type={<>reference&#95;type</>}
  name={<><a href="#af5351d8c6698d7e2647e6237325534d3">operator&#42;</a> () const</>}>
</MembersIndexItem>

<MembersIndexItem
  template={<>template &lt;typename ValueT, typename... IterTs&gt;</>}
  type={<><a href="/docs/api/classes/llvm/concat-iterator">concat&#95;iterator</a> &amp;</>}
  name={<><a href="#a0476ceeb48269d0462286a76096f522e">operator++</a> ()</>}>
</MembersIndexItem>

<MembersIndexItem
  template={<>template &lt;typename ValueT, typename... IterTs&gt;</>}
  type="bool"
  name={<><a href="#a305f0e04643fc1a893e7a2a6abda664a">operator==</a> (const concat&#95;iterator &amp;RHS) const</>}>
</MembersIndexItem>

</MembersIndex>

## Private Member Functions Index

<MembersIndex>

<MembersIndexItem
  template={<>template &lt;size&#95;t... Ns&gt;</>}
  type={<>reference&#95;type</>}
  name={<><a href="#ac4a05b0d970d38c0ff541946c5bb8252">get</a> (std::index&#95;sequence&lt; Ns... &gt;) const</>}>
Finds the first non-end iterator, dereferences, and returns the resulting reference. <a href="#ac4a05b0d970d38c0ff541946c5bb8252">More...</a>
</MembersIndexItem>

<MembersIndexItem
  template={<>template &lt;size&#95;t Index&gt;</>}
  type={<>handle&#95;type</>}
  name={<><a href="#ad655fd05ac919ac5487ce75a78f58bfb">getHelper</a> () const</>}>
Returns null if the specified iterator is at the end. <a href="#ad655fd05ac919ac5487ce75a78f58bfb">More...</a>
</MembersIndexItem>

<MembersIndexItem
  template={<>template &lt;size&#95;t... Ns&gt;</>}
  type="void"
  name={<><a href="#ad677f99958a236d6eeccb84fa064c4fb">increment</a> (std::index&#95;sequence&lt; Ns... &gt;)</>}>
Increments the first non-end iterator. <a href="#ad677f99958a236d6eeccb84fa064c4fb">More...</a>
</MembersIndexItem>

<MembersIndexItem
  template={<>template &lt;size&#95;t Index&gt;</>}
  type="bool"
  name={<><a href="#a35d4e619dfd1f1c8b92fcf44ce7b392d">incrementHelper</a> ()</>}>
Attempts to increment a specific iterator. <a href="#a35d4e619dfd1f1c8b92fcf44ce7b392d">More...</a>
</MembersIndexItem>

</MembersIndex>

## Private Member Attributes Index

<MembersIndex>

<MembersIndexItem
  template={<>template &lt;typename ValueT, typename... IterTs&gt;</>}
  type={<>std::tuple&lt; IterTs... &gt;</>}
  name={<><a href="#ac73f85210264d3941b3d505b72f3e0fa">Begins</a></>}>
We store both the current and end iterators for each concatenated sequence in a tuple of pairs. <a href="#ac73f85210264d3941b3d505b72f3e0fa">More...</a>
</MembersIndexItem>

<MembersIndexItem
  template={<>template &lt;typename ValueT, typename... IterTs&gt;</>}
  type={<>std::tuple&lt; IterTs... &gt;</>}
  name={<><a href="#ae308f3b21d0ecaeb699434ff81db2a46">Ends</a></>}>
</MembersIndexItem>

</MembersIndex>

## Private Static Attributes Index

<MembersIndex>

<MembersIndexItem
  template={<>template &lt;typename ValueT, typename... IterTs&gt;</>}
  type="bool"
  name={<><a href="#a7435a6099c404e6fdac70f7e4c03b5e2">ReturnsByValue</a> =
      !(std::is&#95;reference&#95;v&lt;decltype(&#42;std::declval&lt;IterTs&gt;())&gt; &amp;&amp; ...)</>}>
</MembersIndexItem>

</MembersIndex>

## Description {#details}

Iterator wrapper that concatenates sequences together.

This can concatenate different iterators, even with different types, into a single iterator provided the value types of all the concatenated iterators expose <code>reference</code> and <code>pointer</code> types that can be converted to <code>ValueT &amp;</code> and <code>ValueT &#42;</code> respectively. It doesn&#39;t support more interesting/customized pointer or reference types.

Currently this only supports forward or higher iterator categories as inputs and always exposes a forward iterator interface.

Definition at line 1022 of file <a href="/docs/api/files/include/include/llvm/include/llvm/adt/stlextras-h">STLExtras.h</a>.

<SectionDefinition>

## Private Member Typedefs

### BaseT {#a2127b4f8c6f96f9cfd4f9883c326fd08}

<MemberDefinition
  template={<>template &lt;typename ValueT, typename... IterTs&gt;</>}
  prototype={<>using llvm::concat&#95;iterator&lt; ValueT, IterTs &gt;::BaseT =  typename concat&#95;iterator::iterator&#95;facade&#95;base</>}>

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/adt/stlextras-h/#l01025">1025</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/adt/stlextras-h">STLExtras.h</a>.
</MemberDefinition>

### handle&#95;type {#a767e224a758e1f7c3b80b79680b0dd06}

<MemberDefinition
  template={<>template &lt;typename ValueT, typename... IterTs&gt;</>}
  prototype={<>using llvm::concat&#95;iterator&lt; ValueT, IterTs &gt;::handle&#95;type = 
      typename std::conditional&#95;t&lt;ReturnsByValue, std::optional&lt;ValueT&gt;,
                                  ValueT &#42;&gt;</>}>

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/adt/stlextras-h/#l01033">1033</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/adt/stlextras-h">STLExtras.h</a>.
</MemberDefinition>

### reference&#95;type {#a133bf7caa55511d1953efd6fa91ec53d}

<MemberDefinition
  template={<>template &lt;typename ValueT, typename... IterTs&gt;</>}
  prototype={<>using llvm::concat&#95;iterator&lt; ValueT, IterTs &gt;::reference&#95;type = 
      typename std::conditional&#95;t&lt;ReturnsByValue, ValueT, ValueT &amp;&gt;</>}>

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/adt/stlextras-h/#l01030">1030</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/adt/stlextras-h">STLExtras.h</a>.
</MemberDefinition>

</SectionDefinition>

<SectionDefinition>

## Public Constructors

### concat&#95;iterator() {#ac566cb13277fd8d2b3423537cbe733ef}

<MemberDefinition
  template={<>template &lt;typename... RangeTs&gt;</>}
  prototype={<>llvm::concat&#95;iterator&lt; ValueT, IterTs &gt;::concat&#95;iterator (RangeTs &amp;&amp;... Ranges)</>}
  labels = {["inline", "explicit"]}>
Constructs an iterator from a sequence of ranges.

We need the full range to know how to switch between each of the iterators.

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/adt/stlextras-h/#l01114">1114</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/adt/stlextras-h">STLExtras.h</a>.
</MemberDefinition>

</SectionDefinition>

<SectionDefinition>

## Public Operators

### operator&#42;() {#af5351d8c6698d7e2647e6237325534d3}

<MemberDefinition
  template={<>template &lt;typename ValueT, typename... IterTs&gt;</>}
  prototype={<>reference&#95;type llvm::concat&#95;iterator&lt; ValueT, IterTs &gt;::operator&#42; () const</>}
  labels = {["inline"]}>

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/adt/stlextras-h/#l01124">1124</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/adt/stlextras-h">STLExtras.h</a>.
</MemberDefinition>

### operator++() {#a0476ceeb48269d0462286a76096f522e}

<MemberDefinition
  template={<>template &lt;typename ValueT, typename... IterTs&gt;</>}
  prototype={<>concat&#95;iterator &amp; llvm::concat&#95;iterator&lt; ValueT, IterTs &gt;::operator++ ()</>}
  labels = {["inline"]}>

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/adt/stlextras-h/#l01119">1119</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/adt/stlextras-h">STLExtras.h</a>.
</MemberDefinition>

### operator==() {#a305f0e04643fc1a893e7a2a6abda664a}

<MemberDefinition
  template={<>template &lt;typename ValueT, typename... IterTs&gt;</>}
  prototype={<>bool llvm::concat&#95;iterator&lt; ValueT, IterTs &gt;::operator== (<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/classes/llvm/concat-iterator">concat&#95;iterator</a> &amp; RHS) const</>}
  labels = {["inline"]}>

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/adt/stlextras-h/#l01128">1128</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/adt/stlextras-h">STLExtras.h</a>.
</MemberDefinition>

</SectionDefinition>

<SectionDefinition>

## Private Member Functions

### get() {#ac4a05b0d970d38c0ff541946c5bb8252}

<MemberDefinition
  template={<>template &lt;size&#95;t... Ns&gt;</>}
  prototype={<>reference&#95;type llvm::concat&#95;iterator&lt; ValueT, IterTs &gt;::get (std::index&#95;sequence&lt; Ns... &gt;) const</>}
  labels = {["inline"]}>
Finds the first non-end iterator, dereferences, and returns the resulting reference.

It is an error to call this with all iterators at the end.

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/adt/stlextras-h/#l01095">1095</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/adt/stlextras-h">STLExtras.h</a>.
</MemberDefinition>

### getHelper() {#ad655fd05ac919ac5487ce75a78f58bfb}

<MemberDefinition
  template={<>template &lt;size&#95;t Index&gt;</>}
  prototype={<>handle&#95;type llvm::concat&#95;iterator&lt; ValueT, IterTs &gt;::getHelper () const</>}
  labels = {["inline"]}>
Returns null if the specified iterator is at the end.

Otherwise, dereferences the iterator and returns the address of the resulting reference.

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/adt/stlextras-h/#l01079">1079</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/adt/stlextras-h">STLExtras.h</a>.
</MemberDefinition>

### increment() {#ad677f99958a236d6eeccb84fa064c4fb}

<MemberDefinition
  template={<>template &lt;size&#95;t... Ns&gt;</>}
  prototype={<>void llvm::concat&#95;iterator&lt; ValueT, IterTs &gt;::increment (std::index&#95;sequence&lt; Ns... &gt;)</>}
  labels = {["inline"]}>
Increments the first non-end iterator.

It is an error to call this with all iterators at the end.

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/adt/stlextras-h/#l01063">1063</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/adt/stlextras-h">STLExtras.h</a>.
</MemberDefinition>

### incrementHelper() {#a35d4e619dfd1f1c8b92fcf44ce7b392d}

<MemberDefinition
  template={<>template &lt;size&#95;t Index&gt;</>}
  prototype={<>bool llvm::concat&#95;iterator&lt; ValueT, IterTs &gt;::incrementHelper ()</>}
  labels = {["inline"]}>
Attempts to increment a specific iterator.

Returns true if it was able to increment the iterator. Returns false if the iterator is already at the end iterator.

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/adt/stlextras-h/#l01050">1050</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/adt/stlextras-h">STLExtras.h</a>.
</MemberDefinition>

</SectionDefinition>

<SectionDefinition>

## Private Member Attributes

### Begins {#ac73f85210264d3941b3d505b72f3e0fa}

<MemberDefinition
  template={<>template &lt;typename ValueT, typename... IterTs&gt;</>}
  prototype={<>std::tuple&lt;IterTs...&gt; llvm::concat&#95;iterator&lt; ValueT, IterTs &gt;::Begins</>}>
We store both the current and end iterators for each concatenated sequence in a tuple of pairs.

Note that something like <a href="/docs/api/classes/llvm/iterator-range">iterator&#95;range</a> seems nice at first here, but the range properties are of little benefit and end up getting in the way because we need to do mutation on the current iterators.

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/adt/stlextras-h/#l01043">1043</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/adt/stlextras-h">STLExtras.h</a>.
</MemberDefinition>

### Ends {#ae308f3b21d0ecaeb699434ff81db2a46}

<MemberDefinition
  template={<>template &lt;typename ValueT, typename... IterTs&gt;</>}
  prototype={<>std::tuple&lt;IterTs...&gt; llvm::concat&#95;iterator&lt; ValueT, IterTs &gt;::Ends</>}>

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/adt/stlextras-h/#l01044">1044</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/adt/stlextras-h">STLExtras.h</a>.
</MemberDefinition>

</SectionDefinition>

<SectionDefinition>

## Private Static Attributes

### ReturnsByValue {#a7435a6099c404e6fdac70f7e4c03b5e2}

<MemberDefinition
  template={<>template &lt;typename ValueT, typename... IterTs&gt;</>}
  prototype={<>bool llvm::concat&#95;iterator&lt; ValueT, IterTs &gt;::ReturnsByValue =
      !(std::is&#95;reference&#95;v&lt;decltype(&#42;std::declval&lt;IterTs&gt;())&gt; &amp;&amp; ...)</>}
  labels = {["constexpr", "static"]}>

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/adt/stlextras-h/#l01027">1027</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/adt/stlextras-h">STLExtras.h</a>.
</MemberDefinition>

</SectionDefinition>

<hr/>

The documentation for this class was generated from the following file:

<ul>
<li><a href="/docs/api/files/include/include/llvm/include/llvm/adt/stlextras-h">STLExtras.h</a></li>
</ul>

</DoxygenPage>
