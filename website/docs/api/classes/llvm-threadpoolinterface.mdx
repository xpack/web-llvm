---

# DO NOT EDIT!
# Automatically generated via docusaurus-plugin-doxygen by Doxygen.

slug: /api/classes/llvm/threadpoolinterface
custom_edit_url: null
keywords:
  - doxygen
  - reference
  - class
toc_max_heading_level: 3

---

import CodeBlock from '@theme/CodeBlock'

import DoxygenPage from '@xpack/docusaurus-plugin-doxygen/components/DoxygenPage'
import IncludesList from '@xpack/docusaurus-plugin-doxygen/components/IncludesList'
import IncludesListItem from '@xpack/docusaurus-plugin-doxygen/components/IncludesListItem'
import MemberDefinition from '@xpack/docusaurus-plugin-doxygen/components/MemberDefinition'
import MembersIndex from '@xpack/docusaurus-plugin-doxygen/components/MembersIndex'
import MembersIndexItem from '@xpack/docusaurus-plugin-doxygen/components/MembersIndexItem'
import SectionDefinition from '@xpack/docusaurus-plugin-doxygen/components/SectionDefinition'

import pluginConfig from '@site/docusaurus-plugin-doxygen-config.json'

# The `ThreadPoolInterface` Class Reference

<DoxygenPage pluginConfig={pluginConfig}>

This defines the abstract base interface for a ThreadPool allowing asynchronous parallel execution on a defined number of threads. <a href="#details">More...</a>

## Declaration

<CodeBlock>class llvm::ThreadPoolInterface</CodeBlock>

## Included Headers

<IncludesList>
<IncludesListItem
  filePath="llvm/Support/ThreadPool.h"
  permalink="/docs/api/files/include/include/llvm/include/llvm/support/threadpool-h"
  isLocal="true" />
</IncludesList>

## Derived Classes

<MembersIndex>

<MembersIndexItem
  type="class"
  name={<><a href="/docs/api/classes/llvm/singlethreadexecutor">SingleThreadExecutor</a></>}>
A non-threaded implementation. <a href="/docs/api/classes/llvm/singlethreadexecutor/#details">More...</a>
</MembersIndexItem>

</MembersIndex>

## Public Destructor Index

<MembersIndex>

<MembersIndexItem
  name={<><a href="#abe20bbefd5e591081ad9ac5c19eedb5a">~ThreadPoolInterface</a> ()</>}>
Destroying the pool will drain the pending tasks and wait. <a href="#abe20bbefd5e591081ad9ac5c19eedb5a">More...</a>
</MembersIndexItem>

</MembersIndex>

## Public Member Functions Index

<MembersIndex>

<MembersIndexItem
  template={<>template &lt;typename Function, typename... Args&gt;</>}
  type="auto"
  name={<><a href="#ad43d0052f680e6ac08426d8821df178d">async</a> (Function &amp;&amp;F, Args &amp;&amp;...ArgList)</>}>
Asynchronous submission of a task to the pool. <a href="#ad43d0052f680e6ac08426d8821df178d">More...</a>
</MembersIndexItem>

<MembersIndexItem
  template={<>template &lt;typename Function, typename... Args&gt;</>}
  type="auto"
  name={<><a href="#a0c671f2f05014107ee55248f18f88dea">async</a> (ThreadPoolTaskGroup &amp;Group, Function &amp;&amp;F, Args &amp;&amp;...ArgList)</>}>
Overload, task will be in the given task group. <a href="#a0c671f2f05014107ee55248f18f88dea">More...</a>
</MembersIndexItem>

<MembersIndexItem
  template={<>template &lt;typename Func&gt;</>}
  type="auto "
  name={<><a href="#a7397950f434c9dff4b594c980e5d518d">async</a> (Func &amp;&amp;F) -&gt; std::shared&#95;future&lt; decltype(<a href="/docs/api/files/lib/lib/support/md5-cpp/#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a>())&gt;</>}>
Asynchronous submission of a task to the pool. <a href="#a7397950f434c9dff4b594c980e5d518d">More...</a>
</MembersIndexItem>

<MembersIndexItem
  template={<>template &lt;typename Func&gt;</>}
  type="auto "
  name={<><a href="#a671aff841cc82b9c2f39b1d7272c6174">async</a> (ThreadPoolTaskGroup &amp;Group, Func &amp;&amp;F) -&gt; std::shared&#95;future&lt; decltype(<a href="/docs/api/files/lib/lib/support/md5-cpp/#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a>())&gt;</>}>
</MembersIndexItem>

<MembersIndexItem
  type="unsigned"
  name={<><a href="#a6ec7a595fe1af1fa5204286641a356fc">getMaxConcurrency</a> () const =0</>}>
Returns the maximum number of worker this pool can eventually grow to. <a href="#a6ec7a595fe1af1fa5204286641a356fc">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#a0ea46b29f97f4f535c563a68a38185a4">wait</a> ()=0</>}>
Blocking wait for all the threads to complete and the queue to be empty. <a href="#a0ea46b29f97f4f535c563a68a38185a4">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#ad4dbcf0b0e80230eb3f28d30672eff19">wait</a> (ThreadPoolTaskGroup &amp;Group)=0</>}>
Blocking wait for only all the threads in the given group to complete. <a href="#ad4dbcf0b0e80230eb3f28d30672eff19">More...</a>
</MembersIndexItem>

</MembersIndex>

## Private Member Functions Index

<MembersIndex>

<MembersIndexItem
  type="void"
  name={<><a href="#a7d2ed24366ea0eaa572d4273f9ff2fd6">asyncEnqueue</a> (std::function&lt; void()&gt; Task, ThreadPoolTaskGroup &#42;Group)=0</>}>
The actual method to enqueue a task to be defined by the concrete implementation. <a href="#a7d2ed24366ea0eaa572d4273f9ff2fd6">More...</a>
</MembersIndexItem>

<MembersIndexItem
  template={<>template &lt;typename ResTy&gt;</>}
  type="auto "
  name={<><a href="#ace2964d9b181e3894a14807262340e1a">asyncImpl</a> (std::function&lt; ResTy()&gt; Task, ThreadPoolTaskGroup &#42;Group) -&gt; std::shared&#95;future&lt; ResTy &gt;</>}>
Asynchronous submission of a task to the pool. <a href="#ace2964d9b181e3894a14807262340e1a">More...</a>
</MembersIndexItem>

</MembersIndex>

## Description {#details}

This defines the abstract base interface for a ThreadPool allowing asynchronous parallel execution on a defined number of threads.

It is possible to reuse one thread pool for different groups of tasks by grouping tasks using <a href="/docs/api/classes/llvm/threadpooltaskgroup">ThreadPoolTaskGroup</a>. All tasks are processed using the same queue, but it is possible to wait only for a specific group of tasks to finish.

It is also possible for worker threads to submit new tasks and wait for them. Note that this may result in a deadlock in cases such as when a task (directly or indirectly) tries to wait for its own completion, or when all available threads are used up by tasks waiting for a task that has no thread left to run on (this includes waiting on the returned future). It should be generally safe to <a href="#a0ea46b29f97f4f535c563a68a38185a4">wait()</a> for a group as long as groups do not form a cycle.

Definition at line 49 of file <a href="/docs/api/files/include/include/llvm/include/llvm/support/threadpool-h">ThreadPool.h</a>.

<SectionDefinition>

## Public Destructor

### ~ThreadPoolInterface() {#abe20bbefd5e591081ad9ac5c19eedb5a}

<MemberDefinition
  prototype="ThreadPoolInterface::~ThreadPoolInterface ()"
  labels = {["virtual"]}>
Destroying the pool will drain the pending tasks and wait.

The current thread may participate in the execution of the pending tasks.

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/support/threadpool-h/#l00058">58</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/support/threadpool-h">ThreadPool.h</a>.
</MemberDefinition>

</SectionDefinition>

<SectionDefinition>

## Public Member Functions

### async() {#ad43d0052f680e6ac08426d8821df178d}

<MemberDefinition
  template={<>template &lt;typename Function, typename... Args&gt;</>}
  prototype={<>auto llvm::ThreadPoolInterface::async (<a href="/docs/api/classes/llvm/function">Function</a> &amp;&amp; F, Args &amp;&amp;... ArgList)</>}
  labels = {["inline"]}>
Asynchronous submission of a task to the pool.

The returned future can be used to wait for the task to finish and is <em>non-blocking</em> on destruction.

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/support/threadpool-h/#l00078">78</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/support/threadpool-h">ThreadPool.h</a>.
</MemberDefinition>

### async() {#a0c671f2f05014107ee55248f18f88dea}

<MemberDefinition
  template={<>template &lt;typename Function, typename... Args&gt;</>}
  prototype={<>auto llvm::ThreadPoolInterface::async (<a href="/docs/api/classes/llvm/threadpooltaskgroup">ThreadPoolTaskGroup</a> &amp; Group, <a href="/docs/api/classes/llvm/function">Function</a> &amp;&amp; F, Args &amp;&amp;... ArgList)</>}
  labels = {["inline"]}>
Overload, task will be in the given task group.

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/support/threadpool-h/#l00086">86</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/support/threadpool-h">ThreadPool.h</a>.
</MemberDefinition>

### async() {#a7397950f434c9dff4b594c980e5d518d}

<MemberDefinition
  template={<>template &lt;typename Func&gt;</>}
  prototype={<>std::shared&#95;future&lt; decltype(F())&gt; llvm::ThreadPoolInterface::async (Func &amp;&amp; F)</>}
  labels = {["inline"]}>
Asynchronous submission of a task to the pool.

The returned future can be used to wait for the task to finish and is <em>non-blocking</em> on destruction.

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/support/threadpool-h/#l00095">95</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/support/threadpool-h">ThreadPool.h</a>.
</MemberDefinition>

### async() {#a671aff841cc82b9c2f39b1d7272c6174}

<MemberDefinition
  template={<>template &lt;typename Func&gt;</>}
  prototype={<>std::shared&#95;future&lt; decltype(F())&gt; llvm::ThreadPoolInterface::async (<a href="/docs/api/classes/llvm/threadpooltaskgroup">ThreadPoolTaskGroup</a> &amp; Group, Func &amp;&amp; F)</>}
  labels = {["inline"]}>

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/support/threadpool-h/#l00101">101</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/support/threadpool-h">ThreadPool.h</a>.
</MemberDefinition>

### getMaxConcurrency() {#a6ec7a595fe1af1fa5204286641a356fc}

<MemberDefinition
  prototype="virtual unsigned llvm::ThreadPoolInterface::getMaxConcurrency () const">
Returns the maximum number of worker this pool can eventually grow to.

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/support/threadpool-h/#l00073">73</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/support/threadpool-h">ThreadPool.h</a>.
</MemberDefinition>

### wait() {#a0ea46b29f97f4f535c563a68a38185a4}

<MemberDefinition
  prototype="virtual void llvm::ThreadPoolInterface::wait ()">
Blocking wait for all the threads to complete and the queue to be empty.

It is an error to try to add new tasks while blocking on this call. Calling <a href="#a0ea46b29f97f4f535c563a68a38185a4">wait()</a> from a task would deadlock waiting for itself.

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/support/threadpool-h/#l00063">63</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/support/threadpool-h">ThreadPool.h</a>.
</MemberDefinition>

### wait() {#ad4dbcf0b0e80230eb3f28d30672eff19}

<MemberDefinition
  prototype={<>virtual void llvm::ThreadPoolInterface::wait (<a href="/docs/api/classes/llvm/threadpooltaskgroup">ThreadPoolTaskGroup</a> &amp; Group)</>}>
Blocking wait for only all the threads in the given group to complete.

It is possible to wait even inside a task, but waiting (directly or indirectly) on itself will deadlock. If called from a task running on a worker thread, the call may process pending tasks while waiting in order not to waste the thread.

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/support/threadpool-h/#l00070">70</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/support/threadpool-h">ThreadPool.h</a>.
</MemberDefinition>

</SectionDefinition>

<SectionDefinition>

## Private Member Functions

### asyncEnqueue() {#a7d2ed24366ea0eaa572d4273f9ff2fd6}

<MemberDefinition
  prototype={<>virtual void llvm::ThreadPoolInterface::asyncEnqueue (std::function&lt; void()&gt; Task, <a href="/docs/api/classes/llvm/threadpooltaskgroup">ThreadPoolTaskGroup</a> &#42; Group)</>}>
The actual method to enqueue a task to be defined by the concrete implementation.

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/support/threadpool-h/#l00052">52</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/support/threadpool-h">ThreadPool.h</a>.
</MemberDefinition>

### asyncImpl() {#ace2964d9b181e3894a14807262340e1a}

<MemberDefinition
  template={<>template &lt;typename ResTy&gt;</>}
  prototype={<>std::shared&#95;future&lt; ResTy &gt; llvm::ThreadPoolInterface::asyncImpl (std::function&lt; ResTy()&gt; Task, <a href="/docs/api/classes/llvm/threadpooltaskgroup">ThreadPoolTaskGroup</a> &#42; Group)</>}
  labels = {["inline"]}>
Asynchronous submission of a task to the pool.

The returned future can be used to wait for the task to finish and is <em>non-blocking</em> on destruction.

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/support/threadpool-h/#l00111">111</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/support/threadpool-h">ThreadPool.h</a>.
</MemberDefinition>

</SectionDefinition>

<hr/>

The documentation for this class was generated from the following file:

<ul>
<li><a href="/docs/api/files/include/include/llvm/include/llvm/support/threadpool-h">ThreadPool.h</a></li>
</ul>

</DoxygenPage>
