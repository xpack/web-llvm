---

# DO NOT EDIT!
# Automatically generated via docusaurus-plugin-doxygen by Doxygen.

slug: /api/classes/llvm/mca/resourcestate
custom_edit_url: null
keywords:
  - doxygen
  - reference
  - class
toc_max_heading_level: 3

---

import CodeBlock from '@theme/CodeBlock'

import DoxygenPage from '@xpack/docusaurus-plugin-doxygen/components/DoxygenPage'
import IncludesList from '@xpack/docusaurus-plugin-doxygen/components/IncludesList'
import IncludesListItem from '@xpack/docusaurus-plugin-doxygen/components/IncludesListItem'
import MemberDefinition from '@xpack/docusaurus-plugin-doxygen/components/MemberDefinition'
import MembersIndex from '@xpack/docusaurus-plugin-doxygen/components/MembersIndex'
import MembersIndexItem from '@xpack/docusaurus-plugin-doxygen/components/MembersIndexItem'
import SectionDefinition from '@xpack/docusaurus-plugin-doxygen/components/SectionDefinition'

import pluginConfig from '@site/docusaurus-plugin-doxygen-config.json'

# The `ResourceState` Class Reference

<DoxygenPage pluginConfig={pluginConfig}>

A processor resource descriptor. <a href="#details">More...</a>

## Declaration

<CodeBlock>class llvm::mca::ResourceState</CodeBlock>

## Included Headers

<IncludesList>
<IncludesListItem
  filePath="llvm/MCA/HardwareUnits/ResourceManager.h"
  permalink="/docs/api/files/include/include/llvm/include/llvm/mca/include/llvm/mca/hardwareunits/resourcemanager-h"
  isLocal="true" />
</IncludesList>

## Private Member Functions Index

<MembersIndex>

<MembersIndexItem
  type="void"
  name={<><a href="#a32dd6a9044edddba5266d1c62dd34db2">cycleEvent</a> (SmallVectorImpl&lt; ResourceRef &gt; &amp;ResourcesFreed)</>}>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#afa99bfd758109a4e146d24a336a8b7e4">dump</a> () const</>}>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#aad12ec4f74c5d78414738ed3b6bdb363">fastIssueInstruction</a> (const InstrDesc &amp;Desc, SmallVectorImpl&lt; ResourceWithCycles &gt; &amp;Pipes)</>}>
A resource mask. <a href="#aad12ec4f74c5d78414738ed3b6bdb363">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#a965a906ee0ae3fe72d57f6e3a47a7695">issueInstructionImpl</a> (const InstrDesc &amp;Desc, SmallVectorImpl&lt; ResourceWithCycles &gt; &amp;Pipes)</>}>
</MembersIndexItem>

</MembersIndex>

## Private Member Attributes Index

<MembersIndex>

<MembersIndexItem
  type={<><a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> unsigned</>}
  name={<><a href="#a4d986b91e554d8aecae6e4334adbba3a">ProcResourceDescIndex</a></>}>
An index to the <a href="/docs/api/structs/llvm/mcprocresourcedesc">MCProcResourceDesc</a> entry in the processor model. <a href="#a4d986b91e554d8aecae6e4334adbba3a">More...</a>
</MembersIndexItem>

</MembersIndex>

## Description {#details}

A processor resource descriptor.

There is an instance of this class for every processor resource defined by the machine scheduling model. Objects of class <a href="/docs/api/classes/llvm/mca/resourcestate">ResourceState</a> dynamically track the usage of processor resource units.

Definition at line 135 of file <a href="/docs/api/files/include/include/llvm/include/llvm/mca/include/llvm/mca/hardwareunits/resourcemanager-h">ResourceManager.h</a>.

<SectionDefinition>

## Private Member Functions

### cycleEvent() {#a32dd6a9044edddba5266d1c62dd34db2}

<MemberDefinition
  prototype={<>void llvm::mca::ResourceState::cycleEvent (<a href="/docs/api/classes/llvm/smallvectorimpl">SmallVectorImpl</a>&lt; <a href="/docs/api/namespaces/llvm/mca/#a961b7aeaca000c803c0f4b1df4d26c27">ResourceRef</a> &gt; &amp; ResourcesFreed)</>}>

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/mca/include/llvm/mca/hardwareunits/resourcemanager-h/#l00460">460</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/mca/include/llvm/mca/hardwareunits/resourcemanager-h">ResourceManager.h</a>.
</MemberDefinition>

### dump() {#afa99bfd758109a4e146d24a336a8b7e4}

<MemberDefinition
  prototype="void llvm::mca::ResourceState::dump () const"
  labels = {["inline"]}>

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/mca/include/llvm/mca/hardwareunits/resourcemanager-h/#l00463">463</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/mca/include/llvm/mca/hardwareunits/resourcemanager-h">ResourceManager.h</a>.
</MemberDefinition>

### fastIssueInstruction() {#aad12ec4f74c5d78414738ed3b6bdb363}

<MemberDefinition
  prototype={<>void llvm::mca::ResourceState::fastIssueInstruction (<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/structs/llvm/mca/instrdesc">InstrDesc</a> &amp; Desc, <a href="/docs/api/classes/llvm/smallvectorimpl">SmallVectorImpl</a>&lt; ResourceWithCycles &gt; &amp; Pipes)</>}>
A resource mask.

This is generated by the tool with the help of function ‘<a href="/docs/api/namespaces/llvm/mca/#ae1d3c5a1f43dcec43774a3767b41e447">mca::computeProcResourceMasks</a>` (see Support.h). / / <a href="/docs/api/files/lib/lib/support/optimizedstructlayout-cpp/#a5208f2b0568d811c542f8d8097dbc035">Field</a> ResourceMask only has one bit set if this resource state describes a / processor resource unit (i.e. this is not a group). That means, we can / quickly check if a resource is a group by simply counting the number of / bits that are set in the mask. / / The most significant bit of a mask (MSB) uniquely identifies a resource. / Remaining bits are used to describe the composition of a group (Group). / / Example (little endian): / Resource | Mask | MSB | Group / ------—+---------—+---------—+---------— / A | 0b000001 | 0b000001 | 0b000000 / | | | / B | 0b000010 | 0b000010 | 0b000000 / | | | / C | 0b010000 | 0b010000 | 0b000000 / | | | / D | 0b110010 | 0b100000 | 0b010010 / / In this example, resources A, B and C are processor resource units. / Only resource D is a group resource, and it contains resources B and C. / That is because MSB(B) and MSB(C) are both contained within Group(D). const uint64&#95;t ResourceMask;

/ A ProcResource can have multiple units. / / For processor resource groups this field is a mask of contained resource / units. It is obtained from ResourceMask by clearing the highest set bit. / The number of resource units in a group can be simply computed as the / population count of this field. / / For normal (i.e. non-group) resources, the number of bits set in this mask / is equivalent to the number of units declared by the processor model (see / field &#39;NumUnits&#39; in &#39;ProcResourceUnits&#39;). uint64&#95;t ResourceSizeMask;

/ A mask of ready units. uint64&#95;t ReadyMask;

/ Buffered resources will have this field set to a positive number different / than zero. A buffered resource behaves like a reservation station / implementing its own buffer for out-of-order execution. / / A BufferSize of 1 is used by scheduler resources that force in-order / execution. / / A BufferSize of 0 is used to model in-order issue/dispatch resources. / Since in-order issue/dispatch resources don&#39;t implement buffers, dispatch / events coincide with issue events. / Also, no other instruction ca be dispatched/issue while this resource is / in use. Only when all the &quot;resource cycles&quot; are consumed (after the issue / event), a new instruction ca be dispatched. const int BufferSize;

/ Available slots in the buffer (zero, if this is not a buffered resource). unsigned AvailableSlots;

/ This field is set if this resource is currently reserved. / / Resources can be reserved for a number of cycles. / Instructions can still be dispatched to reserved resources. However, / istructions dispatched to a reserved resource cannot be issued to the / underlying units (i.e. pipelines) until the resource is released. bool Unavailable;

const bool IsAGroup;

/ Checks for the availability of unit &#39;SubResMask&#39; in the group. bool isSubResourceReady(uint64&#95;t SubResMask) const &#123; return ReadyMask &amp; SubResMask; &#125;

public: ResourceState(const MCProcResourceDesc &amp;Desc, unsigned Index, uint64&#95;t Mask);

unsigned getProcResourceID() const &#123; return ProcResourceDescIndex; &#125; uint64&#95;t getResourceMask() const &#123; return ResourceMask; &#125; uint64&#95;t getReadyMask() const &#123; return ReadyMask; &#125; int getBufferSize() const &#123; return BufferSize; &#125;

bool isBuffered() const &#123; return BufferSize &gt; 0; &#125; bool isInOrder() const &#123; return BufferSize == 1; &#125;

/ Returns true if this is an in-order dispatch/issue resource. bool isADispatchHazard() const &#123; return BufferSize == 0; &#125; bool isReserved() const &#123; return Unavailable; &#125;

void setReserved() &#123; Unavailable = true; &#125; void clearReserved() &#123; Unavailable = false; &#125;

/ Returs true if this resource is not reserved, and if there are at least / <code>NumUnits</code> available units. bool isReady(unsigned NumUnits = 1) const;

uint64&#95;t getNumReadyUnits() const &#123; return llvm::popcount(ReadyMask); &#125;

bool isAResourceGroup() const &#123; return IsAGroup; &#125;

bool containsResource(uint64&#95;t ID) const &#123; return ResourceMask &amp; ID; &#125;

void markSubResourceAsUsed(uint64&#95;t ID) &#123; assert(isSubResourceReady(ID)); ReadyMask ^= ID; &#125;

void releaseSubResource(uint64&#95;t ID) &#123; assert(!isSubResourceReady(ID)); ReadyMask ^= ID; &#125;

unsigned getNumUnits() const &#123; return isAResourceGroup() ? 1U : llvm::popcount(ResourceSizeMask); &#125;

/ Checks if there is an available slot in the resource buffer. / / Returns RS&#95;BUFFER&#95;AVAILABLE if this is not a buffered resource, or if / there is a slot available. / / Returns RS&#95;RESERVED if this buffered resource is a dispatch hazard, and it / is reserved. / / Returns RS&#95;BUFFER&#95;UNAVAILABLE if there are no available slots. <a href="/docs/api/namespaces/llvm/mca/#a75e277a81194898f20f1c3613af0072a">ResourceStateEvent</a> isBufferAvailable() const;

/ Reserve a buffer slot. / / Returns true if the buffer is not full. / It always returns true if BufferSize is set to zero. bool reserveBuffer() &#123; if (BufferSize &lt;= 0) return true;

–AvailableSlots; assert(AvailableSlots &lt;= static&#95;cast&lt;unsigned&gt;(BufferSize)); return AvailableSlots; &#125;

/ Releases a slot in the buffer. void releaseBuffer() &#123; Ignore dispatch hazards or invalid buffer sizes. if (BufferSize &lt;= 0) return;

++AvailableSlots; assert(AvailableSlots &lt;= static&#95;cast&lt;unsigned&gt;(BufferSize)); &#125;

void dump() const;

&#125;;

/ A resource unit identifier. / / This is used to identify a specific processor resource unit using a pair / of indices where the &#39;first&#39; index is a processor resource mask, and the / &#39;second&#39; index is an index for a &quot;sub-resource&quot; (i.e. unit). typedef std::pair&lt;uint64&#95;t, uint64&#95;t&gt; <a href="/docs/api/namespaces/llvm/mca/#a961b7aeaca000c803c0f4b1df4d26c27">ResourceRef</a>;

First: a <a href="/docs/api/structs/llvm/mcprocresourcedesc">MCProcResourceDesc</a> index identifying a buffered resource. Second: max number of buffer entries used in this resource. typedef std::pair&lt;unsigned, unsigned&gt; BufferUsageEntry;

/ A resource manager for processor resource units and groups. / / This class owns all the <a href="/docs/api/classes/llvm/mca/resourcestate">ResourceState</a> objects, and it is responsible for / acting on requests from a <a href="/docs/api/classes/llvm/mca/scheduler">Scheduler</a> by updating the internal state of / <a href="/docs/api/classes/llvm/mca/resourcestate">ResourceState</a> objects. / This class doesn&#39;t know about instruction itineraries and functional units. / In future, it can be extended to support itineraries too through the same / public interface. class <a href="/docs/api/classes/llvm/resourcemanager">ResourceManager</a> &#123; Set of resources available on the subtarget.

There is an instance of <a href="/docs/api/classes/llvm/mca/resourcestate">ResourceState</a> for every resource declared by the target scheduling model.

Elements of this vector are ordered by resource kind. In particular, resource units take precedence over resource groups.

The index of a processor resource in this vector depends on the value of its mask (see the description of field ResourceState::ResourceMask). In particular, it is computed as the position of the most significant bit set (MSB) in the mask plus one (since we want to ignore the invalid resource descriptor at index zero).

Example (little endian):

Resource | Mask | MSB | Index ------—+------—+------—+----— A | 0b00001 | 0b00001 | 1 | | | B | 0b00100 | 0b00100 | 3 | | | C | 0b10010 | 0b10000 | 5

The same index is also used to address elements within vector <code>Strategies</code> and vector <code>Resource2Groups</code>. std::vector&lt;std::unique&#95;ptr&lt;ResourceState&gt;&gt; Resources; std::vector&lt;std::unique&#95;ptr&lt;ResourceStrategy&gt;&gt; Strategies;

Used to quickly identify groups that own a particular resource unit. std::vector&lt;uint64&#95;t&gt; Resource2Groups;

A table that maps processor resource IDs to processor resource masks. <a href="/docs/api/classes/llvm/smallvector">SmallVector&lt;uint64&#95;t, 8&gt;</a> ProcResID2Mask;

A table that maps resource indices to actual processor resource IDs in the scheduling model. <a href="/docs/api/classes/llvm/smallvector">SmallVector&lt;unsigned, 8&gt;</a> ResIndex2ProcResID;

Keeps track of which resources are busy, and how many cycles are left before those become usable again. <a href="/docs/api/classes/llvm/smalldensemap">SmallDenseMap&lt;ResourceRef, unsigned&gt;</a> BusyResources;

Set of processor resource units available on the target. uint64&#95;t ProcResUnitMask;

Set of processor resource units that are available during this cycle. uint64&#95;t AvailableProcResUnits;

Set of processor resources that are currently reserved. uint64&#95;t ReservedResourceGroups;

Set of unavailable scheduler buffer resources. This is used internally to speedup <code>canBeDispatched()</code> queries. uint64&#95;t AvailableBuffers;

Set of dispatch hazard buffer resources that are currently unavailable. uint64&#95;t ReservedBuffers;

Returns the actual resource unit that will be used. <a href="/docs/api/namespaces/llvm/mca/#a961b7aeaca000c803c0f4b1df4d26c27">ResourceRef</a> selectPipe(uint64&#95;t ResourceID);

void <a href="/docs/api/files/lib/lib/codegen/lib/codegen/globalisel/localizer-cpp/#a428090a453f41a199ef67fc3f2179fbc">use(const ResourceRef &amp;RR)</a>; void <a href="/docs/api/namespaces/llvm/#a650dea4533083a886cec9f16d80356d9a123fead50246387983ee340507115ef4">release(const ResourceRef &amp;RR)</a>;

unsigned getNumUnits(uint64&#95;t ResourceID) const;

Overrides the selection strategy for the processor resource with the given mask. void setCustomStrategyImpl(std::unique&#95;ptr&lt;ResourceStrategy&gt; S,
                             uint64&#95;t ResourceMask);

public: ResourceManager(const MCSchedModel &amp;SM); virtual ~ResourceManager() = default;

Overrides the selection strategy for the resource at index ResourceID in the <a href="/docs/api/structs/llvm/mcprocresourcedesc">MCProcResourceDesc</a> table. void setCustomStrategy(std::unique&#95;ptr&lt;ResourceStrategy&gt; S,
                         unsigned ResourceID) &#123; assert(ResourceID &lt; ProcResID2Mask.size() &amp;&amp; &quot;Invalid resource index in input!&quot;); return setCustomStrategyImpl(std::move(S), ProcResID2Mask&#91;ResourceID&#93;); &#125;

Returns RS&#95;BUFFER&#95;AVAILABLE if buffered resources are not reserved, and if there are enough available slots in the buffers. <a href="/docs/api/namespaces/llvm/mca/#a75e277a81194898f20f1c3613af0072a">ResourceStateEvent</a> canBeDispatched(uint64&#95;t ConsumedBuffers) const;

Return the processor resource identifier associated to this Mask. unsigned resolveResourceMask(uint64&#95;t Mask) const;

Acquires a slot from every buffered resource in mask <code>ConsumedBuffers</code>. Units that are dispatch hazards (i.e. BufferSize=0) are marked as reserved. void reserveBuffers(uint64&#95;t ConsumedBuffers);

Releases a slot from every buffered resource in mask <code>ConsumedBuffers</code>. ConsumedBuffers is a bitmask of previously acquired buffers (using method <code>reserveBuffers</code>). Units that are dispatch hazards (i.e. BufferSize=0) are not automatically unreserved by this method. void releaseBuffers(uint64&#95;t ConsumedBuffers);

Reserve a processor resource. A reserved resource is not available for instruction issue until it is released. void reserveResource(uint64&#95;t ResourceID);

Release a previously reserved processor resource. void releaseResource(uint64&#95;t ResourceID);

Returns a zero mask if resources requested by <a href="/docs/api/namespaces/llvm/#a4de98a9acffcef5bb4b31862cb8c72ac">Desc</a> are all available during this cycle. It returns a non-zero mask value only if there are unavailable processor resources; each bit set in the mask represents a busy processor resource unit or a reserved processor resource group. uint64&#95;t checkAvailability(const InstrDesc &amp;Desc) const;

uint64&#95;t getProcResUnitMask() const &#123; return ProcResUnitMask; &#125; uint64&#95;t getAvailableProcResUnits() const &#123; return AvailableProcResUnits; &#125;

using ResourceWithCycles = std::pair&lt;ResourceRef, ReleaseAtCycles&gt;;

void issueInstruction(const InstrDesc &amp;Desc,
                        SmallVectorImpl&lt;ResourceWithCycles&gt; &amp;Pipes) &#123; if (Desc.HasPartiallyOverlappingGroups) return issueInstructionImpl(Desc, Pipes);

return fastIssueInstruction(Desc, Pipes); &#125;

Selects pipeline resources consumed by an instruction. This method works under the assumption that used group resources don&#39;t partially overlap. The logic is guaranteed to find a valid resource unit schedule, no matter in which order individual uses are processed. For that reason, the vector of resource uses is simply (and quickly) processed in sequence. The resulting schedule is eventually stored into vector <code>Pipes</code>.

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/mca/include/llvm/mca/hardwareunits/resourcemanager-h/#l00449">449</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/mca/include/llvm/mca/hardwareunits/resourcemanager-h">ResourceManager.h</a>.
</MemberDefinition>

### issueInstructionImpl() {#a965a906ee0ae3fe72d57f6e3a47a7695}

<MemberDefinition
  prototype={<>void llvm::mca::ResourceState::issueInstructionImpl (<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/structs/llvm/mca/instrdesc">InstrDesc</a> &amp; Desc, <a href="/docs/api/classes/llvm/smallvectorimpl">SmallVectorImpl</a>&lt; ResourceWithCycles &gt; &amp; Pipes)</>}>

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/mca/include/llvm/mca/hardwareunits/resourcemanager-h/#l00457">457</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/mca/include/llvm/mca/hardwareunits/resourcemanager-h">ResourceManager.h</a>.
</MemberDefinition>

</SectionDefinition>

<SectionDefinition>

## Private Member Attributes

### ProcResourceDescIndex {#a4d986b91e554d8aecae6e4334adbba3a}

<MemberDefinition
  prototype="const unsigned llvm::mca::ResourceState::ProcResourceDescIndex">
An index to the <a href="/docs/api/structs/llvm/mcprocresourcedesc">MCProcResourceDesc</a> entry in the processor model.

Definition at line <a href="/docs/api/files/include/include/llvm/include/llvm/mca/include/llvm/mca/hardwareunits/resourcemanager-h/#l00137">137</a> of file <a href="/docs/api/files/include/include/llvm/include/llvm/mca/include/llvm/mca/hardwareunits/resourcemanager-h">ResourceManager.h</a>.
</MemberDefinition>

</SectionDefinition>

<hr/>

The documentation for this class was generated from the following file:

<ul>
<li><a href="/docs/api/files/include/include/llvm/include/llvm/mca/include/llvm/mca/hardwareunits/resourcemanager-h">ResourceManager.h</a></li>
</ul>

</DoxygenPage>
