---

# DO NOT EDIT!
# Automatically generated via docusaurus-plugin-doxygen by Doxygen.

slug: /api/classes/anonymous-namespace-x86speculativeloadhardening-cpp-/x86speculativeloadhardeningpass
custom_edit_url: null
keywords:
  - doxygen
  - reference
  - class
toc_max_heading_level: 3

---

import CodeBlock from '@theme/CodeBlock'

import DoxygenPage from '@xpack/docusaurus-plugin-doxygen/components/DoxygenPage'
import MemberDefinition from '@xpack/docusaurus-plugin-doxygen/components/MemberDefinition'
import MembersIndex from '@xpack/docusaurus-plugin-doxygen/components/MembersIndex'
import MembersIndexItem from '@xpack/docusaurus-plugin-doxygen/components/MembersIndexItem'
import SectionDefinition from '@xpack/docusaurus-plugin-doxygen/components/SectionDefinition'

import pluginConfig from '@site/docusaurus-plugin-doxygen-config.json'

# The `X86SpeculativeLoadHardeningPass` Class Reference

<DoxygenPage pluginConfig={pluginConfig}>



## Declaration

<CodeBlock>class anonymous_namespace{X86SpeculativeLoadHardening.cpp}::X86SpeculativeLoadHardeningPass</CodeBlock>

## Base class

<MembersIndex>

<MembersIndexItem
  type="class"
  name={<><a href="/docs/api/classes/llvm/machinefunctionpass">MachineFunctionPass</a></>}>
<a href="/docs/api/classes/llvm/machinefunctionpass">MachineFunctionPass</a> - This class adapts the <a href="/docs/api/classes/llvm/functionpass">FunctionPass</a> interface to allow convenient creation of passes that operate on the <a href="/docs/api/classes/llvm/machinefunction">MachineFunction</a> representation. <a href="/docs/api/classes/llvm/machinefunctionpass/#details">More...</a>
</MembersIndexItem>

</MembersIndex>

## Public Constructors Index

<MembersIndex>

<MembersIndexItem
  name={<><a href="#a77a626d52a8457ef92d87b702df1cb7f">X86SpeculativeLoadHardeningPass</a> ()</>}>
</MembersIndexItem>

</MembersIndex>

## Public Member Functions Index

<MembersIndex>

<MembersIndexItem
  type="void"
  name={<><a href="#a395357d9b35c4d32866dac3ab09a335a">getAnalysisUsage</a> (AnalysisUsage &amp;AU) const override</>}>
getAnalysisUsage - Subclasses that override getAnalysisUsage must call this. <a href="#a395357d9b35c4d32866dac3ab09a335a">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<><a href="/docs/api/classes/llvm/stringref">StringRef</a></>}
  name={<><a href="#afc095bc1100ba5f1e44a49e741303f28">getPassName</a> () const override</>}>
getPassName - Return a nice clean name for a pass. <a href="#afc095bc1100ba5f1e44a49e741303f28">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="bool"
  name={<><a href="#a862b3b4b5ed250fcfb2d6f9a130f4a0c">runOnMachineFunction</a> (MachineFunction &amp;MF) override</>}>
runOnMachineFunction - This method must be overloaded to perform the desired machine code transformation or analysis. <a href="#a862b3b4b5ed250fcfb2d6f9a130f4a0c">More...</a>
</MembersIndexItem>

</MembersIndex>

## Private Member Functions Index

<MembersIndex>

<MembersIndexItem
  type="bool"
  name={<><a href="#a8fb1b7b0795af4afaad6fbe2bbad1b4f">canHardenRegister</a> (Register Reg)</>}>
</MembersIndexItem>

<MembersIndexItem
  type={<><a href="/docs/api/classes/llvm/smallvector">SmallVector</a>&lt; BlockCondInfo, 16 &gt;</>}
  name={<><a href="#a9288e68efcb80c36f717b85f956b8c22">collectBlockCondInfo</a> (MachineFunction &amp;MF)</>}>
</MembersIndexItem>

<MembersIndexItem
  type="unsigned"
  name={<><a href="#a124c30984d35bb558c28bed24433e677">extractPredStateFromSP</a> (MachineBasicBlock &amp;MBB, MachineBasicBlock::iterator InsertPt, const DebugLoc &amp;Loc)</>}>
Extracts the predicate state stored in the high bits of the stack pointer. <a href="#a124c30984d35bb558c28bed24433e677">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#ac91f80e5fe7079cb556e107af58aa915">hardenEdgesWithLFENCE</a> (MachineFunction &amp;MF)</>}>
Implements the naive hardening approach of putting an LFENCE after every potentially mis-predicted control flow construct. <a href="#ac91f80e5fe7079cb556e107af58aa915">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#a27e361ee6ed1a69fa63aa5ce5a93cac9">hardenIndirectCallOrJumpInstr</a> (MachineInstr &amp;MI, SmallDenseMap&lt; unsigned, unsigned, 32 &gt; &amp;AddrRegToHardenedReg)</>}>
An attacker may speculatively store over a value that is then speculatively loaded and used as the target of an indirect call or jump instruction. <a href="#a27e361ee6ed1a69fa63aa5ce5a93cac9">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#a2cc96bcaec5dcc9c812aa674278bf8b0">hardenLoadAddr</a> (MachineInstr &amp;MI, MachineOperand &amp;BaseMO, MachineOperand &amp;IndexMO, SmallDenseMap&lt; unsigned, unsigned, 32 &gt; &amp;AddrRegToHardenedReg)</>}>
</MembersIndexItem>

<MembersIndexItem
  type="unsigned"
  name={<><a href="#a9a63f76260d0e7c60d0acca5da94973c">hardenPostLoad</a> (MachineInstr &amp;MI)</>}>
Harden a load by hardening the loaded value in the defined register. <a href="#a9a63f76260d0e7c60d0acca5da94973c">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#a79aa2da36f644b0a5894e49159921fe7">hardenReturnInstr</a> (MachineInstr &amp;MI)</>}>
Harden a return instruction. <a href="#a79aa2da36f644b0a5894e49159921fe7">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="unsigned"
  name={<><a href="#a6192a88ae0ffb9aae6d2777f03bc2051">hardenValueInRegister</a> (Register Reg, MachineBasicBlock &amp;MBB, MachineBasicBlock::iterator InsertPt, const DebugLoc &amp;Loc)</>}>
Harden a value in a register. <a href="#a6192a88ae0ffb9aae6d2777f03bc2051">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#a6bf98c3ecbac31ed744d67bd7e1fd6ba">mergePredStateIntoSP</a> (MachineBasicBlock &amp;MBB, MachineBasicBlock::iterator InsertPt, const DebugLoc &amp;Loc, unsigned PredStateReg)</>}>
Takes the current predicate state (in a register) and merges it into the stack pointer. <a href="#a6bf98c3ecbac31ed744d67bd7e1fd6ba">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#a57fe992bc7311068a5e174e5115345e5">restoreEFLAGS</a> (MachineBasicBlock &amp;MBB, MachineBasicBlock::iterator InsertPt, const DebugLoc &amp;Loc, Register Reg)</>}>
Restore EFLAGS from the provided GPR. <a href="#a57fe992bc7311068a5e174e5115345e5">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="unsigned"
  name={<><a href="#a51c88fadd2d858ca48009266fa4f9e20">saveEFLAGS</a> (MachineBasicBlock &amp;MBB, MachineBasicBlock::iterator InsertPt, const DebugLoc &amp;Loc)</>}>
Save EFLAGS into the returned GPR. <a href="#a51c88fadd2d858ca48009266fa4f9e20">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<><a href="/docs/api/classes/llvm/machineinstr">MachineInstr</a> &#42;</>}
  name={<><a href="#a4a2590a4dd70cb8fc910e778999a149d">sinkPostLoadHardenedInst</a> (MachineInstr &amp;MI, SmallPtrSetImpl&lt; MachineInstr &#42; &gt; &amp;HardenedInstrs)</>}>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#a83e6c452f7fdc25aeff4b8d56ffa68f2">tracePredStateThroughBlocksAndHarden</a> (MachineFunction &amp;MF)</>}>
<a href="/docs/api/classes/llvm/trace">Trace</a> the predicate state through each of the blocks in the function, hardening everything necessary along the way. <a href="#a83e6c452f7fdc25aeff4b8d56ffa68f2">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#a9e3bcfd049a584052d380b5b9f6d5910">tracePredStateThroughCall</a> (MachineInstr &amp;MI)</>}>
<a href="/docs/api/classes/llvm/trace">Trace</a> the predicate state through a call. <a href="#a9e3bcfd049a584052d380b5b9f6d5910">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<><a href="/docs/api/classes/llvm/smallvector">SmallVector</a>&lt; <a href="/docs/api/classes/llvm/machineinstr">MachineInstr</a> &#42;, 16 &gt;</>}
  name={<><a href="#a561226da60bb592263645c4c2221e2b3">tracePredStateThroughCFG</a> (MachineFunction &amp;MF, ArrayRef&lt; BlockCondInfo &gt; Infos)</>}>
<a href="/docs/api/classes/llvm/trace">Trace</a> the predicate state through the CFG, instrumenting each conditional branch such that misspeculation through an edge will poison the predicate state. <a href="#a561226da60bb592263645c4c2221e2b3">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<><a href="/docs/api/classes/llvm/smallvector">SmallVector</a>&lt; <a href="/docs/api/classes/llvm/machineinstr">MachineInstr</a> &#42;, 16 &gt;</>}
  name={<><a href="#a99e2041e476780454dd8421e1ba23bca">tracePredStateThroughIndirectBranches</a> (MachineFunction &amp;MF)</>}>
<a href="/docs/api/classes/llvm/trace">Trace</a> the predicate state through indirect branches, instrumenting them to poison the state if a target is reached that does not match the expected target. <a href="#a99e2041e476780454dd8421e1ba23bca">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#abb1705e42db56a885ff72109bae739a5">unfoldCallAndJumpLoads</a> (MachineFunction &amp;MF)</>}>
</MembersIndexItem>

</MembersIndex>

## Private Member Attributes Index

<MembersIndex>

<MembersIndexItem
  type={<><a href="/docs/api/classes/llvm/machineregisterinfo">MachineRegisterInfo</a> &#42;</>}
  name={<><a href="#a455d25db0312916c89c3b89268a74736">MRI</a> = nullptr</>}>
</MembersIndexItem>

<MembersIndexItem
  type={<>std::optional&lt; PredState &gt;</>}
  name={<><a href="#ac90994b9a84a001b8c9e5ee90630e184">PS</a></>}>
</MembersIndexItem>

<MembersIndexItem
  type={<><a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/classes/llvm/x86subtarget">X86Subtarget</a> &#42;</>}
  name={<><a href="#ab6d274b65a12e504061a83af5e701001">Subtarget</a> = nullptr</>}>
</MembersIndexItem>

<MembersIndexItem
  type={<><a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/classes/llvm/x86instrinfo">X86InstrInfo</a> &#42;</>}
  name={<><a href="#ab25b96ceead471840bc2c0bf4ea9d504">TII</a> = nullptr</>}>
</MembersIndexItem>

<MembersIndexItem
  type={<><a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/classes/llvm/targetregisterinfo">TargetRegisterInfo</a> &#42;</>}
  name={<><a href="#a0d888e74c1090f8752b50cbaa7e9e6b8">TRI</a> = nullptr</>}>
</MembersIndexItem>

</MembersIndex>

## Public Static Attributes Index

<MembersIndex>

<MembersIndexItem
  type="char"
  name={<><a href="#a845bb9b2068e7fd8052fc0e53ed461e5">ID</a> = 0</>}>
Pass identification, replacement for typeid. <a href="#a845bb9b2068e7fd8052fc0e53ed461e5">More...</a>
</MembersIndexItem>

</MembersIndex>


Definition at line 121 of file <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp">X86SpeculativeLoadHardening.cpp</a>.

<SectionDefinition>

## Public Constructors

### X86SpeculativeLoadHardeningPass() {#a77a626d52a8457ef92d87b702df1cb7f}

<MemberDefinition
  prototype={<>anonymous&#95;namespace&#123;X86SpeculativeLoadHardening.cpp&#125;::X86SpeculativeLoadHardeningPass::X86SpeculativeLoadHardeningPass ()</>}
  labels = {["inline"]}>

Definition at line <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp/#l00123">123</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp">X86SpeculativeLoadHardening.cpp</a>.
</MemberDefinition>

</SectionDefinition>

<SectionDefinition>

## Public Member Functions

### getAnalysisUsage() {#a395357d9b35c4d32866dac3ab09a335a}

<MemberDefinition
  prototype={<>void X86SpeculativeLoadHardeningPass::getAnalysisUsage (<a href="/docs/api/classes/llvm/analysisusage">AnalysisUsage</a> &amp; AU) const</>}
  labels = {["virtual"]}>
getAnalysisUsage - Subclasses that override getAnalysisUsage must call this.

For MachineFunctionPasses, calling AU.preservesCFG() indicates that the pass does not modify the MachineBasicBlock CFG.

Definition at line <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp/#l00129">129</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp">X86SpeculativeLoadHardening.cpp</a>.
</MemberDefinition>

### getPassName() {#afc095bc1100ba5f1e44a49e741303f28}

<MemberDefinition
  prototype={<>StringRef anonymous&#95;namespace&#123;X86SpeculativeLoadHardening.cpp&#125;::X86SpeculativeLoadHardeningPass::getPassName () const</>}
  labels = {["inline", "virtual"]}>
getPassName - Return a nice clean name for a pass.

This usually implemented in terms of the name that is registered by one of the Registration templates, but can be overloaded directly.

Definition at line <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp/#l00125">125</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp">X86SpeculativeLoadHardening.cpp</a>.
</MemberDefinition>

### runOnMachineFunction() {#a862b3b4b5ed250fcfb2d6f9a130f4a0c}

<MemberDefinition
  prototype={<>bool X86SpeculativeLoadHardeningPass::runOnMachineFunction (<a href="/docs/api/classes/llvm/machinefunction">MachineFunction</a> &amp; MF)</>}
  labels = {["virtual"]}>
runOnMachineFunction - This method must be overloaded to perform the desired machine code transformation or analysis.

Definition at line <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp/#l00128">128</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp">X86SpeculativeLoadHardening.cpp</a>.
</MemberDefinition>

</SectionDefinition>

<SectionDefinition>

## Private Member Functions

### canHardenRegister() {#a8fb1b7b0795af4afaad6fbe2bbad1b4f}

<MemberDefinition
  prototype={<>bool X86SpeculativeLoadHardeningPass::canHardenRegister (<a href="/docs/api/classes/llvm/register">Register</a> Reg)</>}>

Definition at line <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp/#l00201">201</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp">X86SpeculativeLoadHardening.cpp</a>.
</MemberDefinition>

### collectBlockCondInfo() {#a9288e68efcb80c36f717b85f956b8c22}

<MemberDefinition
  prototype={<>SmallVector&lt; X86SpeculativeLoadHardeningPass::BlockCondInfo, 16 &gt; X86SpeculativeLoadHardeningPass::collectBlockCondInfo (<a href="/docs/api/classes/llvm/machinefunction">MachineFunction</a> &amp; MF)</>}>

Definition at line <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp/#l00168">168</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp">X86SpeculativeLoadHardening.cpp</a>.
</MemberDefinition>

### extractPredStateFromSP() {#a124c30984d35bb558c28bed24433e677}

<MemberDefinition
  prototype={<>unsigned X86SpeculativeLoadHardeningPass::extractPredStateFromSP (<a href="/docs/api/classes/llvm/machinebasicblock">MachineBasicBlock</a> &amp; MBB, <a href="/docs/api/classes/llvm/machinebasicblock/#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a> InsertPt, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/classes/llvm/debugloc">DebugLoc</a> &amp; Loc)</>}>
Extracts the predicate state stored in the high bits of the stack pointer.

Definition at line <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp/#l00190">190</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp">X86SpeculativeLoadHardening.cpp</a>.
</MemberDefinition>

### hardenEdgesWithLFENCE() {#ac91f80e5fe7079cb556e107af58aa915}

<MemberDefinition
  prototype={<>void X86SpeculativeLoadHardeningPass::hardenEdgesWithLFENCE (<a href="/docs/api/classes/llvm/machinefunction">MachineFunction</a> &amp; MF)</>}>
Implements the naive hardening approach of putting an LFENCE after every potentially mis-predicted control flow construct.

We include this as an alternative mostly for the purpose of comparison. The performance impact of this is expected to be extremely severe and not practical for any real-world users.

Definition at line <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp/#l00166">166</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp">X86SpeculativeLoadHardening.cpp</a>.
</MemberDefinition>

### hardenIndirectCallOrJumpInstr() {#a27e361ee6ed1a69fa63aa5ce5a93cac9}

<MemberDefinition
  prototype={<>void X86SpeculativeLoadHardeningPass::hardenIndirectCallOrJumpInstr (<a href="/docs/api/classes/llvm/machineinstr">MachineInstr</a> &amp; MI, <a href="/docs/api/classes/llvm/smalldensemap">SmallDenseMap</a>&lt; unsigned, unsigned, 32 &gt; &amp; AddrRegToHardenedReg)</>}>
An attacker may speculatively store over a value that is then speculatively loaded and used as the target of an indirect call or jump instruction.

This is called Spectre v1.2 or Bounds Check Bypass Store (BCBS) and is described in this paper: <a href="https://people.csail.mit.edu/vlk/spectre11.pdf">https://people.csail.mit.edu/vlk/spectre11.pdf</a>

When this happens, the speculative execution of the call or jump will end up being steered to this attacker controlled address. While most such loads will be adequately hardened already, we want to ensure that they are definitively treated as needing post-load hardening. While address hardening is sufficient to prevent secret data from leaking to the attacker, it may not be sufficient to prevent an attacker from steering speculative execution. We forcibly unfolded all relevant loads above and so will always have an opportunity to post-load harden here, we just need to scan for cases not already flagged and add them.

Definition at line <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp/#l00208">208</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp">X86SpeculativeLoadHardening.cpp</a>.
</MemberDefinition>

### hardenLoadAddr() {#a2cc96bcaec5dcc9c812aa674278bf8b0}

<MemberDefinition
  prototype={<>void X86SpeculativeLoadHardeningPass::hardenLoadAddr (<a href="/docs/api/classes/llvm/machineinstr">MachineInstr</a> &amp; MI, <a href="/docs/api/classes/llvm/machineoperand">MachineOperand</a> &amp; BaseMO, <a href="/docs/api/classes/llvm/machineoperand">MachineOperand</a> &amp; IndexMO, <a href="/docs/api/classes/llvm/smalldensemap">SmallDenseMap</a>&lt; unsigned, unsigned, 32 &gt; &amp; AddrRegToHardenedReg)</>}>

Definition at line <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp/#l00195">195</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp">X86SpeculativeLoadHardening.cpp</a>.
</MemberDefinition>

### hardenPostLoad() {#a9a63f76260d0e7c60d0acca5da94973c}

<MemberDefinition
  prototype={<>unsigned X86SpeculativeLoadHardeningPass::hardenPostLoad (<a href="/docs/api/classes/llvm/machineinstr">MachineInstr</a> &amp; MI)</>}>
Harden a load by hardening the loaded value in the defined register.

We can harden a non-leaking load into a register without touching the address by just hiding all of the loaded bits during misspeculation. We use an <code>or</code> instruction to do this because we set up our poison value as all ones. And the goal is just for the loaded bits to not be exposed to execution and coercing them to one is sufficient.

Returns the newly hardened register.

Definition at line <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp/#l00205">205</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp">X86SpeculativeLoadHardening.cpp</a>.
</MemberDefinition>

### hardenReturnInstr() {#a79aa2da36f644b0a5894e49159921fe7}

<MemberDefinition
  prototype={<>void X86SpeculativeLoadHardeningPass::hardenReturnInstr (<a href="/docs/api/classes/llvm/machineinstr">MachineInstr</a> &amp; MI)</>}>
Harden a return instruction.

Returns implicitly perform a load which we need to harden. Without hardening this load, an attacker my speculatively write over the return address to steer speculation of the return to an attacker controlled address. This is called Spectre v1.1 or Bounds Check Bypass Store (BCBS) and is described in this paper: <a href="https://people.csail.mit.edu/vlk/spectre11.pdf">https://people.csail.mit.edu/vlk/spectre11.pdf</a>

We can harden this by introducing an LFENCE that will delay any load of the return address until prior instructions have retired (and thus are not being speculated), or we can harden the address used by the implicit load: the stack pointer.

If we are not using an LFENCE, hardening the stack pointer has an additional benefit: it allows us to pass the predicate state accumulated in this function back to the caller. In the absence of a BCBS attack on the return, the caller will typically be resumed and speculatively executed due to the Return Stack Buffer (RSB) prediction which is very accurate and has a high priority. It is possible that some code from the caller will be executed speculatively even during a BCBS-attacked return until the steering takes effect. Whenever this happens, the caller can recover the (poisoned) predicate state from the stack pointer and continue to harden loads.

Definition at line <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp/#l00206">206</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp">X86SpeculativeLoadHardening.cpp</a>.
</MemberDefinition>

### hardenValueInRegister() {#a6192a88ae0ffb9aae6d2777f03bc2051}

<MemberDefinition
  prototype={<>unsigned X86SpeculativeLoadHardeningPass::hardenValueInRegister (<a href="/docs/api/classes/llvm/register">Register</a> Reg, <a href="/docs/api/classes/llvm/machinebasicblock">MachineBasicBlock</a> &amp; MBB, <a href="/docs/api/classes/llvm/machinebasicblock/#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a> InsertPt, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/classes/llvm/debugloc">DebugLoc</a> &amp; Loc)</>}>
Harden a value in a register.

This is the low-level logic to fully harden a value sitting in a register against leaking during speculative execution.

Unlike hardening an address that is used by a load, this routine is required to hide <em>all</em> incoming bits in the register.

<code>Reg</code> must be a virtual register. Currently, it is required to be a GPR no larger than the predicate state register. FIXME: We should support vector registers here by broadcasting the predicate state.

The new, hardened virtual register is returned. It will have the same register class as <code>Reg</code>.

Definition at line <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp/#l00202">202</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp">X86SpeculativeLoadHardening.cpp</a>.
</MemberDefinition>

### mergePredStateIntoSP() {#a6bf98c3ecbac31ed744d67bd7e1fd6ba}

<MemberDefinition
  prototype={<>void X86SpeculativeLoadHardeningPass::mergePredStateIntoSP (<a href="/docs/api/classes/llvm/machinebasicblock">MachineBasicBlock</a> &amp; MBB, <a href="/docs/api/classes/llvm/machinebasicblock/#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a> InsertPt, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/classes/llvm/debugloc">DebugLoc</a> &amp; Loc, unsigned PredStateReg)</>}>
Takes the current predicate state (in a register) and merges it into the stack pointer.

The state is essentially a single bit, but we merge this in a way that won&#39;t form non-canonical pointers and also will be preserved across normal stack adjustments.

Definition at line <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp/#l00187">187</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp">X86SpeculativeLoadHardening.cpp</a>.
</MemberDefinition>

### restoreEFLAGS() {#a57fe992bc7311068a5e174e5115345e5}

<MemberDefinition
  prototype={<>void X86SpeculativeLoadHardeningPass::restoreEFLAGS (<a href="/docs/api/classes/llvm/machinebasicblock">MachineBasicBlock</a> &amp; MBB, <a href="/docs/api/classes/llvm/machinebasicblock/#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a> InsertPt, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/classes/llvm/debugloc">DebugLoc</a> &amp; Loc, <a href="/docs/api/classes/llvm/register">Register</a> Reg)</>}>
Restore EFLAGS from the provided GPR.

This should be produced by <code>saveEFLAGS</code>.

This must be done within the same basic block as the save in order to reliably lower.

Definition at line <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp/#l00183">183</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp">X86SpeculativeLoadHardening.cpp</a>.
</MemberDefinition>

### saveEFLAGS() {#a51c88fadd2d858ca48009266fa4f9e20}

<MemberDefinition
  prototype={<>unsigned X86SpeculativeLoadHardeningPass::saveEFLAGS (<a href="/docs/api/classes/llvm/machinebasicblock">MachineBasicBlock</a> &amp; MBB, <a href="/docs/api/classes/llvm/machinebasicblock/#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a> InsertPt, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64promoteconstant-cpp/#a90f8350fecae261c25be85d38b451bff">const</a> <a href="/docs/api/classes/llvm/debugloc">DebugLoc</a> &amp; Loc)</>}>
Save EFLAGS into the returned GPR.

This can in turn be restored with <code>restoreEFLAGS</code>.

Note that LLVM can only lower very simple patterns of saved and restored EFLAGS registers. The restore should always be within the same basic block as the save so that no PHI nodes are inserted.

Definition at line <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp/#l00180">180</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp">X86SpeculativeLoadHardening.cpp</a>.
</MemberDefinition>

### sinkPostLoadHardenedInst() {#a4a2590a4dd70cb8fc910e778999a149d}

<MemberDefinition
  prototype={<>MachineInstr &#42; X86SpeculativeLoadHardeningPass::sinkPostLoadHardenedInst (<a href="/docs/api/classes/llvm/machineinstr">MachineInstr</a> &amp; MI, <a href="/docs/api/classes/llvm/smallptrsetimpl">SmallPtrSetImpl</a>&lt; <a href="/docs/api/classes/llvm/machineinstr">MachineInstr</a> &#42; &gt; &amp; HardenedInstrs)</>}>

Definition at line <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp/#l00199">199</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp">X86SpeculativeLoadHardening.cpp</a>.
</MemberDefinition>

### tracePredStateThroughBlocksAndHarden() {#a83e6c452f7fdc25aeff4b8d56ffa68f2}

<MemberDefinition
  prototype={<>void X86SpeculativeLoadHardeningPass::tracePredStateThroughBlocksAndHarden (<a href="/docs/api/classes/llvm/machinefunction">MachineFunction</a> &amp; MF)</>}>
<a href="/docs/api/classes/llvm/trace">Trace</a> the predicate state through each of the blocks in the function, hardening everything necessary along the way.

We call this routine once the initial predicate state has been established for each basic block in the function in the SSA updater. This routine traces it through the instructions within each basic block, and for non-returning blocks informs the SSA updater about the final state that lives out of the block. Along the way, it hardens any vulnerable instruction using the currently valid predicate state. We have to do these two things together because the SSA updater only works across blocks. Within a block, we track the current predicate state directly and update it as it changes.

This operates in two passes over each block. First, we analyze the loads in the block to determine which strategy will be used to harden them: hardening the address or hardening the loaded value when loaded into a register amenable to hardening. We have to process these first because the two strategies may interact – later hardening may change what strategy we wish to use. We also will analyze data dependencies between loads and avoid hardening those loads that are data dependent on a load with a hardened address. We also skip hardening loads already behind an LFENCE as that is sufficient to harden them against misspeculation.

Second, we actively trace the predicate state through the block, applying the hardening steps we determined necessary in the first pass as we go.

These two passes are applied to each basic block. We operate one block at a time to simplify reasoning about reachability and sequencing.

Definition at line <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp/#l00178">178</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp">X86SpeculativeLoadHardening.cpp</a>.
</MemberDefinition>

### tracePredStateThroughCall() {#a9e3bcfd049a584052d380b5b9f6d5910}

<MemberDefinition
  prototype={<>void X86SpeculativeLoadHardeningPass::tracePredStateThroughCall (<a href="/docs/api/classes/llvm/machineinstr">MachineInstr</a> &amp; MI)</>}>
<a href="/docs/api/classes/llvm/trace">Trace</a> the predicate state through a call.

There are several layers of this needed to handle the full complexity of calls.

First, we need to send the predicate state into the called function. We do this by merging it into the high bits of the stack pointer.

For tail calls, this is all we need to do.

For calls where we might return and resume the control flow, we need to extract the predicate state from the high bits of the stack pointer after control returns from the called function.

We also need to verify that we intended to return to this location in the code. An attacker might arrange for the processor to mispredict the return to this valid but incorrect return address in the program rather than the correct one. See the paper on this attack, called &quot;ret2spec&quot; by the researchers, here: <a href="https://christian-rossow.de/publications/ret2spec-ccs2018.pdf">https://christian-rossow.de/publications/ret2spec-ccs2018.pdf</a>

The way we verify that we returned to the correct location is by preserving the expected return address across the call. One technique involves taking advantage of the red-zone to load the return address from <code>8(rsp)</code> where it was left by the RET instruction when it popped <code>rsp</code>. Alternatively, we can directly save the address into a register that will be preserved across the call. We compare this intended return address against the address immediately following the call (the observed return address). If these mismatch, we have detected misspeculation and can poison our predicate state.

Definition at line <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp/#l00207">207</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp">X86SpeculativeLoadHardening.cpp</a>.
</MemberDefinition>

### tracePredStateThroughCFG() {#a561226da60bb592263645c4c2221e2b3}

<MemberDefinition
  prototype={<>SmallVector&lt; MachineInstr &#42;, 16 &gt; X86SpeculativeLoadHardeningPass::tracePredStateThroughCFG (<a href="/docs/api/classes/llvm/machinefunction">MachineFunction</a> &amp; MF, <a href="/docs/api/classes/llvm/arrayref">ArrayRef</a>&lt; BlockCondInfo &gt; Infos)</>}>
<a href="/docs/api/classes/llvm/trace">Trace</a> the predicate state through the CFG, instrumenting each conditional branch such that misspeculation through an edge will poison the predicate state.

Returns the list of inserted CMov instructions so that they can have their uses of the predicate state rewritten into proper SSA form once it is complete.

Definition at line <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp/#l00171">171</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp">X86SpeculativeLoadHardening.cpp</a>.
</MemberDefinition>

### tracePredStateThroughIndirectBranches() {#a99e2041e476780454dd8421e1ba23bca}

<MemberDefinition
  prototype={<>SmallVector&lt; MachineInstr &#42;, 16 &gt; X86SpeculativeLoadHardeningPass::tracePredStateThroughIndirectBranches (<a href="/docs/api/classes/llvm/machinefunction">MachineFunction</a> &amp; MF)</>}>
<a href="/docs/api/classes/llvm/trace">Trace</a> the predicate state through indirect branches, instrumenting them to poison the state if a target is reached that does not match the expected target.

This is designed to mitigate Spectre variant 1 attacks where an indirect branch is trained to predict a particular target and then mispredicts that target in a way that can leak data. Despite using an indirect branch, this is really a variant 1 style attack: it does not steer execution to an arbitrary or attacker controlled address, and it does not require any special code executing next to the victim. This attack can also be mitigated through retpolines, but those require either replacing indirect branches with conditional direct branches or lowering them through a device that blocks speculation. This mitigation can replace these retpoline-style mitigations for jump tables and other indirect branches within a function when variant 2 isn&#39;t a risk while allowing limited speculation. Indirect calls, however, cannot be mitigated through this technique without changing the ABI in a fundamental way.

Definition at line <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp/#l00176">176</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp">X86SpeculativeLoadHardening.cpp</a>.
</MemberDefinition>

### unfoldCallAndJumpLoads() {#abb1705e42db56a885ff72109bae739a5}

<MemberDefinition
  prototype={<>void X86SpeculativeLoadHardeningPass::unfoldCallAndJumpLoads (<a href="/docs/api/classes/llvm/machinefunction">MachineFunction</a> &amp; MF)</>}>

Definition at line <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp/#l00173">173</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp">X86SpeculativeLoadHardening.cpp</a>.
</MemberDefinition>

</SectionDefinition>

<SectionDefinition>

## Private Member Attributes

### MRI {#a455d25db0312916c89c3b89268a74736}

<MemberDefinition
  prototype={<>MachineRegisterInfo&#42; anonymous&#95;namespace&#123;X86SpeculativeLoadHardening.cpp&#125;::X86SpeculativeLoadHardeningPass::MRI = nullptr</>}>

Definition at line <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp/#l00160">160</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp">X86SpeculativeLoadHardening.cpp</a>.
</MemberDefinition>

### PS {#ac90994b9a84a001b8c9e5ee90630e184}

<MemberDefinition
  prototype={<>std::optional&lt;PredState&gt; anonymous&#95;namespace&#123;X86SpeculativeLoadHardening.cpp&#125;::X86SpeculativeLoadHardeningPass::PS</>}>

Definition at line <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp/#l00164">164</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp">X86SpeculativeLoadHardening.cpp</a>.
</MemberDefinition>

### Subtarget {#ab6d274b65a12e504061a83af5e701001}

<MemberDefinition
  prototype={<>const X86Subtarget&#42; anonymous&#95;namespace&#123;X86SpeculativeLoadHardening.cpp&#125;::X86SpeculativeLoadHardeningPass::Subtarget = nullptr</>}>

Definition at line <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp/#l00159">159</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp">X86SpeculativeLoadHardening.cpp</a>.
</MemberDefinition>

### TII {#ab25b96ceead471840bc2c0bf4ea9d504}

<MemberDefinition
  prototype={<>const X86InstrInfo&#42; anonymous&#95;namespace&#123;X86SpeculativeLoadHardening.cpp&#125;::X86SpeculativeLoadHardeningPass::TII = nullptr</>}>

Definition at line <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp/#l00161">161</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp">X86SpeculativeLoadHardening.cpp</a>.
</MemberDefinition>

### TRI {#a0d888e74c1090f8752b50cbaa7e9e6b8}

<MemberDefinition
  prototype={<>const TargetRegisterInfo&#42; anonymous&#95;namespace&#123;X86SpeculativeLoadHardening.cpp&#125;::X86SpeculativeLoadHardeningPass::TRI = nullptr</>}>

Definition at line <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp/#l00162">162</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp">X86SpeculativeLoadHardening.cpp</a>.
</MemberDefinition>

</SectionDefinition>

<SectionDefinition>

## Public Static Attributes

### ID {#a845bb9b2068e7fd8052fc0e53ed461e5}

<MemberDefinition
  prototype="char X86SpeculativeLoadHardeningPass::ID = 0"
  labels = {["static"]}>
Pass identification, replacement for typeid.

Definition at line <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp/#l00132">132</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp">X86SpeculativeLoadHardening.cpp</a>.
</MemberDefinition>

</SectionDefinition>

<hr/>

The documentation for this class was generated from the following file:

<ul>
<li><a href="/docs/api/files/lib/lib/target/lib/target/x86/x86speculativeloadhardening-cpp">X86SpeculativeLoadHardening.cpp</a></li>
</ul>

</DoxygenPage>
