---

# DO NOT EDIT!
# Automatically generated via docusaurus-plugin-doxygen by Doxygen.

slug: /api/files/lib/lib/target/lib/target/aarch64/aarch64expandimm-cpp
custom_edit_url: null
keywords:
  - doxygen
  - reference
  - file

---

import Link from '@docusaurus/Link'

import CodeLine from '@xpack/docusaurus-plugin-doxygen/components/CodeLine'
import DoxygenPage from '@xpack/docusaurus-plugin-doxygen/components/DoxygenPage'
import IncludesList from '@xpack/docusaurus-plugin-doxygen/components/IncludesList'
import IncludesListItem from '@xpack/docusaurus-plugin-doxygen/components/IncludesListItem'
import MemberDefinition from '@xpack/docusaurus-plugin-doxygen/components/MemberDefinition'
import MembersIndex from '@xpack/docusaurus-plugin-doxygen/components/MembersIndex'
import MembersIndexItem from '@xpack/docusaurus-plugin-doxygen/components/MembersIndexItem'
import ProgramListing from '@xpack/docusaurus-plugin-doxygen/components/ProgramListing'
import SectionDefinition from '@xpack/docusaurus-plugin-doxygen/components/SectionDefinition'

import pluginConfig from '@site/docusaurus-plugin-doxygen-config.json'

# The `AArch64ExpandImm.cpp` File Reference

<DoxygenPage pluginConfig={pluginConfig}>



## Included Headers

<IncludesList>
<IncludesListItem
  filePath="AArch64.h"
  permalink="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64-h"
  isLocal="true" />
<IncludesListItem
  filePath="AArch64ExpandImm.h"
  permalink="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64expandimm-h"
  isLocal="true" />
<IncludesListItem
  filePath="MCTargetDesc/AArch64AddressingModes.h"
  permalink="/docs/api/files/lib/lib/target/lib/target/aarch64/lib/target/aarch64/mctargetdesc/aarch64addressingmodes-h"
  isLocal="true" />
</IncludesList>

## Functions Index

<MembersIndex>

<MembersIndexItem
  type="bool"
  name={<><a href="#a436cd44154cf245c297b6b5a5fac9a84">canUseOrr</a> (uint64&#95;t Chunk, uint64&#95;t &amp;Encoding)</>}>
<a href="/docs/api/namespaces/llvm/check">Check</a> whether the given 16-bit chunk replicated to full 64-bit width can be materialized with an ORR instruction. <a href="#a436cd44154cf245c297b6b5a5fac9a84">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<>std::optional&lt; std::pair&lt; uint64&#95;t, uint64&#95;t &gt; &gt;</>}
  name={<><a href="#aeb71b2a77bd02c4e0e01aecf2d392452">decomposeIntoOrrOfLogicalImmediates</a> (uint64&#95;t UImm)</>}>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#a2edf9e8f09bfb0cc4949aa1813872322">expandMOVImmSimple</a> (uint64&#95;t Imm, unsigned BitSize, unsigned OneChunks, unsigned ZeroChunks, SmallVectorImpl&lt; ImmInsnModel &gt; &amp;Insn)</>}>
Expand a MOVi32imm or MOVi64imm pseudo instruction to a MOVZ or MOVN of width BitSize followed by up to 3 MOVK instructions. <a href="#a2edf9e8f09bfb0cc4949aa1813872322">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<>uint64&#95;t</>}
  name={<><a href="#aa5bbae3632b4bfe0de4faea7a4da829f">getChunk</a> (uint64&#95;t Imm, unsigned ChunkIdx)</>}>
Helper function which extracts the specified 16-bit chunk from a 64-bit value. <a href="#aa5bbae3632b4bfe0de4faea7a4da829f">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<>uint64&#95;t</>}
  name={<><a href="#a2e2936fed450c145238eeca56cf4572e">GetRunOfOnesStartingAt</a> (uint64&#95;t V, uint64&#95;t StartPosition)</>}>
</MembersIndexItem>

<MembersIndexItem
  type="bool"
  name={<><a href="#add895e8580b9acacceb10b92edcd4d37">isEndChunk</a> (uint64&#95;t Chunk)</>}>
<a href="/docs/api/namespaces/llvm/check">Check</a> whether this chunk matches the pattern &#39;0...1...&#39; This pattern ends a contiguous sequence of ones if we look at the bits from the LSB towards the MSB. <a href="#add895e8580b9acacceb10b92edcd4d37">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="bool"
  name={<><a href="#ad84ff3d34cc228b799e8bc2f070fc4ab">isStartChunk</a> (uint64&#95;t Chunk)</>}>
<a href="/docs/api/namespaces/llvm/check">Check</a> whether this chunk matches the pattern &#39;1...0...&#39;. <a href="#ad84ff3d34cc228b799e8bc2f070fc4ab">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<>uint64&#95;t</>}
  name={<><a href="#ad62d9bcb5891de134deb4465831a762b">maximalLogicalImmWithin</a> (uint64&#95;t RemainingBits, uint64&#95;t OriginalBits)</>}>
</MembersIndexItem>

<MembersIndexItem
  type={<>uint64&#95;t</>}
  name={<><a href="#a78822aec5f2ccbac50c2b2ac068dc7d7">MaximallyReplicateSubImmediate</a> (uint64&#95;t V, uint64&#95;t Subset)</>}>
</MembersIndexItem>

<MembersIndexItem
  type="bool"
  name={<><a href="#aa20f3eb24c28efa9c93053a733a172c1">tryAndOfLogicalImmediates</a> (uint64&#95;t UImm, SmallVectorImpl&lt; ImmInsnModel &gt; &amp;Insn)</>}>
</MembersIndexItem>

<MembersIndexItem
  type="bool"
  name={<><a href="#ab2f723b31c9dbe46610248a047805046">tryEorOfLogicalImmediates</a> (uint64&#95;t Imm, SmallVectorImpl&lt; ImmInsnModel &gt; &amp;Insn)</>}>
</MembersIndexItem>

<MembersIndexItem
  type="bool"
  name={<><a href="#ae492dde0ae62ef0c16a80f8b648bae19">tryOrrOfLogicalImmediates</a> (uint64&#95;t UImm, SmallVectorImpl&lt; ImmInsnModel &gt; &amp;Insn)</>}>
</MembersIndexItem>

<MembersIndexItem
  type="bool"
  name={<><a href="#a7000ac817f63a64697020f0538311927">trySequenceOfOnes</a> (uint64&#95;t UImm, SmallVectorImpl&lt; ImmInsnModel &gt; &amp;Insn)</>}>
<a href="/docs/api/namespaces/llvm/check">Check</a> whether the constant contains a sequence of contiguous ones, which might be interrupted by one or two chunks. <a href="#a7000ac817f63a64697020f0538311927">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="bool"
  name={<><a href="#a6efd5b30fe34a042d2937ba63a73ad07">tryToreplicateChunks</a> (uint64&#95;t UImm, SmallVectorImpl&lt; ImmInsnModel &gt; &amp;Insn)</>}>
<a href="/docs/api/namespaces/llvm/check">Check</a> for identical 16-bit chunks within the constant and if so materialize them with a single ORR instruction. <a href="#a6efd5b30fe34a042d2937ba63a73ad07">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<>uint64&#95;t</>}
  name={<><a href="#a4323e3fa0f558ea22393bc68e9520b27">updateImm</a> (uint64&#95;t Imm, unsigned Idx, bool Clear)</>}>
Clear or set all bits in the chunk at the given index. <a href="#a4323e3fa0f558ea22393bc68e9520b27">More...</a>
</MembersIndexItem>

</MembersIndex>


<SectionDefinition>

## Functions

### canUseOrr() {#a436cd44154cf245c297b6b5a5fac9a84}

<MemberDefinition
  prototype={<>static bool canUseOrr (uint64&#95;t Chunk, uint64&#95;t &amp; Encoding)</>}
  labels = {["static"]}>
<a href="/docs/api/namespaces/llvm/check">Check</a> whether the given 16-bit chunk replicated to full 64-bit width can be materialized with an ORR instruction.

Definition at line <a href="#l00030">30</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64expandimm-cpp">AArch64ExpandImm.cpp</a>.
</MemberDefinition>

### decomposeIntoOrrOfLogicalImmediates() {#aeb71b2a77bd02c4e0e01aecf2d392452}

<MemberDefinition
  prototype={<>static std::optional&lt; std::pair&lt; uint64&#95;t, uint64&#95;t &gt; &gt; decomposeIntoOrrOfLogicalImmediates (uint64&#95;t UImm)</>}
  labels = {["static"]}>

Definition at line <a href="#l00288">288</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64expandimm-cpp">AArch64ExpandImm.cpp</a>.
</MemberDefinition>

### expandMOVImmSimple() {#a2edf9e8f09bfb0cc4949aa1813872322}

<MemberDefinition
  prototype={<>static void expandMOVImmSimple (uint64&#95;t Imm, unsigned BitSize, unsigned OneChunks, unsigned ZeroChunks, <a href="/docs/api/classes/llvm/smallvectorimpl">SmallVectorImpl</a>&lt; <a href="/docs/api/structs/llvm/aarch64-imm/imminsnmodel">ImmInsnModel</a> &gt; &amp; Insn)</>}
  labels = {["inline", "static"]}>
Expand a MOVi32imm or MOVi64imm pseudo instruction to a MOVZ or MOVN of width BitSize followed by up to 3 MOVK instructions.

Definition at line <a href="#l00466">466</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64expandimm-cpp">AArch64ExpandImm.cpp</a>.
</MemberDefinition>

### getChunk() {#aa5bbae3632b4bfe0de4faea7a4da829f}

<MemberDefinition
  prototype={<>static uint64&#95;t getChunk (uint64&#95;t Imm, unsigned ChunkIdx)</>}
  labels = {["static"]}>
Helper function which extracts the specified 16-bit chunk from a 64-bit value.

Definition at line <a href="#l00022">22</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64expandimm-cpp">AArch64ExpandImm.cpp</a>.
</MemberDefinition>

### GetRunOfOnesStartingAt() {#a2e2936fed450c145238eeca56cf4572e}

<MemberDefinition
  prototype={<>static uint64&#95;t GetRunOfOnesStartingAt (uint64&#95;t V, uint64&#95;t StartPosition)</>}
  labels = {["static"]}>

Definition at line <a href="#l00242">242</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64expandimm-cpp">AArch64ExpandImm.cpp</a>.
</MemberDefinition>

### isEndChunk() {#add895e8580b9acacceb10b92edcd4d37}

<MemberDefinition
  prototype={<>static bool isEndChunk (uint64&#95;t Chunk)</>}
  labels = {["static"]}>
<a href="/docs/api/namespaces/llvm/check">Check</a> whether this chunk matches the pattern &#39;0...1...&#39; This pattern ends a contiguous sequence of ones if we look at the bits from the LSB towards the MSB.

Definition at line <a href="#l00116">116</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64expandimm-cpp">AArch64ExpandImm.cpp</a>.
</MemberDefinition>

### isStartChunk() {#ad84ff3d34cc228b799e8bc2f070fc4ab}

<MemberDefinition
  prototype={<>static bool isStartChunk (uint64&#95;t Chunk)</>}
  labels = {["static"]}>
<a href="/docs/api/namespaces/llvm/check">Check</a> whether this chunk matches the pattern &#39;1...0...&#39;.

This pattern starts a contiguous sequence of ones if we look at the bits from the LSB towards the MSB.

Definition at line <a href="#l00106">106</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64expandimm-cpp">AArch64ExpandImm.cpp</a>.
</MemberDefinition>

### maximalLogicalImmWithin() {#ad62d9bcb5891de134deb4465831a762b}

<MemberDefinition
  prototype={<>static uint64&#95;t maximalLogicalImmWithin (uint64&#95;t RemainingBits, uint64&#95;t OriginalBits)</>}
  labels = {["static"]}>

Definition at line <a href="#l00272">272</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64expandimm-cpp">AArch64ExpandImm.cpp</a>.
</MemberDefinition>

### MaximallyReplicateSubImmediate() {#a78822aec5f2ccbac50c2b2ac068dc7d7}

<MemberDefinition
  prototype={<>static uint64&#95;t MaximallyReplicateSubImmediate (uint64&#95;t V, uint64&#95;t Subset)</>}
  labels = {["static"]}>

Definition at line <a href="#l00254">254</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64expandimm-cpp">AArch64ExpandImm.cpp</a>.
</MemberDefinition>

### tryAndOfLogicalImmediates() {#aa20f3eb24c28efa9c93053a733a172c1}

<MemberDefinition
  prototype={<>static bool tryAndOfLogicalImmediates (uint64&#95;t UImm, <a href="/docs/api/classes/llvm/smallvectorimpl">SmallVectorImpl</a>&lt; <a href="/docs/api/structs/llvm/aarch64-imm/imminsnmodel">ImmInsnModel</a> &gt; &amp; Insn)</>}
  labels = {["static"]}>

Definition at line <a href="#l00341">341</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64expandimm-cpp">AArch64ExpandImm.cpp</a>.
</MemberDefinition>

### tryEorOfLogicalImmediates() {#ab2f723b31c9dbe46610248a047805046}

<MemberDefinition
  prototype={<>static bool tryEorOfLogicalImmediates (uint64&#95;t Imm, <a href="/docs/api/classes/llvm/smallvectorimpl">SmallVectorImpl</a>&lt; <a href="/docs/api/structs/llvm/aarch64-imm/imminsnmodel">ImmInsnModel</a> &gt; &amp; Insn)</>}
  labels = {["static"]}>

Definition at line <a href="#l00373">373</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64expandimm-cpp">AArch64ExpandImm.cpp</a>.
</MemberDefinition>

### tryOrrOfLogicalImmediates() {#ae492dde0ae62ef0c16a80f8b648bae19}

<MemberDefinition
  prototype={<>static bool tryOrrOfLogicalImmediates (uint64&#95;t UImm, <a href="/docs/api/classes/llvm/smallvectorimpl">SmallVectorImpl</a>&lt; <a href="/docs/api/structs/llvm/aarch64-imm/imminsnmodel">ImmInsnModel</a> &gt; &amp; Insn)</>}
  labels = {["static"]}>

Definition at line <a href="#l00316">316</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64expandimm-cpp">AArch64ExpandImm.cpp</a>.
</MemberDefinition>

### trySequenceOfOnes() {#a7000ac817f63a64697020f0538311927}

<MemberDefinition
  prototype={<>static bool trySequenceOfOnes (uint64&#95;t UImm, <a href="/docs/api/classes/llvm/smallvectorimpl">SmallVectorImpl</a>&lt; <a href="/docs/api/structs/llvm/aarch64-imm/imminsnmodel">ImmInsnModel</a> &gt; &amp; Insn)</>}
  labels = {["static"]}>
<a href="/docs/api/namespaces/llvm/check">Check</a> whether the constant contains a sequence of contiguous ones, which might be interrupted by one or two chunks.

If so, materialize the sequence of contiguous ones with an ORR instruction. Materialize the chunks which are either interrupting the sequence or outside of the sequence with a MOVK instruction.

Assuming S is a chunk which starts the sequence (1...0...), E is a chunk which ends the sequence (0...1...). Then we are looking for constants which contain at least one S and E chunk. E.g. |E|A|B|S|, |A|E|B|S| or |A|B|E|S|.

We are also looking for constants like |S|A|B|E| where the contiguous sequence of ones wraps around the MSB into the LSB.

Definition at line <a href="#l00150">150</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64expandimm-cpp">AArch64ExpandImm.cpp</a>.
</MemberDefinition>

### tryToreplicateChunks() {#a6efd5b30fe34a042d2937ba63a73ad07}

<MemberDefinition
  prototype={<>static bool tryToreplicateChunks (uint64&#95;t UImm, <a href="/docs/api/classes/llvm/smallvectorimpl">SmallVectorImpl</a>&lt; <a href="/docs/api/structs/llvm/aarch64-imm/imminsnmodel">ImmInsnModel</a> &gt; &amp; Insn)</>}
  labels = {["static"]}>
<a href="/docs/api/namespaces/llvm/check">Check</a> for identical 16-bit chunks within the constant and if so materialize them with a single ORR instruction.

The remaining one or two 16-bit chunks will be materialized with MOVK instructions.

This allows us to materialize constants like |A|B|A|A| or |A|B|C|A| (order of the chunks doesn&#39;t matter), assuming |A|A|A|A| can be materialized with an ORR instruction.

Definition at line <a href="#l00043">43</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64expandimm-cpp">AArch64ExpandImm.cpp</a>.
</MemberDefinition>

### updateImm() {#a4323e3fa0f558ea22393bc68e9520b27}

<MemberDefinition
  prototype={<>static uint64&#95;t updateImm (uint64&#95;t Imm, unsigned Idx, bool Clear)</>}
  labels = {["static"]}>
Clear or set all bits in the chunk at the given index.

Definition at line <a href="#l00124">124</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64expandimm-cpp">AArch64ExpandImm.cpp</a>.
</MemberDefinition>

</SectionDefinition>

## File Listing

The file content with the documentation metadata removed is:

<ProgramListing>

<Link id="l00001" /><CodeLine lineNumber="1"><span class="doxyHighlightComment">//===- AArch64ExpandImm.h - AArch64 Immediate Expansion -------------------===//</span></CodeLine>
<Link id="l00002" /><CodeLine lineNumber="2"><span class="doxyHighlightComment">//</span></CodeLine>
<Link id="l00003" /><CodeLine lineNumber="3"><span class="doxyHighlightComment">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</span></CodeLine>
<Link id="l00004" /><CodeLine lineNumber="4"><span class="doxyHighlightComment">// See https://llvm.org/LICENSE.txt for license information.</span></CodeLine>
<Link id="l00005" /><CodeLine lineNumber="5"><span class="doxyHighlightComment">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</span></CodeLine>
<Link id="l00006" /><CodeLine lineNumber="6"><span class="doxyHighlightComment">//</span></CodeLine>
<Link id="l00007" /><CodeLine lineNumber="7"><span class="doxyHighlightComment">//===----------------------------------------------------------------------===//</span></CodeLine>
<Link id="l00008" /><CodeLine lineNumber="8"><span class="doxyHighlightComment">//</span></CodeLine>
<Link id="l00009" /><CodeLine lineNumber="9"><span class="doxyHighlightComment">// This file implements the AArch64ExpandImm stuff.</span></CodeLine>
<Link id="l00010" /><CodeLine lineNumber="10"><span class="doxyHighlightComment">//</span></CodeLine>
<Link id="l00011" /><CodeLine lineNumber="11"><span class="doxyHighlightComment">//===----------------------------------------------------------------------===//</span></CodeLine>
<Link id="l00012" /><CodeLine lineNumber="12"></CodeLine>
<Link id="l00013" /><CodeLine lineNumber="13"><span class="doxyHighlightPreprocessor">#include &quot;<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64-h">AArch64.h</a>&quot;</span></CodeLine>
<Link id="l00014" /><CodeLine lineNumber="14"><span class="doxyHighlightPreprocessor">#include &quot;<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64expandimm-h">AArch64ExpandImm.h</a>&quot;</span></CodeLine>
<Link id="l00015" /><CodeLine lineNumber="15"><span class="doxyHighlightPreprocessor">#include &quot;<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/lib/target/aarch64/mctargetdesc/aarch64addressingmodes-h">MCTargetDesc/AArch64AddressingModes.h</a>&quot;</span></CodeLine>
<Link id="l00016" /><CodeLine lineNumber="16"></CodeLine>
<Link id="l00017" /><CodeLine lineNumber="17"><span class="doxyHighlightKeyword">using namespace </span><span class="doxyHighlight"><a href="/docs/api/namespaces/llvm">llvm</a>;</span></CodeLine>
<Link id="l00018" /><CodeLine lineNumber="18"><span class="doxyHighlightKeyword">using namespace </span><span class="doxyHighlight"><a href="/docs/api/namespaces/llvm/aarch64-imm">llvm::AArch64&#95;IMM</a>;</span></CodeLine>
<Link id="l00019" /><CodeLine lineNumber="19"></CodeLine>
<Link id="l00020" /><CodeLine lineNumber="20"><span class="doxyHighlightComment">/// Helper function which extracts the specified 16-bit chunk from a</span></CodeLine>
<Link id="l00021" /><CodeLine lineNumber="21"><span class="doxyHighlightComment">/// 64-bit value.</span></CodeLine>
<Link id="l00022" /><CodeLine lineNumber="22" lineLink="#aa5bbae3632b4bfe0de4faea7a4da829f"><span class="doxyHighlightKeyword">static</span><span class="doxyHighlight"> uint64&#95;t <a href="#aa5bbae3632b4bfe0de4faea7a4da829f">getChunk</a>(uint64&#95;t Imm, </span><span class="doxyHighlightKeywordType">unsigned</span><span class="doxyHighlight"> ChunkIdx) &#123;</span></CodeLine>
<Link id="l00023" /><CodeLine lineNumber="23"><span class="doxyHighlight">  <a href="/docs/api/files/lib/lib/target/lib/target/amdgpu/silowercontrolflow-cpp/#a4868c5d81c5ccc98c47aeab6244346a0">assert</a>(ChunkIdx &lt; 4 &amp;&amp; </span><span class="doxyHighlightStringLiteral">&quot;Out of range chunk index specified!&quot;</span><span class="doxyHighlight">);</span></CodeLine>
<Link id="l00024" /><CodeLine lineNumber="24"></CodeLine>
<Link id="l00025" /><CodeLine lineNumber="25"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">return</span><span class="doxyHighlight"> (Imm &gt;&gt; (ChunkIdx &#42; 16)) &amp; 0xFFFF;</span></CodeLine>
<Link id="l00026" /><CodeLine lineNumber="26"><span class="doxyHighlight">&#125;</span></CodeLine>
<Link id="l00027" /><CodeLine lineNumber="27"></CodeLine>
<Link id="l00028" /><CodeLine lineNumber="28"><span class="doxyHighlightComment">/// Check whether the given 16-bit chunk replicated to full 64-bit width</span></CodeLine>
<Link id="l00029" /><CodeLine lineNumber="29"><span class="doxyHighlightComment">/// can be materialized with an ORR instruction.</span></CodeLine>
<Link id="l00030" /><CodeLine lineNumber="30" lineLink="#a436cd44154cf245c297b6b5a5fac9a84"><span class="doxyHighlightKeyword">static</span><span class="doxyHighlight"> </span><span class="doxyHighlightKeywordType">bool</span><span class="doxyHighlight"> <a href="#a436cd44154cf245c297b6b5a5fac9a84">canUseOrr</a>(uint64&#95;t Chunk, uint64&#95;t &amp;Encoding) &#123;</span></CodeLine>
<Link id="l00031" /><CodeLine lineNumber="31"><span class="doxyHighlight">  Chunk = (Chunk &lt;&lt; 48) | (Chunk &lt;&lt; 32) | (Chunk &lt;&lt; 16) | Chunk;</span></CodeLine>
<Link id="l00032" /><CodeLine lineNumber="32"></CodeLine>
<Link id="l00033" /><CodeLine lineNumber="33"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">return</span><span class="doxyHighlight"> <a href="/docs/api/namespaces/llvm/aarch64-am/#a2cd3e23b97b495a98c0b723ab18e4d96">AArch64&#95;AM::processLogicalImmediate</a>(Chunk, 64, Encoding);</span></CodeLine>
<Link id="l00034" /><CodeLine lineNumber="34"><span class="doxyHighlight">&#125;</span></CodeLine>
<Link id="l00035" /><CodeLine lineNumber="35"></CodeLine>
<Link id="l00036" /><CodeLine lineNumber="36"><span class="doxyHighlightComment">/// Check for identical 16-bit chunks within the constant and if so</span></CodeLine>
<Link id="l00037" /><CodeLine lineNumber="37"><span class="doxyHighlightComment">/// materialize them with a single ORR instruction. The remaining one or two</span></CodeLine>
<Link id="l00038" /><CodeLine lineNumber="38"><span class="doxyHighlightComment">/// 16-bit chunks will be materialized with MOVK instructions.</span></CodeLine>
<Link id="l00039" /><CodeLine lineNumber="39"><span class="doxyHighlightComment">///</span></CodeLine>
<Link id="l00040" /><CodeLine lineNumber="40"><span class="doxyHighlightComment">/// This allows us to materialize constants like |A|B|A|A| or |A|B|C|A| (order</span></CodeLine>
<Link id="l00041" /><CodeLine lineNumber="41"><span class="doxyHighlightComment">/// of the chunks doesn&#39;t matter), assuming |A|A|A|A| can be materialized with</span></CodeLine>
<Link id="l00042" /><CodeLine lineNumber="42"><span class="doxyHighlightComment">/// an ORR instruction.</span></CodeLine>
<Link id="l00043" /><CodeLine lineNumber="43" lineLink="#a6efd5b30fe34a042d2937ba63a73ad07"><span class="doxyHighlightKeyword">static</span><span class="doxyHighlight"> </span><span class="doxyHighlightKeywordType">bool</span><span class="doxyHighlight"> <a href="#a6efd5b30fe34a042d2937ba63a73ad07">tryToreplicateChunks</a>(uint64&#95;t UImm,</span></CodeLine>
<Link id="l00044" /><CodeLine lineNumber="44"><span class="doxyHighlight">         <a href="/docs/api/classes/llvm/smallvectorimpl">SmallVectorImpl&lt;ImmInsnModel&gt;</a> &amp;<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>) &#123;</span></CodeLine>
<Link id="l00045" /><CodeLine lineNumber="45"><span class="doxyHighlight">  </span><span class="doxyHighlightKeyword">using </span><span class="doxyHighlight">CountMap = <a href="/docs/api/classes/llvm/densemap">DenseMap&lt;uint64&#95;t, unsigned&gt;</a>;</span></CodeLine>
<Link id="l00046" /><CodeLine lineNumber="46"></CodeLine>
<Link id="l00047" /><CodeLine lineNumber="47"><span class="doxyHighlight">  CountMap Counts;</span></CodeLine>
<Link id="l00048" /><CodeLine lineNumber="48"></CodeLine>
<Link id="l00049" /><CodeLine lineNumber="49"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// Scan the constant and count how often every chunk occurs.</span></CodeLine>
<Link id="l00050" /><CodeLine lineNumber="50"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">for</span><span class="doxyHighlight"> (</span><span class="doxyHighlightKeywordType">unsigned</span><span class="doxyHighlight"> Idx = 0; Idx &lt; 4; ++Idx)</span></CodeLine>
<Link id="l00051" /><CodeLine lineNumber="51"><span class="doxyHighlight">    ++Counts&#91;<a href="#aa5bbae3632b4bfe0de4faea7a4da829f">getChunk</a>(UImm, Idx)&#93;;</span></CodeLine>
<Link id="l00052" /><CodeLine lineNumber="52"></CodeLine>
<Link id="l00053" /><CodeLine lineNumber="53"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// Traverse the chunks to find one which occurs more than once.</span></CodeLine>
<Link id="l00054" /><CodeLine lineNumber="54"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">for</span><span class="doxyHighlight"> (</span><span class="doxyHighlightKeyword">const</span><span class="doxyHighlight"> </span><span class="doxyHighlightKeyword">auto</span><span class="doxyHighlight"> &amp;Chunk : Counts) &#123;</span></CodeLine>
<Link id="l00055" /><CodeLine lineNumber="55"><span class="doxyHighlight">    </span><span class="doxyHighlightKeyword">const</span><span class="doxyHighlight"> uint64&#95;t ChunkVal = Chunk.first;</span></CodeLine>
<Link id="l00056" /><CodeLine lineNumber="56"><span class="doxyHighlight">    </span><span class="doxyHighlightKeyword">const</span><span class="doxyHighlight"> </span><span class="doxyHighlightKeywordType">unsigned</span><span class="doxyHighlight"> <a href="/docs/api/namespaces/llvm/#a845e08be4b0320d66901a66b0c0e9509">Count</a> = Chunk.second;</span></CodeLine>
<Link id="l00057" /><CodeLine lineNumber="57"></CodeLine>
<Link id="l00058" /><CodeLine lineNumber="58"><span class="doxyHighlight">    uint64&#95;t Encoding = 0;</span></CodeLine>
<Link id="l00059" /><CodeLine lineNumber="59"></CodeLine>
<Link id="l00060" /><CodeLine lineNumber="60"><span class="doxyHighlight">    </span><span class="doxyHighlightComment">// We are looking for chunks which have two or three instances and can be</span></CodeLine>
<Link id="l00061" /><CodeLine lineNumber="61"><span class="doxyHighlight">    </span><span class="doxyHighlightComment">// materialized with an ORR instruction.</span></CodeLine>
<Link id="l00062" /><CodeLine lineNumber="62"><span class="doxyHighlight">    </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> ((<a href="/docs/api/namespaces/llvm/#a845e08be4b0320d66901a66b0c0e9509">Count</a> != 2 &amp;&amp; <a href="/docs/api/namespaces/llvm/#a845e08be4b0320d66901a66b0c0e9509">Count</a> != 3) || !<a href="#a436cd44154cf245c297b6b5a5fac9a84">canUseOrr</a>(ChunkVal, Encoding))</span></CodeLine>
<Link id="l00063" /><CodeLine lineNumber="63"><span class="doxyHighlight">      </span><span class="doxyHighlightKeywordFlow">continue</span><span class="doxyHighlight">;</span></CodeLine>
<Link id="l00064" /><CodeLine lineNumber="64"></CodeLine>
<Link id="l00065" /><CodeLine lineNumber="65"><span class="doxyHighlight">    </span><span class="doxyHighlightKeyword">const</span><span class="doxyHighlight"> </span><span class="doxyHighlightKeywordType">bool</span><span class="doxyHighlight"> CountThree = <a href="/docs/api/namespaces/llvm/#a845e08be4b0320d66901a66b0c0e9509">Count</a> == 3;</span></CodeLine>
<Link id="l00066" /><CodeLine lineNumber="66"></CodeLine>
<Link id="l00067" /><CodeLine lineNumber="67"><span class="doxyHighlight">    <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>.push&#95;back(&#123; AArch64::ORRXri, 0, Encoding &#125;);</span></CodeLine>
<Link id="l00068" /><CodeLine lineNumber="68"></CodeLine>
<Link id="l00069" /><CodeLine lineNumber="69"><span class="doxyHighlight">    </span><span class="doxyHighlightKeywordType">unsigned</span><span class="doxyHighlight"> ShiftAmt = 0;</span></CodeLine>
<Link id="l00070" /><CodeLine lineNumber="70"><span class="doxyHighlight">    uint64&#95;t Imm16 = 0;</span></CodeLine>
<Link id="l00071" /><CodeLine lineNumber="71"><span class="doxyHighlight">    </span><span class="doxyHighlightComment">// Find the first chunk not materialized with the ORR instruction.</span></CodeLine>
<Link id="l00072" /><CodeLine lineNumber="72"><span class="doxyHighlight">    </span><span class="doxyHighlightKeywordFlow">for</span><span class="doxyHighlight"> (; ShiftAmt &lt; 64; ShiftAmt += 16) &#123;</span></CodeLine>
<Link id="l00073" /><CodeLine lineNumber="73"><span class="doxyHighlight">      Imm16 = (UImm &gt;&gt; ShiftAmt) &amp; 0xFFFF;</span></CodeLine>
<Link id="l00074" /><CodeLine lineNumber="74"></CodeLine>
<Link id="l00075" /><CodeLine lineNumber="75"><span class="doxyHighlight">      </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> (Imm16 != ChunkVal)</span></CodeLine>
<Link id="l00076" /><CodeLine lineNumber="76"><span class="doxyHighlight">        </span><span class="doxyHighlightKeywordFlow">break</span><span class="doxyHighlight">;</span></CodeLine>
<Link id="l00077" /><CodeLine lineNumber="77"><span class="doxyHighlight">    &#125;</span></CodeLine>
<Link id="l00078" /><CodeLine lineNumber="78"></CodeLine>
<Link id="l00079" /><CodeLine lineNumber="79"><span class="doxyHighlight">    </span><span class="doxyHighlightComment">// Create the first MOVK instruction.</span></CodeLine>
<Link id="l00080" /><CodeLine lineNumber="80"><span class="doxyHighlight">    <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>.push&#95;back(&#123; AArch64::MOVKXi, Imm16,</span></CodeLine>
<Link id="l00081" /><CodeLine lineNumber="81"><span class="doxyHighlight">         <a href="/docs/api/namespaces/llvm/aarch64-am/#aeae88f12b667477f90db9b726556b337">AArch64&#95;AM::getShifterImm</a>(<a href="/docs/api/namespaces/llvm/aarch64-am/#a7e75394a33f6a5897d7a14c0ba5d44f1a1d97e13eb9923037fe733eda83b7f938">AArch64&#95;AM::LSL</a>, ShiftAmt) &#125;);</span></CodeLine>
<Link id="l00082" /><CodeLine lineNumber="82"></CodeLine>
<Link id="l00083" /><CodeLine lineNumber="83"><span class="doxyHighlight">    </span><span class="doxyHighlightComment">// In case we have three instances the whole constant is now materialized</span></CodeLine>
<Link id="l00084" /><CodeLine lineNumber="84"><span class="doxyHighlight">    </span><span class="doxyHighlightComment">// and we can exit.</span></CodeLine>
<Link id="l00085" /><CodeLine lineNumber="85"><span class="doxyHighlight">    </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> (CountThree)</span></CodeLine>
<Link id="l00086" /><CodeLine lineNumber="86"><span class="doxyHighlight">      </span><span class="doxyHighlightKeywordFlow">return</span><span class="doxyHighlight"> </span><span class="doxyHighlightKeyword">true</span><span class="doxyHighlight">;</span></CodeLine>
<Link id="l00087" /><CodeLine lineNumber="87"></CodeLine>
<Link id="l00088" /><CodeLine lineNumber="88"><span class="doxyHighlight">    </span><span class="doxyHighlightComment">// Find the remaining chunk which needs to be materialized.</span></CodeLine>
<Link id="l00089" /><CodeLine lineNumber="89"><span class="doxyHighlight">    </span><span class="doxyHighlightKeywordFlow">for</span><span class="doxyHighlight"> (ShiftAmt += 16; ShiftAmt &lt; 64; ShiftAmt += 16) &#123;</span></CodeLine>
<Link id="l00090" /><CodeLine lineNumber="90"><span class="doxyHighlight">      Imm16 = (UImm &gt;&gt; ShiftAmt) &amp; 0xFFFF;</span></CodeLine>
<Link id="l00091" /><CodeLine lineNumber="91"></CodeLine>
<Link id="l00092" /><CodeLine lineNumber="92"><span class="doxyHighlight">      </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> (Imm16 != ChunkVal)</span></CodeLine>
<Link id="l00093" /><CodeLine lineNumber="93"><span class="doxyHighlight">        </span><span class="doxyHighlightKeywordFlow">break</span><span class="doxyHighlight">;</span></CodeLine>
<Link id="l00094" /><CodeLine lineNumber="94"><span class="doxyHighlight">    &#125;</span></CodeLine>
<Link id="l00095" /><CodeLine lineNumber="95"><span class="doxyHighlight">    <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>.push&#95;back(&#123; AArch64::MOVKXi, Imm16,</span></CodeLine>
<Link id="l00096" /><CodeLine lineNumber="96"><span class="doxyHighlight">                     <a href="/docs/api/namespaces/llvm/aarch64-am/#aeae88f12b667477f90db9b726556b337">AArch64&#95;AM::getShifterImm</a>(<a href="/docs/api/namespaces/llvm/aarch64-am/#a7e75394a33f6a5897d7a14c0ba5d44f1a1d97e13eb9923037fe733eda83b7f938">AArch64&#95;AM::LSL</a>, ShiftAmt) &#125;);</span></CodeLine>
<Link id="l00097" /><CodeLine lineNumber="97"><span class="doxyHighlight">    </span><span class="doxyHighlightKeywordFlow">return</span><span class="doxyHighlight"> </span><span class="doxyHighlightKeyword">true</span><span class="doxyHighlight">;</span></CodeLine>
<Link id="l00098" /><CodeLine lineNumber="98"><span class="doxyHighlight">  &#125;</span></CodeLine>
<Link id="l00099" /><CodeLine lineNumber="99"></CodeLine>
<Link id="l00100" /><CodeLine lineNumber="100"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">return</span><span class="doxyHighlight"> </span><span class="doxyHighlightKeyword">false</span><span class="doxyHighlight">;</span></CodeLine>
<Link id="l00101" /><CodeLine lineNumber="101"><span class="doxyHighlight">&#125;</span></CodeLine>
<Link id="l00102" /><CodeLine lineNumber="102"></CodeLine>
<Link id="l00103" /><CodeLine lineNumber="103"><span class="doxyHighlightComment">/// Check whether this chunk matches the pattern &#39;1...0...&#39;. This pattern</span></CodeLine>
<Link id="l00104" /><CodeLine lineNumber="104"><span class="doxyHighlightComment">/// starts a contiguous sequence of ones if we look at the bits from the LSB</span></CodeLine>
<Link id="l00105" /><CodeLine lineNumber="105"><span class="doxyHighlightComment">/// towards the MSB.</span></CodeLine>
<Link id="l00106" /><CodeLine lineNumber="106" lineLink="#ad84ff3d34cc228b799e8bc2f070fc4ab"><span class="doxyHighlightKeyword">static</span><span class="doxyHighlight"> </span><span class="doxyHighlightKeywordType">bool</span><span class="doxyHighlight"> <a href="#ad84ff3d34cc228b799e8bc2f070fc4ab">isStartChunk</a>(uint64&#95;t Chunk) &#123;</span></CodeLine>
<Link id="l00107" /><CodeLine lineNumber="107"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> (Chunk == 0 || Chunk == std::numeric&#95;limits&lt;uint64&#95;t&gt;::max())</span></CodeLine>
<Link id="l00108" /><CodeLine lineNumber="108"><span class="doxyHighlight">    </span><span class="doxyHighlightKeywordFlow">return</span><span class="doxyHighlight"> </span><span class="doxyHighlightKeyword">false</span><span class="doxyHighlight">;</span></CodeLine>
<Link id="l00109" /><CodeLine lineNumber="109"></CodeLine>
<Link id="l00110" /><CodeLine lineNumber="110"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">return</span><span class="doxyHighlight"> <a href="/docs/api/namespaces/llvm/#a82a9558b6319303ae62f59dab9669685">isMask&#95;64</a>(~Chunk);</span></CodeLine>
<Link id="l00111" /><CodeLine lineNumber="111"><span class="doxyHighlight">&#125;</span></CodeLine>
<Link id="l00112" /><CodeLine lineNumber="112"></CodeLine>
<Link id="l00113" /><CodeLine lineNumber="113"><span class="doxyHighlightComment">/// Check whether this chunk matches the pattern &#39;0...1...&#39; This pattern</span></CodeLine>
<Link id="l00114" /><CodeLine lineNumber="114"><span class="doxyHighlightComment">/// ends a contiguous sequence of ones if we look at the bits from the LSB</span></CodeLine>
<Link id="l00115" /><CodeLine lineNumber="115"><span class="doxyHighlightComment">/// towards the MSB.</span></CodeLine>
<Link id="l00116" /><CodeLine lineNumber="116" lineLink="#add895e8580b9acacceb10b92edcd4d37"><span class="doxyHighlightKeyword">static</span><span class="doxyHighlight"> </span><span class="doxyHighlightKeywordType">bool</span><span class="doxyHighlight"> <a href="#add895e8580b9acacceb10b92edcd4d37">isEndChunk</a>(uint64&#95;t Chunk) &#123;</span></CodeLine>
<Link id="l00117" /><CodeLine lineNumber="117"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> (Chunk == 0 || Chunk == std::numeric&#95;limits&lt;uint64&#95;t&gt;::max())</span></CodeLine>
<Link id="l00118" /><CodeLine lineNumber="118"><span class="doxyHighlight">    </span><span class="doxyHighlightKeywordFlow">return</span><span class="doxyHighlight"> </span><span class="doxyHighlightKeyword">false</span><span class="doxyHighlight">;</span></CodeLine>
<Link id="l00119" /><CodeLine lineNumber="119"></CodeLine>
<Link id="l00120" /><CodeLine lineNumber="120"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">return</span><span class="doxyHighlight"> <a href="/docs/api/namespaces/llvm/#a82a9558b6319303ae62f59dab9669685">isMask&#95;64</a>(Chunk);</span></CodeLine>
<Link id="l00121" /><CodeLine lineNumber="121"><span class="doxyHighlight">&#125;</span></CodeLine>
<Link id="l00122" /><CodeLine lineNumber="122"></CodeLine>
<Link id="l00123" /><CodeLine lineNumber="123"><span class="doxyHighlightComment">/// Clear or set all bits in the chunk at the given index.</span></CodeLine>
<Link id="l00124" /><CodeLine lineNumber="124" lineLink="#a4323e3fa0f558ea22393bc68e9520b27"><span class="doxyHighlightKeyword">static</span><span class="doxyHighlight"> uint64&#95;t <a href="#a4323e3fa0f558ea22393bc68e9520b27">updateImm</a>(uint64&#95;t Imm, </span><span class="doxyHighlightKeywordType">unsigned</span><span class="doxyHighlight"> Idx, </span><span class="doxyHighlightKeywordType">bool</span><span class="doxyHighlight"> Clear) &#123;</span></CodeLine>
<Link id="l00125" /><CodeLine lineNumber="125"><span class="doxyHighlight">  </span><span class="doxyHighlightKeyword">const</span><span class="doxyHighlight"> uint64&#95;t Mask = 0xFFFF;</span></CodeLine>
<Link id="l00126" /><CodeLine lineNumber="126"></CodeLine>
<Link id="l00127" /><CodeLine lineNumber="127"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> (Clear)</span></CodeLine>
<Link id="l00128" /><CodeLine lineNumber="128"><span class="doxyHighlight">    </span><span class="doxyHighlightComment">// Clear chunk in the immediate.</span></CodeLine>
<Link id="l00129" /><CodeLine lineNumber="129"><span class="doxyHighlight">    Imm &amp;= ~(Mask &lt;&lt; (Idx &#42; 16));</span></CodeLine>
<Link id="l00130" /><CodeLine lineNumber="130"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">else</span></CodeLine>
<Link id="l00131" /><CodeLine lineNumber="131"><span class="doxyHighlight">    </span><span class="doxyHighlightComment">// Set all bits in the immediate for the particular chunk.</span></CodeLine>
<Link id="l00132" /><CodeLine lineNumber="132"><span class="doxyHighlight">    Imm |= Mask &lt;&lt; (Idx &#42; 16);</span></CodeLine>
<Link id="l00133" /><CodeLine lineNumber="133"></CodeLine>
<Link id="l00134" /><CodeLine lineNumber="134"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">return</span><span class="doxyHighlight"> Imm;</span></CodeLine>
<Link id="l00135" /><CodeLine lineNumber="135"><span class="doxyHighlight">&#125;</span></CodeLine>
<Link id="l00136" /><CodeLine lineNumber="136"></CodeLine>
<Link id="l00137" /><CodeLine lineNumber="137"><span class="doxyHighlightComment">/// Check whether the constant contains a sequence of contiguous ones,</span></CodeLine>
<Link id="l00138" /><CodeLine lineNumber="138"><span class="doxyHighlightComment">/// which might be interrupted by one or two chunks. If so, materialize the</span></CodeLine>
<Link id="l00139" /><CodeLine lineNumber="139"><span class="doxyHighlightComment">/// sequence of contiguous ones with an ORR instruction.</span></CodeLine>
<Link id="l00140" /><CodeLine lineNumber="140"><span class="doxyHighlightComment">/// Materialize the chunks which are either interrupting the sequence or outside</span></CodeLine>
<Link id="l00141" /><CodeLine lineNumber="141"><span class="doxyHighlightComment">/// of the sequence with a MOVK instruction.</span></CodeLine>
<Link id="l00142" /><CodeLine lineNumber="142"><span class="doxyHighlightComment">///</span></CodeLine>
<Link id="l00143" /><CodeLine lineNumber="143"><span class="doxyHighlightComment">/// Assuming S is a chunk which starts the sequence (1...0...), E is a chunk</span></CodeLine>
<Link id="l00144" /><CodeLine lineNumber="144"><span class="doxyHighlightComment">/// which ends the sequence (0...1...). Then we are looking for constants which</span></CodeLine>
<Link id="l00145" /><CodeLine lineNumber="145"><span class="doxyHighlightComment">/// contain at least one S and E chunk.</span></CodeLine>
<Link id="l00146" /><CodeLine lineNumber="146"><span class="doxyHighlightComment">/// E.g. |E|A|B|S|, |A|E|B|S| or |A|B|E|S|.</span></CodeLine>
<Link id="l00147" /><CodeLine lineNumber="147"><span class="doxyHighlightComment">///</span></CodeLine>
<Link id="l00148" /><CodeLine lineNumber="148"><span class="doxyHighlightComment">/// We are also looking for constants like |S|A|B|E| where the contiguous</span></CodeLine>
<Link id="l00149" /><CodeLine lineNumber="149"><span class="doxyHighlightComment">/// sequence of ones wraps around the MSB into the LSB.</span></CodeLine>
<Link id="l00150" /><CodeLine lineNumber="150" lineLink="#a7000ac817f63a64697020f0538311927"><span class="doxyHighlightKeyword">static</span><span class="doxyHighlight"> </span><span class="doxyHighlightKeywordType">bool</span><span class="doxyHighlight"> <a href="#a7000ac817f63a64697020f0538311927">trySequenceOfOnes</a>(uint64&#95;t UImm,</span></CodeLine>
<Link id="l00151" /><CodeLine lineNumber="151"><span class="doxyHighlight">                              <a href="/docs/api/classes/llvm/smallvectorimpl">SmallVectorImpl&lt;ImmInsnModel&gt;</a> &amp;<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>) &#123;</span></CodeLine>
<Link id="l00152" /><CodeLine lineNumber="152"><span class="doxyHighlight">  </span><span class="doxyHighlightKeyword">const</span><span class="doxyHighlight"> </span><span class="doxyHighlightKeywordType">int</span><span class="doxyHighlight"> NotSet = -1;</span></CodeLine>
<Link id="l00153" /><CodeLine lineNumber="153"><span class="doxyHighlight">  </span><span class="doxyHighlightKeyword">const</span><span class="doxyHighlight"> uint64&#95;t Mask = 0xFFFF;</span></CodeLine>
<Link id="l00154" /><CodeLine lineNumber="154"></CodeLine>
<Link id="l00155" /><CodeLine lineNumber="155"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordType">int</span><span class="doxyHighlight"> StartIdx = NotSet;</span></CodeLine>
<Link id="l00156" /><CodeLine lineNumber="156"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordType">int</span><span class="doxyHighlight"> EndIdx = NotSet;</span></CodeLine>
<Link id="l00157" /><CodeLine lineNumber="157"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// Try to find the chunks which start/end a contiguous sequence of ones.</span></CodeLine>
<Link id="l00158" /><CodeLine lineNumber="158"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">for</span><span class="doxyHighlight"> (</span><span class="doxyHighlightKeywordType">int</span><span class="doxyHighlight"> Idx = 0; Idx &lt; 4; ++Idx) &#123;</span></CodeLine>
<Link id="l00159" /><CodeLine lineNumber="159"><span class="doxyHighlight">    int64&#95;t Chunk = <a href="#aa5bbae3632b4bfe0de4faea7a4da829f">getChunk</a>(UImm, Idx);</span></CodeLine>
<Link id="l00160" /><CodeLine lineNumber="160"><span class="doxyHighlight">    </span><span class="doxyHighlightComment">// Sign extend the 16-bit chunk to 64-bit.</span></CodeLine>
<Link id="l00161" /><CodeLine lineNumber="161"><span class="doxyHighlight">    Chunk = (Chunk &lt;&lt; 48) &gt;&gt; 48;</span></CodeLine>
<Link id="l00162" /><CodeLine lineNumber="162"></CodeLine>
<Link id="l00163" /><CodeLine lineNumber="163"><span class="doxyHighlight">    </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> (<a href="#ad84ff3d34cc228b799e8bc2f070fc4ab">isStartChunk</a>(Chunk))</span></CodeLine>
<Link id="l00164" /><CodeLine lineNumber="164"><span class="doxyHighlight">      StartIdx = Idx;</span></CodeLine>
<Link id="l00165" /><CodeLine lineNumber="165"><span class="doxyHighlight">    </span><span class="doxyHighlightKeywordFlow">else</span><span class="doxyHighlight"> </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> (<a href="#add895e8580b9acacceb10b92edcd4d37">isEndChunk</a>(Chunk))</span></CodeLine>
<Link id="l00166" /><CodeLine lineNumber="166"><span class="doxyHighlight">      EndIdx = Idx;</span></CodeLine>
<Link id="l00167" /><CodeLine lineNumber="167"><span class="doxyHighlight">  &#125;</span></CodeLine>
<Link id="l00168" /><CodeLine lineNumber="168"></CodeLine>
<Link id="l00169" /><CodeLine lineNumber="169"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// Early exit in case we can&#39;t find a start/end chunk.</span></CodeLine>
<Link id="l00170" /><CodeLine lineNumber="170"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> (StartIdx == NotSet || EndIdx == NotSet)</span></CodeLine>
<Link id="l00171" /><CodeLine lineNumber="171"><span class="doxyHighlight">    </span><span class="doxyHighlightKeywordFlow">return</span><span class="doxyHighlight"> </span><span class="doxyHighlightKeyword">false</span><span class="doxyHighlight">;</span></CodeLine>
<Link id="l00172" /><CodeLine lineNumber="172"></CodeLine>
<Link id="l00173" /><CodeLine lineNumber="173"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// Outside of the contiguous sequence of ones everything needs to be zero.</span></CodeLine>
<Link id="l00174" /><CodeLine lineNumber="174"><span class="doxyHighlight">  uint64&#95;t Outside = 0;</span></CodeLine>
<Link id="l00175" /><CodeLine lineNumber="175"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// Chunks between the start and end chunk need to have all their bits set.</span></CodeLine>
<Link id="l00176" /><CodeLine lineNumber="176"><span class="doxyHighlight">  uint64&#95;t Inside = Mask;</span></CodeLine>
<Link id="l00177" /><CodeLine lineNumber="177"></CodeLine>
<Link id="l00178" /><CodeLine lineNumber="178"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// If our contiguous sequence of ones wraps around from the MSB into the LSB,</span></CodeLine>
<Link id="l00179" /><CodeLine lineNumber="179"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// just swap indices and pretend we are materializing a contiguous sequence</span></CodeLine>
<Link id="l00180" /><CodeLine lineNumber="180"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// of zeros surrounded by a contiguous sequence of ones.</span></CodeLine>
<Link id="l00181" /><CodeLine lineNumber="181"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> (StartIdx &gt; EndIdx) &#123;</span></CodeLine>
<Link id="l00182" /><CodeLine lineNumber="182"><span class="doxyHighlight">    <a href="/docs/api/namespaces/std/#ab8424022895aee3e366fb9a32f2883cb">std::swap</a>(StartIdx, EndIdx);</span></CodeLine>
<Link id="l00183" /><CodeLine lineNumber="183"><span class="doxyHighlight">    <a href="/docs/api/namespaces/std/#ab8424022895aee3e366fb9a32f2883cb">std::swap</a>(Outside, Inside);</span></CodeLine>
<Link id="l00184" /><CodeLine lineNumber="184"><span class="doxyHighlight">  &#125;</span></CodeLine>
<Link id="l00185" /><CodeLine lineNumber="185"></CodeLine>
<Link id="l00186" /><CodeLine lineNumber="186"><span class="doxyHighlight">  uint64&#95;t OrrImm = UImm;</span></CodeLine>
<Link id="l00187" /><CodeLine lineNumber="187"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordType">int</span><span class="doxyHighlight"> FirstMovkIdx = NotSet;</span></CodeLine>
<Link id="l00188" /><CodeLine lineNumber="188"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordType">int</span><span class="doxyHighlight"> SecondMovkIdx = NotSet;</span></CodeLine>
<Link id="l00189" /><CodeLine lineNumber="189"></CodeLine>
<Link id="l00190" /><CodeLine lineNumber="190"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// Find out which chunks we need to patch up to obtain a contiguous sequence</span></CodeLine>
<Link id="l00191" /><CodeLine lineNumber="191"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// of ones.</span></CodeLine>
<Link id="l00192" /><CodeLine lineNumber="192"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">for</span><span class="doxyHighlight"> (</span><span class="doxyHighlightKeywordType">int</span><span class="doxyHighlight"> Idx = 0; Idx &lt; 4; ++Idx) &#123;</span></CodeLine>
<Link id="l00193" /><CodeLine lineNumber="193"><span class="doxyHighlight">    </span><span class="doxyHighlightKeyword">const</span><span class="doxyHighlight"> uint64&#95;t Chunk = <a href="#aa5bbae3632b4bfe0de4faea7a4da829f">getChunk</a>(UImm, Idx);</span></CodeLine>
<Link id="l00194" /><CodeLine lineNumber="194"></CodeLine>
<Link id="l00195" /><CodeLine lineNumber="195"><span class="doxyHighlight">    </span><span class="doxyHighlightComment">// Check whether we are looking at a chunk which is not part of the</span></CodeLine>
<Link id="l00196" /><CodeLine lineNumber="196"><span class="doxyHighlight">    </span><span class="doxyHighlightComment">// contiguous sequence of ones.</span></CodeLine>
<Link id="l00197" /><CodeLine lineNumber="197"><span class="doxyHighlight">    </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> ((Idx &lt; StartIdx || EndIdx &lt; Idx) &amp;&amp; Chunk != Outside) &#123;</span></CodeLine>
<Link id="l00198" /><CodeLine lineNumber="198"><span class="doxyHighlight">      OrrImm = <a href="#a4323e3fa0f558ea22393bc68e9520b27">updateImm</a>(OrrImm, Idx, Outside == 0);</span></CodeLine>
<Link id="l00199" /><CodeLine lineNumber="199"></CodeLine>
<Link id="l00200" /><CodeLine lineNumber="200"><span class="doxyHighlight">      </span><span class="doxyHighlightComment">// Remember the index we need to patch.</span></CodeLine>
<Link id="l00201" /><CodeLine lineNumber="201"><span class="doxyHighlight">      </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> (FirstMovkIdx == NotSet)</span></CodeLine>
<Link id="l00202" /><CodeLine lineNumber="202"><span class="doxyHighlight">        FirstMovkIdx = Idx;</span></CodeLine>
<Link id="l00203" /><CodeLine lineNumber="203"><span class="doxyHighlight">      </span><span class="doxyHighlightKeywordFlow">else</span></CodeLine>
<Link id="l00204" /><CodeLine lineNumber="204"><span class="doxyHighlight">        SecondMovkIdx = Idx;</span></CodeLine>
<Link id="l00205" /><CodeLine lineNumber="205"></CodeLine>
<Link id="l00206" /><CodeLine lineNumber="206"><span class="doxyHighlight">      </span><span class="doxyHighlightComment">// Check whether we are looking a chunk which is part of the contiguous</span></CodeLine>
<Link id="l00207" /><CodeLine lineNumber="207"><span class="doxyHighlight">      </span><span class="doxyHighlightComment">// sequence of ones.</span></CodeLine>
<Link id="l00208" /><CodeLine lineNumber="208"><span class="doxyHighlight">    &#125; </span><span class="doxyHighlightKeywordFlow">else</span><span class="doxyHighlight"> </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> (Idx &gt; StartIdx &amp;&amp; Idx &lt; EndIdx &amp;&amp; Chunk != Inside) &#123;</span></CodeLine>
<Link id="l00209" /><CodeLine lineNumber="209"><span class="doxyHighlight">      OrrImm = <a href="#a4323e3fa0f558ea22393bc68e9520b27">updateImm</a>(OrrImm, Idx, Inside != Mask);</span></CodeLine>
<Link id="l00210" /><CodeLine lineNumber="210"></CodeLine>
<Link id="l00211" /><CodeLine lineNumber="211"><span class="doxyHighlight">      </span><span class="doxyHighlightComment">// Remember the index we need to patch.</span></CodeLine>
<Link id="l00212" /><CodeLine lineNumber="212"><span class="doxyHighlight">      </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> (FirstMovkIdx == NotSet)</span></CodeLine>
<Link id="l00213" /><CodeLine lineNumber="213"><span class="doxyHighlight">        FirstMovkIdx = Idx;</span></CodeLine>
<Link id="l00214" /><CodeLine lineNumber="214"><span class="doxyHighlight">      </span><span class="doxyHighlightKeywordFlow">else</span></CodeLine>
<Link id="l00215" /><CodeLine lineNumber="215"><span class="doxyHighlight">        SecondMovkIdx = Idx;</span></CodeLine>
<Link id="l00216" /><CodeLine lineNumber="216"><span class="doxyHighlight">    &#125;</span></CodeLine>
<Link id="l00217" /><CodeLine lineNumber="217"><span class="doxyHighlight">  &#125;</span></CodeLine>
<Link id="l00218" /><CodeLine lineNumber="218"><span class="doxyHighlight">  <a href="/docs/api/files/lib/lib/target/lib/target/amdgpu/silowercontrolflow-cpp/#a4868c5d81c5ccc98c47aeab6244346a0">assert</a>(FirstMovkIdx != NotSet &amp;&amp; </span><span class="doxyHighlightStringLiteral">&quot;Constant materializable with single ORR!&quot;</span><span class="doxyHighlight">);</span></CodeLine>
<Link id="l00219" /><CodeLine lineNumber="219"></CodeLine>
<Link id="l00220" /><CodeLine lineNumber="220"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// Create the ORR-immediate instruction.</span></CodeLine>
<Link id="l00221" /><CodeLine lineNumber="221"><span class="doxyHighlight">  uint64&#95;t Encoding = 0;</span></CodeLine>
<Link id="l00222" /><CodeLine lineNumber="222"><span class="doxyHighlight">  <a href="/docs/api/namespaces/llvm/aarch64-am/#a2cd3e23b97b495a98c0b723ab18e4d96">AArch64&#95;AM::processLogicalImmediate</a>(OrrImm, 64, Encoding);</span></CodeLine>
<Link id="l00223" /><CodeLine lineNumber="223"><span class="doxyHighlight">  <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>.push&#95;back(&#123; AArch64::ORRXri, 0, Encoding &#125;);</span></CodeLine>
<Link id="l00224" /><CodeLine lineNumber="224"></CodeLine>
<Link id="l00225" /><CodeLine lineNumber="225"><span class="doxyHighlight">  </span><span class="doxyHighlightKeyword">const</span><span class="doxyHighlight"> </span><span class="doxyHighlightKeywordType">bool</span><span class="doxyHighlight"> SingleMovk = SecondMovkIdx == NotSet;</span></CodeLine>
<Link id="l00226" /><CodeLine lineNumber="226"><span class="doxyHighlight">  <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>.push&#95;back(&#123; AArch64::MOVKXi, <a href="#aa5bbae3632b4bfe0de4faea7a4da829f">getChunk</a>(UImm, FirstMovkIdx),</span></CodeLine>
<Link id="l00227" /><CodeLine lineNumber="227"><span class="doxyHighlight">                   <a href="/docs/api/namespaces/llvm/aarch64-am/#aeae88f12b667477f90db9b726556b337">AArch64&#95;AM::getShifterImm</a>(<a href="/docs/api/namespaces/llvm/aarch64-am/#a7e75394a33f6a5897d7a14c0ba5d44f1a1d97e13eb9923037fe733eda83b7f938">AArch64&#95;AM::LSL</a>,</span></CodeLine>
<Link id="l00228" /><CodeLine lineNumber="228"><span class="doxyHighlight">                                             FirstMovkIdx &#42; 16) &#125;);</span></CodeLine>
<Link id="l00229" /><CodeLine lineNumber="229"></CodeLine>
<Link id="l00230" /><CodeLine lineNumber="230"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// Early exit in case we only need to emit a single MOVK instruction.</span></CodeLine>
<Link id="l00231" /><CodeLine lineNumber="231"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> (SingleMovk)</span></CodeLine>
<Link id="l00232" /><CodeLine lineNumber="232"><span class="doxyHighlight">    </span><span class="doxyHighlightKeywordFlow">return</span><span class="doxyHighlight"> </span><span class="doxyHighlightKeyword">true</span><span class="doxyHighlight">;</span></CodeLine>
<Link id="l00233" /><CodeLine lineNumber="233"></CodeLine>
<Link id="l00234" /><CodeLine lineNumber="234"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// Create the second MOVK instruction.</span></CodeLine>
<Link id="l00235" /><CodeLine lineNumber="235"><span class="doxyHighlight">  <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>.push&#95;back(&#123; AArch64::MOVKXi, <a href="#aa5bbae3632b4bfe0de4faea7a4da829f">getChunk</a>(UImm, SecondMovkIdx),</span></CodeLine>
<Link id="l00236" /><CodeLine lineNumber="236"><span class="doxyHighlight">             <a href="/docs/api/namespaces/llvm/aarch64-am/#aeae88f12b667477f90db9b726556b337">AArch64&#95;AM::getShifterImm</a>(<a href="/docs/api/namespaces/llvm/aarch64-am/#a7e75394a33f6a5897d7a14c0ba5d44f1a1d97e13eb9923037fe733eda83b7f938">AArch64&#95;AM::LSL</a>,</span></CodeLine>
<Link id="l00237" /><CodeLine lineNumber="237"><span class="doxyHighlight">                                             SecondMovkIdx &#42; 16) &#125;);</span></CodeLine>
<Link id="l00238" /><CodeLine lineNumber="238"></CodeLine>
<Link id="l00239" /><CodeLine lineNumber="239"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">return</span><span class="doxyHighlight"> </span><span class="doxyHighlightKeyword">true</span><span class="doxyHighlight">;</span></CodeLine>
<Link id="l00240" /><CodeLine lineNumber="240"><span class="doxyHighlight">&#125;</span></CodeLine>
<Link id="l00241" /><CodeLine lineNumber="241"></CodeLine>
<Link id="l00242" /><CodeLine lineNumber="242" lineLink="#a2e2936fed450c145238eeca56cf4572e"><span class="doxyHighlightKeyword">static</span><span class="doxyHighlight"> uint64&#95;t <a href="#a2e2936fed450c145238eeca56cf4572e">GetRunOfOnesStartingAt</a>(uint64&#95;t V, uint64&#95;t StartPosition) &#123;</span></CodeLine>
<Link id="l00243" /><CodeLine lineNumber="243"><span class="doxyHighlight">  uint64&#95;t NumOnes = <a href="/docs/api/namespaces/llvm/#a239abca11deebf2731206dd41cf43c0e">llvm::countr&#95;one</a>(V &gt;&gt; StartPosition);</span></CodeLine>
<Link id="l00244" /><CodeLine lineNumber="244"></CodeLine>
<Link id="l00245" /><CodeLine lineNumber="245"><span class="doxyHighlight">  uint64&#95;t UnshiftedOnes;</span></CodeLine>
<Link id="l00246" /><CodeLine lineNumber="246"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> (NumOnes == 64) &#123;</span></CodeLine>
<Link id="l00247" /><CodeLine lineNumber="247"><span class="doxyHighlight">    UnshiftedOnes = ~0ULL;</span></CodeLine>
<Link id="l00248" /><CodeLine lineNumber="248"><span class="doxyHighlight">  &#125; </span><span class="doxyHighlightKeywordFlow">else</span><span class="doxyHighlight"> &#123;</span></CodeLine>
<Link id="l00249" /><CodeLine lineNumber="249"><span class="doxyHighlight">    UnshiftedOnes = (1ULL &lt;&lt; NumOnes) - 1;</span></CodeLine>
<Link id="l00250" /><CodeLine lineNumber="250"><span class="doxyHighlight">  &#125;</span></CodeLine>
<Link id="l00251" /><CodeLine lineNumber="251"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">return</span><span class="doxyHighlight"> UnshiftedOnes &lt;&lt; StartPosition;</span></CodeLine>
<Link id="l00252" /><CodeLine lineNumber="252"><span class="doxyHighlight">&#125;</span></CodeLine>
<Link id="l00253" /><CodeLine lineNumber="253"></CodeLine>
<Link id="l00254" /><CodeLine lineNumber="254" lineLink="#a78822aec5f2ccbac50c2b2ac068dc7d7"><span class="doxyHighlightKeyword">static</span><span class="doxyHighlight"> uint64&#95;t <a href="#a78822aec5f2ccbac50c2b2ac068dc7d7">MaximallyReplicateSubImmediate</a>(uint64&#95;t V, uint64&#95;t Subset) &#123;</span></CodeLine>
<Link id="l00255" /><CodeLine lineNumber="255"><span class="doxyHighlight">  uint64&#95;t Result = Subset;</span></CodeLine>
<Link id="l00256" /><CodeLine lineNumber="256"></CodeLine>
<Link id="l00257" /><CodeLine lineNumber="257"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// 64, 32, 16, 8, 4, 2</span></CodeLine>
<Link id="l00258" /><CodeLine lineNumber="258"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">for</span><span class="doxyHighlight"> (uint64&#95;t i = 0; i &lt; 6; ++i) &#123;</span></CodeLine>
<Link id="l00259" /><CodeLine lineNumber="259"><span class="doxyHighlight">    uint64&#95;t Rotation = 1ULL &lt;&lt; (6 - i);</span></CodeLine>
<Link id="l00260" /><CodeLine lineNumber="260"><span class="doxyHighlight">    uint64&#95;t Closure = Result | <a href="/docs/api/namespaces/llvm/#aef2599d8a5a682c348b25f74051cdb2d">llvm::rotl&lt;uint64&#95;t&gt;</a>(Result, Rotation);</span></CodeLine>
<Link id="l00261" /><CodeLine lineNumber="261"><span class="doxyHighlight">    </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> (Closure != (Closure &amp; V)) &#123;</span></CodeLine>
<Link id="l00262" /><CodeLine lineNumber="262"><span class="doxyHighlight">      </span><span class="doxyHighlightKeywordFlow">break</span><span class="doxyHighlight">;</span></CodeLine>
<Link id="l00263" /><CodeLine lineNumber="263"><span class="doxyHighlight">    &#125;</span></CodeLine>
<Link id="l00264" /><CodeLine lineNumber="264"><span class="doxyHighlight">    Result = Closure;</span></CodeLine>
<Link id="l00265" /><CodeLine lineNumber="265"><span class="doxyHighlight">  &#125;</span></CodeLine>
<Link id="l00266" /><CodeLine lineNumber="266"></CodeLine>
<Link id="l00267" /><CodeLine lineNumber="267"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">return</span><span class="doxyHighlight"> Result;</span></CodeLine>
<Link id="l00268" /><CodeLine lineNumber="268"><span class="doxyHighlight">&#125;</span></CodeLine>
<Link id="l00269" /><CodeLine lineNumber="269"></CodeLine>
<Link id="l00270" /><CodeLine lineNumber="270"><span class="doxyHighlightComment">// Find the logical immediate that covers the most bits in RemainingBits,</span></CodeLine>
<Link id="l00271" /><CodeLine lineNumber="271"><span class="doxyHighlightComment">// allowing for additional bits to be set that were set in OriginalBits.</span></CodeLine>
<Link id="l00272" /><CodeLine lineNumber="272" lineLink="#ad62d9bcb5891de134deb4465831a762b"><span class="doxyHighlightKeyword">static</span><span class="doxyHighlight"> uint64&#95;t <a href="#ad62d9bcb5891de134deb4465831a762b">maximalLogicalImmWithin</a>(uint64&#95;t RemainingBits,</span></CodeLine>
<Link id="l00273" /><CodeLine lineNumber="273"><span class="doxyHighlight">                                        uint64&#95;t OriginalBits) &#123;</span></CodeLine>
<Link id="l00274" /><CodeLine lineNumber="274"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// Find the first set bit.</span></CodeLine>
<Link id="l00275" /><CodeLine lineNumber="275"><span class="doxyHighlight">  uint32&#95;t Position = <a href="/docs/api/namespaces/llvm/#a57d2f9ee99e9e68cff564d0d579c8163">llvm::countr&#95;zero</a>(RemainingBits);</span></CodeLine>
<Link id="l00276" /><CodeLine lineNumber="276"></CodeLine>
<Link id="l00277" /><CodeLine lineNumber="277"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// Get the first run of set bits.</span></CodeLine>
<Link id="l00278" /><CodeLine lineNumber="278"><span class="doxyHighlight">  uint64&#95;t FirstRun = <a href="#a2e2936fed450c145238eeca56cf4572e">GetRunOfOnesStartingAt</a>(OriginalBits, Position);</span></CodeLine>
<Link id="l00279" /><CodeLine lineNumber="279"></CodeLine>
<Link id="l00280" /><CodeLine lineNumber="280"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// Replicate the run as many times as possible, as long as the bits are set in</span></CodeLine>
<Link id="l00281" /><CodeLine lineNumber="281"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// RemainingBits.</span></CodeLine>
<Link id="l00282" /><CodeLine lineNumber="282"><span class="doxyHighlight">  uint64&#95;t MaximalImm = <a href="#a78822aec5f2ccbac50c2b2ac068dc7d7">MaximallyReplicateSubImmediate</a>(OriginalBits, FirstRun);</span></CodeLine>
<Link id="l00283" /><CodeLine lineNumber="283"></CodeLine>
<Link id="l00284" /><CodeLine lineNumber="284"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">return</span><span class="doxyHighlight"> MaximalImm;</span></CodeLine>
<Link id="l00285" /><CodeLine lineNumber="285"><span class="doxyHighlight">&#125;</span></CodeLine>
<Link id="l00286" /><CodeLine lineNumber="286"></CodeLine>
<Link id="l00287" /><CodeLine lineNumber="287"><span class="doxyHighlightKeyword">static</span><span class="doxyHighlight"> std::optional&lt;std::pair&lt;uint64&#95;t, uint64&#95;t&gt;&gt;</span></CodeLine>
<Link id="l00288" /><CodeLine lineNumber="288" lineLink="#aeb71b2a77bd02c4e0e01aecf2d392452"><span class="doxyHighlight"><a href="#aeb71b2a77bd02c4e0e01aecf2d392452">decomposeIntoOrrOfLogicalImmediates</a>(uint64&#95;t UImm) &#123;</span></CodeLine>
<Link id="l00289" /><CodeLine lineNumber="289"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> (UImm == 0 || ~UImm == 0)</span></CodeLine>
<Link id="l00290" /><CodeLine lineNumber="290"><span class="doxyHighlight">    </span><span class="doxyHighlightKeywordFlow">return</span><span class="doxyHighlight"> std::nullopt;</span></CodeLine>
<Link id="l00291" /><CodeLine lineNumber="291"></CodeLine>
<Link id="l00292" /><CodeLine lineNumber="292"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// Make sure we don&#39;t have a run of ones split around the rotation boundary.</span></CodeLine>
<Link id="l00293" /><CodeLine lineNumber="293"><span class="doxyHighlight">  uint32&#95;t InitialTrailingOnes = <a href="/docs/api/namespaces/llvm/#a239abca11deebf2731206dd41cf43c0e">llvm::countr&#95;one</a>(UImm);</span></CodeLine>
<Link id="l00294" /><CodeLine lineNumber="294"><span class="doxyHighlight">  uint64&#95;t RotatedBits = <a href="/docs/api/namespaces/llvm/#a06620855572cf0307aea15a25099df47">llvm::rotr&lt;uint64&#95;t&gt;</a>(UImm, InitialTrailingOnes);</span></CodeLine>
<Link id="l00295" /><CodeLine lineNumber="295"></CodeLine>
<Link id="l00296" /><CodeLine lineNumber="296"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// Find the largest logical immediate that fits within the full immediate.</span></CodeLine>
<Link id="l00297" /><CodeLine lineNumber="297"><span class="doxyHighlight">  uint64&#95;t MaximalImm1 = <a href="#ad62d9bcb5891de134deb4465831a762b">maximalLogicalImmWithin</a>(RotatedBits, RotatedBits);</span></CodeLine>
<Link id="l00298" /><CodeLine lineNumber="298"></CodeLine>
<Link id="l00299" /><CodeLine lineNumber="299"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// Remove all bits that are set by this mask.</span></CodeLine>
<Link id="l00300" /><CodeLine lineNumber="300"><span class="doxyHighlight">  uint64&#95;t RemainingBits = RotatedBits &amp; ~MaximalImm1;</span></CodeLine>
<Link id="l00301" /><CodeLine lineNumber="301"></CodeLine>
<Link id="l00302" /><CodeLine lineNumber="302"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// Find the largest logical immediate covering the remaining bits, allowing</span></CodeLine>
<Link id="l00303" /><CodeLine lineNumber="303"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// for additional bits to be set that were also set in the original immediate.</span></CodeLine>
<Link id="l00304" /><CodeLine lineNumber="304"><span class="doxyHighlight">  uint64&#95;t MaximalImm2 = <a href="#ad62d9bcb5891de134deb4465831a762b">maximalLogicalImmWithin</a>(RemainingBits, RotatedBits);</span></CodeLine>
<Link id="l00305" /><CodeLine lineNumber="305"></CodeLine>
<Link id="l00306" /><CodeLine lineNumber="306"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// If any bits still haven&#39;t been covered, then give up.</span></CodeLine>
<Link id="l00307" /><CodeLine lineNumber="307"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> (RemainingBits &amp; ~MaximalImm2)</span></CodeLine>
<Link id="l00308" /><CodeLine lineNumber="308"><span class="doxyHighlight">    </span><span class="doxyHighlightKeywordFlow">return</span><span class="doxyHighlight"> std::nullopt;</span></CodeLine>
<Link id="l00309" /><CodeLine lineNumber="309"></CodeLine>
<Link id="l00310" /><CodeLine lineNumber="310"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// Make sure to un-rotate the immediates.</span></CodeLine>
<Link id="l00311" /><CodeLine lineNumber="311"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">return</span><span class="doxyHighlight"> std::make&#95;pair(<a href="/docs/api/namespaces/llvm/#aef2599d8a5a682c348b25f74051cdb2d">rotl</a>(MaximalImm1, InitialTrailingOnes),</span></CodeLine>
<Link id="l00312" /><CodeLine lineNumber="312"><span class="doxyHighlight">                        <a href="/docs/api/namespaces/llvm/#aef2599d8a5a682c348b25f74051cdb2d">rotl</a>(MaximalImm2, InitialTrailingOnes));</span></CodeLine>
<Link id="l00313" /><CodeLine lineNumber="313"><span class="doxyHighlight">&#125;</span></CodeLine>
<Link id="l00314" /><CodeLine lineNumber="314"></CodeLine>
<Link id="l00315" /><CodeLine lineNumber="315"><span class="doxyHighlightComment">// Attempt to expand an immediate as the ORR of a pair of logical immediates.</span></CodeLine>
<Link id="l00316" /><CodeLine lineNumber="316" lineLink="#ae492dde0ae62ef0c16a80f8b648bae19"><span class="doxyHighlightKeyword">static</span><span class="doxyHighlight"> </span><span class="doxyHighlightKeywordType">bool</span><span class="doxyHighlight"> <a href="#ae492dde0ae62ef0c16a80f8b648bae19">tryOrrOfLogicalImmediates</a>(uint64&#95;t UImm,</span></CodeLine>
<Link id="l00317" /><CodeLine lineNumber="317"><span class="doxyHighlight">                                      <a href="/docs/api/classes/llvm/smallvectorimpl">SmallVectorImpl&lt;ImmInsnModel&gt;</a> &amp;<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>) &#123;</span></CodeLine>
<Link id="l00318" /><CodeLine lineNumber="318"><span class="doxyHighlight">  </span><span class="doxyHighlightKeyword">auto</span><span class="doxyHighlight"> MaybeDecomposition = <a href="#aeb71b2a77bd02c4e0e01aecf2d392452">decomposeIntoOrrOfLogicalImmediates</a>(UImm);</span></CodeLine>
<Link id="l00319" /><CodeLine lineNumber="319"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> (MaybeDecomposition == std::nullopt)</span></CodeLine>
<Link id="l00320" /><CodeLine lineNumber="320"><span class="doxyHighlight">    </span><span class="doxyHighlightKeywordFlow">return</span><span class="doxyHighlight"> </span><span class="doxyHighlightKeyword">false</span><span class="doxyHighlight">;</span></CodeLine>
<Link id="l00321" /><CodeLine lineNumber="321"><span class="doxyHighlight">  uint64&#95;t Imm1 = MaybeDecomposition-&gt;first;</span></CodeLine>
<Link id="l00322" /><CodeLine lineNumber="322"><span class="doxyHighlight">  uint64&#95;t Imm2 = MaybeDecomposition-&gt;second;</span></CodeLine>
<Link id="l00323" /><CodeLine lineNumber="323"></CodeLine>
<Link id="l00324" /><CodeLine lineNumber="324"><span class="doxyHighlight">  uint64&#95;t Encoding1, Encoding2;</span></CodeLine>
<Link id="l00325" /><CodeLine lineNumber="325"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordType">bool</span><span class="doxyHighlight"> Imm1Success = <a href="/docs/api/namespaces/llvm/aarch64-am/#a2cd3e23b97b495a98c0b723ab18e4d96">AArch64&#95;AM::processLogicalImmediate</a>(Imm1, 64, Encoding1);</span></CodeLine>
<Link id="l00326" /><CodeLine lineNumber="326"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordType">bool</span><span class="doxyHighlight"> Imm2Success = <a href="/docs/api/namespaces/llvm/aarch64-am/#a2cd3e23b97b495a98c0b723ab18e4d96">AArch64&#95;AM::processLogicalImmediate</a>(Imm2, 64, Encoding2);</span></CodeLine>
<Link id="l00327" /><CodeLine lineNumber="327"></CodeLine>
<Link id="l00328" /><CodeLine lineNumber="328"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> (Imm1Success &amp;&amp; Imm2Success) &#123;</span></CodeLine>
<Link id="l00329" /><CodeLine lineNumber="329"><span class="doxyHighlight">    </span><span class="doxyHighlightComment">// Create the ORR-immediate instructions.</span></CodeLine>
<Link id="l00330" /><CodeLine lineNumber="330"><span class="doxyHighlight">    <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>.push&#95;back(&#123;AArch64::ORRXri, 0, Encoding1&#125;);</span></CodeLine>
<Link id="l00331" /><CodeLine lineNumber="331"><span class="doxyHighlight">    <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>.push&#95;back(&#123;AArch64::ORRXri, 1, Encoding2&#125;);</span></CodeLine>
<Link id="l00332" /><CodeLine lineNumber="332"><span class="doxyHighlight">    </span><span class="doxyHighlightKeywordFlow">return</span><span class="doxyHighlight"> </span><span class="doxyHighlightKeyword">true</span><span class="doxyHighlight">;</span></CodeLine>
<Link id="l00333" /><CodeLine lineNumber="333"><span class="doxyHighlight">  &#125;</span></CodeLine>
<Link id="l00334" /><CodeLine lineNumber="334"></CodeLine>
<Link id="l00335" /><CodeLine lineNumber="335"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">return</span><span class="doxyHighlight"> </span><span class="doxyHighlightKeyword">false</span><span class="doxyHighlight">;</span></CodeLine>
<Link id="l00336" /><CodeLine lineNumber="336"><span class="doxyHighlight">&#125;</span></CodeLine>
<Link id="l00337" /><CodeLine lineNumber="337"></CodeLine>
<Link id="l00338" /><CodeLine lineNumber="338"><span class="doxyHighlightComment">// Attempt to expand an immediate as the AND of a pair of logical immediates.</span></CodeLine>
<Link id="l00339" /><CodeLine lineNumber="339"><span class="doxyHighlightComment">// This is done by applying DeMorgan&#39;s law, under which logical immediates</span></CodeLine>
<Link id="l00340" /><CodeLine lineNumber="340"><span class="doxyHighlightComment">// are closed.</span></CodeLine>
<Link id="l00341" /><CodeLine lineNumber="341" lineLink="#aa20f3eb24c28efa9c93053a733a172c1"><span class="doxyHighlightKeyword">static</span><span class="doxyHighlight"> </span><span class="doxyHighlightKeywordType">bool</span><span class="doxyHighlight"> <a href="#aa20f3eb24c28efa9c93053a733a172c1">tryAndOfLogicalImmediates</a>(uint64&#95;t UImm,</span></CodeLine>
<Link id="l00342" /><CodeLine lineNumber="342"><span class="doxyHighlight">                                      <a href="/docs/api/classes/llvm/smallvectorimpl">SmallVectorImpl&lt;ImmInsnModel&gt;</a> &amp;<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>) &#123;</span></CodeLine>
<Link id="l00343" /><CodeLine lineNumber="343"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// Apply DeMorgan&#39;s law to turn this into an ORR problem.</span></CodeLine>
<Link id="l00344" /><CodeLine lineNumber="344"><span class="doxyHighlight">  </span><span class="doxyHighlightKeyword">auto</span><span class="doxyHighlight"> MaybeDecomposition = <a href="#aeb71b2a77bd02c4e0e01aecf2d392452">decomposeIntoOrrOfLogicalImmediates</a>(~UImm);</span></CodeLine>
<Link id="l00345" /><CodeLine lineNumber="345"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> (MaybeDecomposition == std::nullopt)</span></CodeLine>
<Link id="l00346" /><CodeLine lineNumber="346"><span class="doxyHighlight">    </span><span class="doxyHighlightKeywordFlow">return</span><span class="doxyHighlight"> </span><span class="doxyHighlightKeyword">false</span><span class="doxyHighlight">;</span></CodeLine>
<Link id="l00347" /><CodeLine lineNumber="347"><span class="doxyHighlight">  uint64&#95;t Imm1 = MaybeDecomposition-&gt;first;</span></CodeLine>
<Link id="l00348" /><CodeLine lineNumber="348"><span class="doxyHighlight">  uint64&#95;t Imm2 = MaybeDecomposition-&gt;second;</span></CodeLine>
<Link id="l00349" /><CodeLine lineNumber="349"></CodeLine>
<Link id="l00350" /><CodeLine lineNumber="350"><span class="doxyHighlight">  uint64&#95;t Encoding1, Encoding2;</span></CodeLine>
<Link id="l00351" /><CodeLine lineNumber="351"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordType">bool</span><span class="doxyHighlight"> Imm1Success = <a href="/docs/api/namespaces/llvm/aarch64-am/#a2cd3e23b97b495a98c0b723ab18e4d96">AArch64&#95;AM::processLogicalImmediate</a>(~Imm1, 64, Encoding1);</span></CodeLine>
<Link id="l00352" /><CodeLine lineNumber="352"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordType">bool</span><span class="doxyHighlight"> Imm2Success = <a href="/docs/api/namespaces/llvm/aarch64-am/#a2cd3e23b97b495a98c0b723ab18e4d96">AArch64&#95;AM::processLogicalImmediate</a>(~Imm2, 64, Encoding2);</span></CodeLine>
<Link id="l00353" /><CodeLine lineNumber="353"></CodeLine>
<Link id="l00354" /><CodeLine lineNumber="354"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> (Imm1Success &amp;&amp; Imm2Success) &#123;</span></CodeLine>
<Link id="l00355" /><CodeLine lineNumber="355"><span class="doxyHighlight">    </span><span class="doxyHighlightComment">// Materialize Imm1, the LHS of the AND</span></CodeLine>
<Link id="l00356" /><CodeLine lineNumber="356"><span class="doxyHighlight">    <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>.push&#95;back(&#123;AArch64::ORRXri, 0, Encoding1&#125;);</span></CodeLine>
<Link id="l00357" /><CodeLine lineNumber="357"><span class="doxyHighlight">    </span><span class="doxyHighlightComment">// AND Imm1 with Imm2</span></CodeLine>
<Link id="l00358" /><CodeLine lineNumber="358"><span class="doxyHighlight">    <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>.push&#95;back(&#123;AArch64::ANDXri, 1, Encoding2&#125;);</span></CodeLine>
<Link id="l00359" /><CodeLine lineNumber="359"><span class="doxyHighlight">    </span><span class="doxyHighlightKeywordFlow">return</span><span class="doxyHighlight"> </span><span class="doxyHighlightKeyword">true</span><span class="doxyHighlight">;</span></CodeLine>
<Link id="l00360" /><CodeLine lineNumber="360"><span class="doxyHighlight">  &#125;</span></CodeLine>
<Link id="l00361" /><CodeLine lineNumber="361"></CodeLine>
<Link id="l00362" /><CodeLine lineNumber="362"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">return</span><span class="doxyHighlight"> </span><span class="doxyHighlightKeyword">false</span><span class="doxyHighlight">;</span></CodeLine>
<Link id="l00363" /><CodeLine lineNumber="363"><span class="doxyHighlight">&#125;</span></CodeLine>
<Link id="l00364" /><CodeLine lineNumber="364"></CodeLine>
<Link id="l00365" /><CodeLine lineNumber="365"><span class="doxyHighlightComment">// Check whether the constant can be represented by exclusive-or of two 64-bit</span></CodeLine>
<Link id="l00366" /><CodeLine lineNumber="366"><span class="doxyHighlightComment">// logical immediates. If so, materialize it with an ORR instruction followed</span></CodeLine>
<Link id="l00367" /><CodeLine lineNumber="367"><span class="doxyHighlightComment">// by an EOR instruction.</span></CodeLine>
<Link id="l00368" /><CodeLine lineNumber="368"><span class="doxyHighlightComment">//</span></CodeLine>
<Link id="l00369" /><CodeLine lineNumber="369"><span class="doxyHighlightComment">// This encoding allows all remaining repeated byte patterns, and many repeated</span></CodeLine>
<Link id="l00370" /><CodeLine lineNumber="370"><span class="doxyHighlightComment">// 16-bit values, to be encoded without needing four instructions. It can also</span></CodeLine>
<Link id="l00371" /><CodeLine lineNumber="371"><span class="doxyHighlightComment">// represent some irregular bitmasks (although those would mostly only need</span></CodeLine>
<Link id="l00372" /><CodeLine lineNumber="372"><span class="doxyHighlightComment">// three instructions otherwise).</span></CodeLine>
<Link id="l00373" /><CodeLine lineNumber="373" lineLink="#ab2f723b31c9dbe46610248a047805046"><span class="doxyHighlightKeyword">static</span><span class="doxyHighlight"> </span><span class="doxyHighlightKeywordType">bool</span><span class="doxyHighlight"> <a href="#ab2f723b31c9dbe46610248a047805046">tryEorOfLogicalImmediates</a>(uint64&#95;t Imm,</span></CodeLine>
<Link id="l00374" /><CodeLine lineNumber="374"><span class="doxyHighlight">                                      <a href="/docs/api/classes/llvm/smallvectorimpl">SmallVectorImpl&lt;ImmInsnModel&gt;</a> &amp;<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>) &#123;</span></CodeLine>
<Link id="l00375" /><CodeLine lineNumber="375"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// Determine the larger repetition size of the two possible logical</span></CodeLine>
<Link id="l00376" /><CodeLine lineNumber="376"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// immediates, by finding the repetition size of Imm.</span></CodeLine>
<Link id="l00377" /><CodeLine lineNumber="377"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordType">unsigned</span><span class="doxyHighlight"> BigSize = 64;</span></CodeLine>
<Link id="l00378" /><CodeLine lineNumber="378"></CodeLine>
<Link id="l00379" /><CodeLine lineNumber="379"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">do</span><span class="doxyHighlight"> &#123;</span></CodeLine>
<Link id="l00380" /><CodeLine lineNumber="380"><span class="doxyHighlight">    BigSize /= 2;</span></CodeLine>
<Link id="l00381" /><CodeLine lineNumber="381"><span class="doxyHighlight">    uint64&#95;t Mask = (1ULL &lt;&lt; BigSize) - 1;</span></CodeLine>
<Link id="l00382" /><CodeLine lineNumber="382"></CodeLine>
<Link id="l00383" /><CodeLine lineNumber="383"><span class="doxyHighlight">    </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> ((Imm &amp; Mask) != ((Imm &gt;&gt; BigSize) &amp; Mask)) &#123;</span></CodeLine>
<Link id="l00384" /><CodeLine lineNumber="384"><span class="doxyHighlight">      BigSize &#42;= 2;</span></CodeLine>
<Link id="l00385" /><CodeLine lineNumber="385"><span class="doxyHighlight">      </span><span class="doxyHighlightKeywordFlow">break</span><span class="doxyHighlight">;</span></CodeLine>
<Link id="l00386" /><CodeLine lineNumber="386"><span class="doxyHighlight">    &#125;</span></CodeLine>
<Link id="l00387" /><CodeLine lineNumber="387"><span class="doxyHighlight">  &#125; </span><span class="doxyHighlightKeywordFlow">while</span><span class="doxyHighlight"> (BigSize &gt; 2);</span></CodeLine>
<Link id="l00388" /><CodeLine lineNumber="388"></CodeLine>
<Link id="l00389" /><CodeLine lineNumber="389"><span class="doxyHighlight">  uint64&#95;t BigMask = ((uint64&#95;t)-1LL) &gt;&gt; (64 - BigSize);</span></CodeLine>
<Link id="l00390" /><CodeLine lineNumber="390"></CodeLine>
<Link id="l00391" /><CodeLine lineNumber="391"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// Find the last bit of each run of ones, circularly. For runs which wrap</span></CodeLine>
<Link id="l00392" /><CodeLine lineNumber="392"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// around from bit 0 to bit 63, this is the bit before the most-significant</span></CodeLine>
<Link id="l00393" /><CodeLine lineNumber="393"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// zero, otherwise it is the least-significant bit in the run of ones.</span></CodeLine>
<Link id="l00394" /><CodeLine lineNumber="394"><span class="doxyHighlight">  uint64&#95;t RunStarts = Imm &amp; <a href="/docs/api/namespaces/llvm/#aef2599d8a5a682c348b25f74051cdb2d">~rotl&lt;uint64&#95;t&gt;</a>(Imm, 1);</span></CodeLine>
<Link id="l00395" /><CodeLine lineNumber="395"></CodeLine>
<Link id="l00396" /><CodeLine lineNumber="396"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// Find the smaller repetition size of the two possible logical immediates by</span></CodeLine>
<Link id="l00397" /><CodeLine lineNumber="397"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// counting the number of runs of one-bits within the BigSize-bit value. Both</span></CodeLine>
<Link id="l00398" /><CodeLine lineNumber="398"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// sizes may be the same. The EOR may add one or subtract one from the</span></CodeLine>
<Link id="l00399" /><CodeLine lineNumber="399"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// power-of-two count that can be represented by a logical immediate, or it</span></CodeLine>
<Link id="l00400" /><CodeLine lineNumber="400"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// may be left unchanged.</span></CodeLine>
<Link id="l00401" /><CodeLine lineNumber="401"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordType">int</span><span class="doxyHighlight"> RunsPerBigChunk = <a href="/docs/api/namespaces/llvm/#a0eea77e7bfa82e0219d2ec7b4efbc94f">popcount</a>(RunStarts &amp; BigMask);</span></CodeLine>
<Link id="l00402" /><CodeLine lineNumber="402"></CodeLine>
<Link id="l00403" /><CodeLine lineNumber="403"><span class="doxyHighlight">  </span><span class="doxyHighlightKeyword">static</span><span class="doxyHighlight"> </span><span class="doxyHighlightKeyword">const</span><span class="doxyHighlight"> int8&#95;t BigToSmallSizeTable&#91;32&#93; = &#123;</span></CodeLine>
<Link id="l00404" /><CodeLine lineNumber="404"><span class="doxyHighlight">      -1, -1, 0,  1,  2,  2,  -1, 3,  3,  3,  -1, -1, -1, -1, -1, 4,</span></CodeLine>
<Link id="l00405" /><CodeLine lineNumber="405"><span class="doxyHighlight">      4,  4,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5,</span></CodeLine>
<Link id="l00406" /><CodeLine lineNumber="406"><span class="doxyHighlight">  &#125;;</span></CodeLine>
<Link id="l00407" /><CodeLine lineNumber="407"></CodeLine>
<Link id="l00408" /><CodeLine lineNumber="408"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordType">int</span><span class="doxyHighlight"> BigToSmallShift = BigToSmallSizeTable&#91;RunsPerBigChunk&#93;;</span></CodeLine>
<Link id="l00409" /><CodeLine lineNumber="409"></CodeLine>
<Link id="l00410" /><CodeLine lineNumber="410"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// Early-exit if the big chunk couldn&#39;t be a power-of-two number of runs</span></CodeLine>
<Link id="l00411" /><CodeLine lineNumber="411"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// EORed with another single run.</span></CodeLine>
<Link id="l00412" /><CodeLine lineNumber="412"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> (BigToSmallShift == -1)</span></CodeLine>
<Link id="l00413" /><CodeLine lineNumber="413"><span class="doxyHighlight">    </span><span class="doxyHighlightKeywordFlow">return</span><span class="doxyHighlight"> </span><span class="doxyHighlightKeyword">false</span><span class="doxyHighlight">;</span></CodeLine>
<Link id="l00414" /><CodeLine lineNumber="414"></CodeLine>
<Link id="l00415" /><CodeLine lineNumber="415"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordType">unsigned</span><span class="doxyHighlight"> SmallSize = BigSize &gt;&gt; BigToSmallShift;</span></CodeLine>
<Link id="l00416" /><CodeLine lineNumber="416"></CodeLine>
<Link id="l00417" /><CodeLine lineNumber="417"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// 64-bit values with a bit set every (1 &lt;&lt; index) bits.</span></CodeLine>
<Link id="l00418" /><CodeLine lineNumber="418"><span class="doxyHighlight">  </span><span class="doxyHighlightKeyword">static</span><span class="doxyHighlight"> </span><span class="doxyHighlightKeyword">const</span><span class="doxyHighlight"> uint64&#95;t RepeatedOnesTable&#91;&#93; = &#123;</span></CodeLine>
<Link id="l00419" /><CodeLine lineNumber="419"><span class="doxyHighlight">      0xffffffffffffffff, 0x5555555555555555, 0x1111111111111111,</span></CodeLine>
<Link id="l00420" /><CodeLine lineNumber="420"><span class="doxyHighlight">      0x0101010101010101, 0x0001000100010001, 0x0000000100000001,</span></CodeLine>
<Link id="l00421" /><CodeLine lineNumber="421"><span class="doxyHighlight">      0x0000000000000001,</span></CodeLine>
<Link id="l00422" /><CodeLine lineNumber="422"><span class="doxyHighlight">  &#125;;</span></CodeLine>
<Link id="l00423" /><CodeLine lineNumber="423"></CodeLine>
<Link id="l00424" /><CodeLine lineNumber="424"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// This RepeatedOnesTable lookup is a faster implementation of the division</span></CodeLine>
<Link id="l00425" /><CodeLine lineNumber="425"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// 18446744073709552000 / ((1 &lt;&lt; SmallSize) - 1), and can be thought of as</span></CodeLine>
<Link id="l00426" /><CodeLine lineNumber="426"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// dividing the 64-bit value into fields of width SmallSize, and placing a</span></CodeLine>
<Link id="l00427" /><CodeLine lineNumber="427"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// one in the least significant bit of each field.</span></CodeLine>
<Link id="l00428" /><CodeLine lineNumber="428"><span class="doxyHighlight">  uint64&#95;t SmallOnes = RepeatedOnesTable&#91;<a href="/docs/api/namespaces/llvm/#a57d2f9ee99e9e68cff564d0d579c8163">countr&#95;zero</a>(SmallSize)&#93;;</span></CodeLine>
<Link id="l00429" /><CodeLine lineNumber="429"></CodeLine>
<Link id="l00430" /><CodeLine lineNumber="430"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// Now we try to find the number of ones in each of the smaller repetitions,</span></CodeLine>
<Link id="l00431" /><CodeLine lineNumber="431"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// by looking at runs of ones in Imm. This can take three attempts, as the</span></CodeLine>
<Link id="l00432" /><CodeLine lineNumber="432"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// EOR may have changed the length of the first two runs we find.</span></CodeLine>
<Link id="l00433" /><CodeLine lineNumber="433"></CodeLine>
<Link id="l00434" /><CodeLine lineNumber="434"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// Rotate a run of ones so we can count the number of trailing set bits.</span></CodeLine>
<Link id="l00435" /><CodeLine lineNumber="435"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordType">int</span><span class="doxyHighlight"> Rotation = <a href="/docs/api/namespaces/llvm/#a57d2f9ee99e9e68cff564d0d579c8163">countr&#95;zero</a>(RunStarts);</span></CodeLine>
<Link id="l00436" /><CodeLine lineNumber="436"><span class="doxyHighlight">  uint64&#95;t RotatedImm = <a href="/docs/api/namespaces/llvm/#a06620855572cf0307aea15a25099df47">rotr&lt;uint64&#95;t&gt;</a>(Imm, Rotation);</span></CodeLine>
<Link id="l00437" /><CodeLine lineNumber="437"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">for</span><span class="doxyHighlight"> (</span><span class="doxyHighlightKeywordType">int</span><span class="doxyHighlight"> Attempt = 0; Attempt &lt; 3; ++Attempt) &#123;</span></CodeLine>
<Link id="l00438" /><CodeLine lineNumber="438"><span class="doxyHighlight">    </span><span class="doxyHighlightKeywordType">unsigned</span><span class="doxyHighlight"> RunLength = <a href="/docs/api/namespaces/llvm/#a239abca11deebf2731206dd41cf43c0e">countr&#95;one</a>(RotatedImm);</span></CodeLine>
<Link id="l00439" /><CodeLine lineNumber="439"></CodeLine>
<Link id="l00440" /><CodeLine lineNumber="440"><span class="doxyHighlight">    </span><span class="doxyHighlightComment">// Construct candidate values BigImm and SmallImm, such that if these two</span></CodeLine>
<Link id="l00441" /><CodeLine lineNumber="441"><span class="doxyHighlight">    </span><span class="doxyHighlightComment">// values are encodable, we have a solution. (SmallImm is constructed to be</span></CodeLine>
<Link id="l00442" /><CodeLine lineNumber="442"><span class="doxyHighlight">    </span><span class="doxyHighlightComment">// encodable, but this isn&#39;t guaranteed when RunLength &gt;= SmallSize)</span></CodeLine>
<Link id="l00443" /><CodeLine lineNumber="443"><span class="doxyHighlight">    uint64&#95;t SmallImm =</span></CodeLine>
<Link id="l00444" /><CodeLine lineNumber="444"><span class="doxyHighlight">        <a href="/docs/api/namespaces/llvm/#aef2599d8a5a682c348b25f74051cdb2d">rotl&lt;uint64&#95;t&gt;</a>((SmallOnes &lt;&lt; RunLength) - SmallOnes, Rotation);</span></CodeLine>
<Link id="l00445" /><CodeLine lineNumber="445"><span class="doxyHighlight">    uint64&#95;t BigImm = Imm ^ SmallImm;</span></CodeLine>
<Link id="l00446" /><CodeLine lineNumber="446"></CodeLine>
<Link id="l00447" /><CodeLine lineNumber="447"><span class="doxyHighlight">    uint64&#95;t BigEncoding = 0;</span></CodeLine>
<Link id="l00448" /><CodeLine lineNumber="448"><span class="doxyHighlight">    uint64&#95;t SmallEncoding = 0;</span></CodeLine>
<Link id="l00449" /><CodeLine lineNumber="449"><span class="doxyHighlight">    </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> (<a href="/docs/api/namespaces/llvm/aarch64-am/#a2cd3e23b97b495a98c0b723ab18e4d96">AArch64&#95;AM::processLogicalImmediate</a>(BigImm, 64, BigEncoding) &amp;&amp;</span></CodeLine>
<Link id="l00450" /><CodeLine lineNumber="450"><span class="doxyHighlight">        <a href="/docs/api/namespaces/llvm/aarch64-am/#a2cd3e23b97b495a98c0b723ab18e4d96">AArch64&#95;AM::processLogicalImmediate</a>(SmallImm, 64, SmallEncoding)) &#123;</span></CodeLine>
<Link id="l00451" /><CodeLine lineNumber="451"><span class="doxyHighlight">      <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>.push&#95;back(&#123;AArch64::ORRXri, 0, SmallEncoding&#125;);</span></CodeLine>
<Link id="l00452" /><CodeLine lineNumber="452"><span class="doxyHighlight">      <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>.push&#95;back(&#123;AArch64::EORXri, 1, BigEncoding&#125;);</span></CodeLine>
<Link id="l00453" /><CodeLine lineNumber="453"><span class="doxyHighlight">      </span><span class="doxyHighlightKeywordFlow">return</span><span class="doxyHighlight"> </span><span class="doxyHighlightKeyword">true</span><span class="doxyHighlight">;</span></CodeLine>
<Link id="l00454" /><CodeLine lineNumber="454"><span class="doxyHighlight">    &#125;</span></CodeLine>
<Link id="l00455" /><CodeLine lineNumber="455"></CodeLine>
<Link id="l00456" /><CodeLine lineNumber="456"><span class="doxyHighlight">    </span><span class="doxyHighlightComment">// Rotate to the next run of ones</span></CodeLine>
<Link id="l00457" /><CodeLine lineNumber="457"><span class="doxyHighlight">    Rotation += <a href="/docs/api/namespaces/llvm/#a57d2f9ee99e9e68cff564d0d579c8163">countr&#95;zero</a>(<a href="/docs/api/namespaces/llvm/#a06620855572cf0307aea15a25099df47">rotr&lt;uint64&#95;t&gt;</a>(RunStarts, Rotation) &amp; ~1);</span></CodeLine>
<Link id="l00458" /><CodeLine lineNumber="458"><span class="doxyHighlight">    RotatedImm = <a href="/docs/api/namespaces/llvm/#a06620855572cf0307aea15a25099df47">rotr&lt;uint64&#95;t&gt;</a>(Imm, Rotation);</span></CodeLine>
<Link id="l00459" /><CodeLine lineNumber="459"><span class="doxyHighlight">  &#125;</span></CodeLine>
<Link id="l00460" /><CodeLine lineNumber="460"></CodeLine>
<Link id="l00461" /><CodeLine lineNumber="461"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">return</span><span class="doxyHighlight"> </span><span class="doxyHighlightKeyword">false</span><span class="doxyHighlight">;</span></CodeLine>
<Link id="l00462" /><CodeLine lineNumber="462"><span class="doxyHighlight">&#125;</span></CodeLine>
<Link id="l00463" /><CodeLine lineNumber="463"></CodeLine>
<Link id="l00464" /><CodeLine lineNumber="464"><span class="doxyHighlightComment">/// \\brief Expand a MOVi32imm or MOVi64imm pseudo instruction to a</span></CodeLine>
<Link id="l00465" /><CodeLine lineNumber="465"><span class="doxyHighlightComment">/// MOVZ or MOVN of width BitSize followed by up to 3 MOVK instructions.</span></CodeLine>
<Link id="l00466" /><CodeLine lineNumber="466" lineLink="#a2edf9e8f09bfb0cc4949aa1813872322"><span class="doxyHighlightKeyword">static</span><span class="doxyHighlight"> </span><span class="doxyHighlightKeyword">inline</span><span class="doxyHighlight"> </span><span class="doxyHighlightKeywordType">void</span><span class="doxyHighlight"> <a href="#a2edf9e8f09bfb0cc4949aa1813872322">expandMOVImmSimple</a>(uint64&#95;t Imm, </span><span class="doxyHighlightKeywordType">unsigned</span><span class="doxyHighlight"> BitSize,</span></CodeLine>
<Link id="l00467" /><CodeLine lineNumber="467"><span class="doxyHighlight">              </span><span class="doxyHighlightKeywordType">unsigned</span><span class="doxyHighlight"> OneChunks, </span><span class="doxyHighlightKeywordType">unsigned</span><span class="doxyHighlight"> ZeroChunks,</span></CodeLine>
<Link id="l00468" /><CodeLine lineNumber="468"><span class="doxyHighlight">              <a href="/docs/api/classes/llvm/smallvectorimpl">SmallVectorImpl&lt;ImmInsnModel&gt;</a> &amp;<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>) &#123;</span></CodeLine>
<Link id="l00469" /><CodeLine lineNumber="469"><span class="doxyHighlight">  </span><span class="doxyHighlightKeyword">const</span><span class="doxyHighlight"> </span><span class="doxyHighlightKeywordType">unsigned</span><span class="doxyHighlight"> Mask = 0xFFFF;</span></CodeLine>
<Link id="l00470" /><CodeLine lineNumber="470"></CodeLine>
<Link id="l00471" /><CodeLine lineNumber="471"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// Use a MOVZ or MOVN instruction to set the high bits, followed by one or</span></CodeLine>
<Link id="l00472" /><CodeLine lineNumber="472"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// more MOVK instructions to insert additional 16-bit portions into the</span></CodeLine>
<Link id="l00473" /><CodeLine lineNumber="473"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// lower bits.</span></CodeLine>
<Link id="l00474" /><CodeLine lineNumber="474"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordType">bool</span><span class="doxyHighlight"> <a href="/docs/api/files/lib/lib/codegen/complexdeinterleavingpass-cpp/#a2762113571c7956c9818c452b2d256ae">isNeg</a> = </span><span class="doxyHighlightKeyword">false</span><span class="doxyHighlight">;</span></CodeLine>
<Link id="l00475" /><CodeLine lineNumber="475"></CodeLine>
<Link id="l00476" /><CodeLine lineNumber="476"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// Use MOVN to materialize the high bits if we have more all one chunks</span></CodeLine>
<Link id="l00477" /><CodeLine lineNumber="477"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// than all zero chunks.</span></CodeLine>
<Link id="l00478" /><CodeLine lineNumber="478"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> (OneChunks &gt; ZeroChunks) &#123;</span></CodeLine>
<Link id="l00479" /><CodeLine lineNumber="479"><span class="doxyHighlight">    <a href="/docs/api/files/lib/lib/codegen/complexdeinterleavingpass-cpp/#a2762113571c7956c9818c452b2d256ae">isNeg</a> = </span><span class="doxyHighlightKeyword">true</span><span class="doxyHighlight">;</span></CodeLine>
<Link id="l00480" /><CodeLine lineNumber="480"><span class="doxyHighlight">    Imm = ~Imm;</span></CodeLine>
<Link id="l00481" /><CodeLine lineNumber="481"><span class="doxyHighlight">  &#125;</span></CodeLine>
<Link id="l00482" /><CodeLine lineNumber="482"></CodeLine>
<Link id="l00483" /><CodeLine lineNumber="483"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordType">unsigned</span><span class="doxyHighlight"> FirstOpc;</span></CodeLine>
<Link id="l00484" /><CodeLine lineNumber="484"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> (BitSize == 32) &#123;</span></CodeLine>
<Link id="l00485" /><CodeLine lineNumber="485"><span class="doxyHighlight">    Imm &amp;= (1LL &lt;&lt; 32) - 1;</span></CodeLine>
<Link id="l00486" /><CodeLine lineNumber="486"><span class="doxyHighlight">    FirstOpc = (<a href="/docs/api/files/lib/lib/codegen/complexdeinterleavingpass-cpp/#a2762113571c7956c9818c452b2d256ae">isNeg</a> ? AArch64::MOVNWi : AArch64::MOVZWi);</span></CodeLine>
<Link id="l00487" /><CodeLine lineNumber="487"><span class="doxyHighlight">  &#125; </span><span class="doxyHighlightKeywordFlow">else</span><span class="doxyHighlight"> &#123;</span></CodeLine>
<Link id="l00488" /><CodeLine lineNumber="488"><span class="doxyHighlight">    FirstOpc = (<a href="/docs/api/files/lib/lib/codegen/complexdeinterleavingpass-cpp/#a2762113571c7956c9818c452b2d256ae">isNeg</a> ? AArch64::MOVNXi : AArch64::MOVZXi);</span></CodeLine>
<Link id="l00489" /><CodeLine lineNumber="489"><span class="doxyHighlight">  &#125;</span></CodeLine>
<Link id="l00490" /><CodeLine lineNumber="490"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordType">unsigned</span><span class="doxyHighlight"> Shift = 0;     </span><span class="doxyHighlightComment">// LSL amount for high bits with MOVZ/MOVN</span></CodeLine>
<Link id="l00491" /><CodeLine lineNumber="491"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordType">unsigned</span><span class="doxyHighlight"> LastShift = 0; </span><span class="doxyHighlightComment">// LSL amount for last MOVK</span></CodeLine>
<Link id="l00492" /><CodeLine lineNumber="492"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> (Imm != 0) &#123;</span></CodeLine>
<Link id="l00493" /><CodeLine lineNumber="493"><span class="doxyHighlight">    </span><span class="doxyHighlightKeywordType">unsigned</span><span class="doxyHighlight"> LZ = <a href="/docs/api/namespaces/llvm/#a66191f0bcc8c62b784819e9e96ceeba2">llvm::countl&#95;zero</a>(Imm);</span></CodeLine>
<Link id="l00494" /><CodeLine lineNumber="494"><span class="doxyHighlight">    </span><span class="doxyHighlightKeywordType">unsigned</span><span class="doxyHighlight"> TZ = <a href="/docs/api/namespaces/llvm/#a57d2f9ee99e9e68cff564d0d579c8163">llvm::countr&#95;zero</a>(Imm);</span></CodeLine>
<Link id="l00495" /><CodeLine lineNumber="495"><span class="doxyHighlight">    Shift = (TZ / 16) &#42; 16;</span></CodeLine>
<Link id="l00496" /><CodeLine lineNumber="496"><span class="doxyHighlight">    LastShift = ((63 - LZ) / 16) &#42; 16;</span></CodeLine>
<Link id="l00497" /><CodeLine lineNumber="497"><span class="doxyHighlight">  &#125;</span></CodeLine>
<Link id="l00498" /><CodeLine lineNumber="498"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordType">unsigned</span><span class="doxyHighlight"> Imm16 = (Imm &gt;&gt; Shift) &amp; Mask;</span></CodeLine>
<Link id="l00499" /><CodeLine lineNumber="499"></CodeLine>
<Link id="l00500" /><CodeLine lineNumber="500"><span class="doxyHighlight">  <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>.push&#95;back(&#123; FirstOpc, Imm16,</span></CodeLine>
<Link id="l00501" /><CodeLine lineNumber="501"><span class="doxyHighlight">                   <a href="/docs/api/namespaces/llvm/aarch64-am/#aeae88f12b667477f90db9b726556b337">AArch64&#95;AM::getShifterImm</a>(<a href="/docs/api/namespaces/llvm/aarch64-am/#a7e75394a33f6a5897d7a14c0ba5d44f1a1d97e13eb9923037fe733eda83b7f938">AArch64&#95;AM::LSL</a>, Shift) &#125;);</span></CodeLine>
<Link id="l00502" /><CodeLine lineNumber="502"></CodeLine>
<Link id="l00503" /><CodeLine lineNumber="503"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> (Shift == LastShift)</span></CodeLine>
<Link id="l00504" /><CodeLine lineNumber="504"><span class="doxyHighlight">    </span><span class="doxyHighlightKeywordFlow">return</span><span class="doxyHighlight">;</span></CodeLine>
<Link id="l00505" /><CodeLine lineNumber="505"></CodeLine>
<Link id="l00506" /><CodeLine lineNumber="506"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// If a MOVN was used for the high bits of a negative value, flip the rest</span></CodeLine>
<Link id="l00507" /><CodeLine lineNumber="507"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// of the bits back for use with MOVK.</span></CodeLine>
<Link id="l00508" /><CodeLine lineNumber="508"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> (<a href="/docs/api/files/lib/lib/codegen/complexdeinterleavingpass-cpp/#a2762113571c7956c9818c452b2d256ae">isNeg</a>)</span></CodeLine>
<Link id="l00509" /><CodeLine lineNumber="509"><span class="doxyHighlight">    Imm = ~Imm;</span></CodeLine>
<Link id="l00510" /><CodeLine lineNumber="510"></CodeLine>
<Link id="l00511" /><CodeLine lineNumber="511"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordType">unsigned</span><span class="doxyHighlight"> Opc = (BitSize == 32 ? AArch64::MOVKWi : AArch64::MOVKXi);</span></CodeLine>
<Link id="l00512" /><CodeLine lineNumber="512"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">while</span><span class="doxyHighlight"> (Shift &lt; LastShift) &#123;</span></CodeLine>
<Link id="l00513" /><CodeLine lineNumber="513"><span class="doxyHighlight">    Shift += 16;</span></CodeLine>
<Link id="l00514" /><CodeLine lineNumber="514"><span class="doxyHighlight">    Imm16 = (Imm &gt;&gt; Shift) &amp; Mask;</span></CodeLine>
<Link id="l00515" /><CodeLine lineNumber="515"><span class="doxyHighlight">    </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> (Imm16 == (<a href="/docs/api/files/lib/lib/codegen/complexdeinterleavingpass-cpp/#a2762113571c7956c9818c452b2d256ae">isNeg</a> ? Mask : 0))</span></CodeLine>
<Link id="l00516" /><CodeLine lineNumber="516"><span class="doxyHighlight">      </span><span class="doxyHighlightKeywordFlow">continue</span><span class="doxyHighlight">; </span><span class="doxyHighlightComment">// This 16-bit portion is already set correctly.</span></CodeLine>
<Link id="l00517" /><CodeLine lineNumber="517"></CodeLine>
<Link id="l00518" /><CodeLine lineNumber="518"><span class="doxyHighlight">    <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>.push&#95;back(&#123; Opc, Imm16,</span></CodeLine>
<Link id="l00519" /><CodeLine lineNumber="519"><span class="doxyHighlight">                     <a href="/docs/api/namespaces/llvm/aarch64-am/#aeae88f12b667477f90db9b726556b337">AArch64&#95;AM::getShifterImm</a>(<a href="/docs/api/namespaces/llvm/aarch64-am/#a7e75394a33f6a5897d7a14c0ba5d44f1a1d97e13eb9923037fe733eda83b7f938">AArch64&#95;AM::LSL</a>, Shift) &#125;);</span></CodeLine>
<Link id="l00520" /><CodeLine lineNumber="520"><span class="doxyHighlight">  &#125;</span></CodeLine>
<Link id="l00521" /><CodeLine lineNumber="521"></CodeLine>
<Link id="l00522" /><CodeLine lineNumber="522"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// Now, we get 16-bit divided Imm. If high and low bits are same in</span></CodeLine>
<Link id="l00523" /><CodeLine lineNumber="523"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// 32-bit, there is an opportunity to reduce instruction.</span></CodeLine>
<Link id="l00524" /><CodeLine lineNumber="524"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> (<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>.size() &gt; 2 &amp;&amp; (Imm &gt;&gt; 32) == (Imm &amp; 0xffffffffULL)) &#123;</span></CodeLine>
<Link id="l00525" /><CodeLine lineNumber="525"><span class="doxyHighlight">    </span><span class="doxyHighlightKeywordFlow">for</span><span class="doxyHighlight"> (</span><span class="doxyHighlightKeywordType">int</span><span class="doxyHighlight"> <a href="/docs/api/files/lib/lib/analysis/inlineorder-cpp/#a7ee6f0cb51c3b9056199e9a0001fe8c3a6f6cb72d544962fa333e2e34ce64f719">Size</a> = <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>.size(); <a href="/docs/api/files/lib/lib/analysis/inlineorder-cpp/#a7ee6f0cb51c3b9056199e9a0001fe8c3a6f6cb72d544962fa333e2e34ce64f719">Size</a> &gt; 2; <a href="/docs/api/files/lib/lib/analysis/inlineorder-cpp/#a7ee6f0cb51c3b9056199e9a0001fe8c3a6f6cb72d544962fa333e2e34ce64f719">Size</a>--)</span></CodeLine>
<Link id="l00526" /><CodeLine lineNumber="526"><span class="doxyHighlight">      <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>.pop&#95;back();</span></CodeLine>
<Link id="l00527" /><CodeLine lineNumber="527"><span class="doxyHighlight">    <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>.push&#95;back(&#123;AArch64::ORRXrs, 0, 32&#125;);</span></CodeLine>
<Link id="l00528" /><CodeLine lineNumber="528"><span class="doxyHighlight">  &#125;</span></CodeLine>
<Link id="l00529" /><CodeLine lineNumber="529"><span class="doxyHighlight">&#125;</span></CodeLine>
<Link id="l00530" /><CodeLine lineNumber="530"></CodeLine>
<Link id="l00531" /><CodeLine lineNumber="531"><span class="doxyHighlightComment">/// Expand a MOVi32imm or MOVi64imm pseudo instruction to one or more</span></CodeLine>
<Link id="l00532" /><CodeLine lineNumber="532"><span class="doxyHighlightComment">/// real move-immediate instructions to synthesize the immediate.</span></CodeLine>
<Link id="l00533" /><CodeLine lineNumber="533" lineLink="/docs/api/namespaces/llvm/aarch64-imm/#a77a4e6615fbc6c2bbcf179370dbd0fa9"><span class="doxyHighlightKeywordType">void</span><span class="doxyHighlight"> <a href="/docs/api/namespaces/llvm/aarch64-imm/#a77a4e6615fbc6c2bbcf179370dbd0fa9">AArch64&#95;IMM::expandMOVImm</a>(uint64&#95;t Imm, </span><span class="doxyHighlightKeywordType">unsigned</span><span class="doxyHighlight"> BitSize,</span></CodeLine>
<Link id="l00534" /><CodeLine lineNumber="534"><span class="doxyHighlight">                               <a href="/docs/api/classes/llvm/smallvectorimpl">SmallVectorImpl&lt;ImmInsnModel&gt;</a> &amp;<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>) &#123;</span></CodeLine>
<Link id="l00535" /><CodeLine lineNumber="535"><span class="doxyHighlight">  </span><span class="doxyHighlightKeyword">const</span><span class="doxyHighlight"> </span><span class="doxyHighlightKeywordType">unsigned</span><span class="doxyHighlight"> Mask = 0xFFFF;</span></CodeLine>
<Link id="l00536" /><CodeLine lineNumber="536"></CodeLine>
<Link id="l00537" /><CodeLine lineNumber="537"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// Scan the immediate and count the number of 16-bit chunks which are either</span></CodeLine>
<Link id="l00538" /><CodeLine lineNumber="538"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// all ones or all zeros.</span></CodeLine>
<Link id="l00539" /><CodeLine lineNumber="539"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordType">unsigned</span><span class="doxyHighlight"> OneChunks = 0;</span></CodeLine>
<Link id="l00540" /><CodeLine lineNumber="540"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordType">unsigned</span><span class="doxyHighlight"> ZeroChunks = 0;</span></CodeLine>
<Link id="l00541" /><CodeLine lineNumber="541"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">for</span><span class="doxyHighlight"> (</span><span class="doxyHighlightKeywordType">unsigned</span><span class="doxyHighlight"> Shift = 0; Shift &lt; BitSize; Shift += 16) &#123;</span></CodeLine>
<Link id="l00542" /><CodeLine lineNumber="542"><span class="doxyHighlight">    </span><span class="doxyHighlightKeyword">const</span><span class="doxyHighlight"> </span><span class="doxyHighlightKeywordType">unsigned</span><span class="doxyHighlight"> Chunk = (Imm &gt;&gt; Shift) &amp; Mask;</span></CodeLine>
<Link id="l00543" /><CodeLine lineNumber="543"><span class="doxyHighlight">    </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> (Chunk == Mask)</span></CodeLine>
<Link id="l00544" /><CodeLine lineNumber="544"><span class="doxyHighlight">      OneChunks++;</span></CodeLine>
<Link id="l00545" /><CodeLine lineNumber="545"><span class="doxyHighlight">    </span><span class="doxyHighlightKeywordFlow">else</span><span class="doxyHighlight"> </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> (Chunk == 0)</span></CodeLine>
<Link id="l00546" /><CodeLine lineNumber="546"><span class="doxyHighlight">      ZeroChunks++;</span></CodeLine>
<Link id="l00547" /><CodeLine lineNumber="547"><span class="doxyHighlight">  &#125;</span></CodeLine>
<Link id="l00548" /><CodeLine lineNumber="548"></CodeLine>
<Link id="l00549" /><CodeLine lineNumber="549"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// Prefer MOVZ/MOVN over ORR because of the rules for the &quot;mov&quot; alias.</span></CodeLine>
<Link id="l00550" /><CodeLine lineNumber="550"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> ((BitSize / 16) - OneChunks &lt;= 1 || (BitSize / 16) - ZeroChunks &lt;= 1) &#123;</span></CodeLine>
<Link id="l00551" /><CodeLine lineNumber="551"><span class="doxyHighlight">    <a href="#a2edf9e8f09bfb0cc4949aa1813872322">expandMOVImmSimple</a>(Imm, BitSize, OneChunks, ZeroChunks, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>);</span></CodeLine>
<Link id="l00552" /><CodeLine lineNumber="552"><span class="doxyHighlight">    </span><span class="doxyHighlightKeywordFlow">return</span><span class="doxyHighlight">;</span></CodeLine>
<Link id="l00553" /><CodeLine lineNumber="553"><span class="doxyHighlight">  &#125;</span></CodeLine>
<Link id="l00554" /><CodeLine lineNumber="554"></CodeLine>
<Link id="l00555" /><CodeLine lineNumber="555"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// Try a single ORR.</span></CodeLine>
<Link id="l00556" /><CodeLine lineNumber="556"><span class="doxyHighlight">  uint64&#95;t UImm = Imm &lt;&lt; (64 - BitSize) &gt;&gt; (64 - BitSize);</span></CodeLine>
<Link id="l00557" /><CodeLine lineNumber="557"><span class="doxyHighlight">  uint64&#95;t Encoding;</span></CodeLine>
<Link id="l00558" /><CodeLine lineNumber="558"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> (<a href="/docs/api/namespaces/llvm/aarch64-am/#a2cd3e23b97b495a98c0b723ab18e4d96">AArch64&#95;AM::processLogicalImmediate</a>(UImm, BitSize, Encoding)) &#123;</span></CodeLine>
<Link id="l00559" /><CodeLine lineNumber="559"><span class="doxyHighlight">    </span><span class="doxyHighlightKeywordType">unsigned</span><span class="doxyHighlight"> Opc = (BitSize == 32 ? AArch64::ORRWri : AArch64::ORRXri);</span></CodeLine>
<Link id="l00560" /><CodeLine lineNumber="560"><span class="doxyHighlight">    <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>.push&#95;back(&#123; Opc, 0, Encoding &#125;);</span></CodeLine>
<Link id="l00561" /><CodeLine lineNumber="561"><span class="doxyHighlight">    </span><span class="doxyHighlightKeywordFlow">return</span><span class="doxyHighlight">;</span></CodeLine>
<Link id="l00562" /><CodeLine lineNumber="562"><span class="doxyHighlight">  &#125;</span></CodeLine>
<Link id="l00563" /><CodeLine lineNumber="563"></CodeLine>
<Link id="l00564" /><CodeLine lineNumber="564"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// One to up three instruction sequences.</span></CodeLine>
<Link id="l00565" /><CodeLine lineNumber="565"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">//</span></CodeLine>
<Link id="l00566" /><CodeLine lineNumber="566"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// Prefer MOVZ/MOVN followed by MOVK; it&#39;s more readable, and possibly the</span></CodeLine>
<Link id="l00567" /><CodeLine lineNumber="567"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// fastest sequence with fast literal generation.</span></CodeLine>
<Link id="l00568" /><CodeLine lineNumber="568"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> (OneChunks &gt;= (BitSize / 16) - 2 || ZeroChunks &gt;= (BitSize / 16) - 2) &#123;</span></CodeLine>
<Link id="l00569" /><CodeLine lineNumber="569"><span class="doxyHighlight">    <a href="#a2edf9e8f09bfb0cc4949aa1813872322">expandMOVImmSimple</a>(Imm, BitSize, OneChunks, ZeroChunks, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>);</span></CodeLine>
<Link id="l00570" /><CodeLine lineNumber="570"><span class="doxyHighlight">    </span><span class="doxyHighlightKeywordFlow">return</span><span class="doxyHighlight">;</span></CodeLine>
<Link id="l00571" /><CodeLine lineNumber="571"><span class="doxyHighlight">  &#125;</span></CodeLine>
<Link id="l00572" /><CodeLine lineNumber="572"></CodeLine>
<Link id="l00573" /><CodeLine lineNumber="573"><span class="doxyHighlight">  <a href="/docs/api/files/lib/lib/target/lib/target/amdgpu/silowercontrolflow-cpp/#a4868c5d81c5ccc98c47aeab6244346a0">assert</a>(BitSize == 64 &amp;&amp; </span><span class="doxyHighlightStringLiteral">&quot;All 32-bit immediates can be expanded with a&quot;</span></CodeLine>
<Link id="l00574" /><CodeLine lineNumber="574"><span class="doxyHighlight">                          </span><span class="doxyHighlightStringLiteral">&quot;MOVZ/MOVK pair&quot;</span><span class="doxyHighlight">);</span></CodeLine>
<Link id="l00575" /><CodeLine lineNumber="575"></CodeLine>
<Link id="l00576" /><CodeLine lineNumber="576"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// Try other two-instruction sequences.</span></CodeLine>
<Link id="l00577" /><CodeLine lineNumber="577"></CodeLine>
<Link id="l00578" /><CodeLine lineNumber="578"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// 64-bit ORR followed by MOVK.</span></CodeLine>
<Link id="l00579" /><CodeLine lineNumber="579"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// We try to construct the ORR immediate in three different ways: either we</span></CodeLine>
<Link id="l00580" /><CodeLine lineNumber="580"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// zero out the chunk which will be replaced, we fill the chunk which will</span></CodeLine>
<Link id="l00581" /><CodeLine lineNumber="581"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// be replaced with ones, or we take the bit pattern from the other half of</span></CodeLine>
<Link id="l00582" /><CodeLine lineNumber="582"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// the 64-bit immediate. This is comprehensive because of the way ORR</span></CodeLine>
<Link id="l00583" /><CodeLine lineNumber="583"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// immediates are constructed.</span></CodeLine>
<Link id="l00584" /><CodeLine lineNumber="584"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">for</span><span class="doxyHighlight"> (</span><span class="doxyHighlightKeywordType">unsigned</span><span class="doxyHighlight"> Shift = 0; Shift &lt; BitSize; Shift += 16) &#123;</span></CodeLine>
<Link id="l00585" /><CodeLine lineNumber="585"><span class="doxyHighlight">    uint64&#95;t ShiftedMask = (0xFFFFULL &lt;&lt; Shift);</span></CodeLine>
<Link id="l00586" /><CodeLine lineNumber="586"><span class="doxyHighlight">    uint64&#95;t ZeroChunk = UImm &amp; ~ShiftedMask;</span></CodeLine>
<Link id="l00587" /><CodeLine lineNumber="587"><span class="doxyHighlight">    uint64&#95;t OneChunk = UImm | ShiftedMask;</span></CodeLine>
<Link id="l00588" /><CodeLine lineNumber="588"><span class="doxyHighlight">    uint64&#95;t RotatedImm = (UImm &lt;&lt; 32) | (UImm &gt;&gt; 32);</span></CodeLine>
<Link id="l00589" /><CodeLine lineNumber="589"><span class="doxyHighlight">    uint64&#95;t ReplicateChunk = ZeroChunk | (RotatedImm &amp; ShiftedMask);</span></CodeLine>
<Link id="l00590" /><CodeLine lineNumber="590"><span class="doxyHighlight">    </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> (<a href="/docs/api/namespaces/llvm/aarch64-am/#a2cd3e23b97b495a98c0b723ab18e4d96">AArch64&#95;AM::processLogicalImmediate</a>(ZeroChunk, BitSize, Encoding) ||</span></CodeLine>
<Link id="l00591" /><CodeLine lineNumber="591"><span class="doxyHighlight">        <a href="/docs/api/namespaces/llvm/aarch64-am/#a2cd3e23b97b495a98c0b723ab18e4d96">AArch64&#95;AM::processLogicalImmediate</a>(OneChunk, BitSize, Encoding) ||</span></CodeLine>
<Link id="l00592" /><CodeLine lineNumber="592"><span class="doxyHighlight">        <a href="/docs/api/namespaces/llvm/aarch64-am/#a2cd3e23b97b495a98c0b723ab18e4d96">AArch64&#95;AM::processLogicalImmediate</a>(ReplicateChunk, BitSize,</span></CodeLine>
<Link id="l00593" /><CodeLine lineNumber="593"><span class="doxyHighlight">                                            Encoding)) &#123;</span></CodeLine>
<Link id="l00594" /><CodeLine lineNumber="594"><span class="doxyHighlight">      </span><span class="doxyHighlightComment">// Create the ORR-immediate instruction.</span></CodeLine>
<Link id="l00595" /><CodeLine lineNumber="595"><span class="doxyHighlight">      <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>.push&#95;back(&#123; AArch64::ORRXri, 0, Encoding &#125;);</span></CodeLine>
<Link id="l00596" /><CodeLine lineNumber="596"></CodeLine>
<Link id="l00597" /><CodeLine lineNumber="597"><span class="doxyHighlight">      </span><span class="doxyHighlightComment">// Create the MOVK instruction.</span></CodeLine>
<Link id="l00598" /><CodeLine lineNumber="598"><span class="doxyHighlight">      </span><span class="doxyHighlightKeyword">const</span><span class="doxyHighlight"> </span><span class="doxyHighlightKeywordType">unsigned</span><span class="doxyHighlight"> Imm16 = <a href="#aa5bbae3632b4bfe0de4faea7a4da829f">getChunk</a>(UImm, Shift / 16);</span></CodeLine>
<Link id="l00599" /><CodeLine lineNumber="599"><span class="doxyHighlight">      <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>.push&#95;back(&#123; AArch64::MOVKXi, Imm16,</span></CodeLine>
<Link id="l00600" /><CodeLine lineNumber="600"><span class="doxyHighlight">           <a href="/docs/api/namespaces/llvm/aarch64-am/#aeae88f12b667477f90db9b726556b337">AArch64&#95;AM::getShifterImm</a>(<a href="/docs/api/namespaces/llvm/aarch64-am/#a7e75394a33f6a5897d7a14c0ba5d44f1a1d97e13eb9923037fe733eda83b7f938">AArch64&#95;AM::LSL</a>, Shift) &#125;);</span></CodeLine>
<Link id="l00601" /><CodeLine lineNumber="601"><span class="doxyHighlight">      </span><span class="doxyHighlightKeywordFlow">return</span><span class="doxyHighlight">;</span></CodeLine>
<Link id="l00602" /><CodeLine lineNumber="602"><span class="doxyHighlight">    &#125;</span></CodeLine>
<Link id="l00603" /><CodeLine lineNumber="603"><span class="doxyHighlight">  &#125;</span></CodeLine>
<Link id="l00604" /><CodeLine lineNumber="604"></CodeLine>
<Link id="l00605" /><CodeLine lineNumber="605"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// Attempt to use a sequence of two ORR-immediate instructions.</span></CodeLine>
<Link id="l00606" /><CodeLine lineNumber="606"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> (<a href="#ae492dde0ae62ef0c16a80f8b648bae19">tryOrrOfLogicalImmediates</a>(Imm, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>))</span></CodeLine>
<Link id="l00607" /><CodeLine lineNumber="607"><span class="doxyHighlight">    </span><span class="doxyHighlightKeywordFlow">return</span><span class="doxyHighlight">;</span></CodeLine>
<Link id="l00608" /><CodeLine lineNumber="608"></CodeLine>
<Link id="l00609" /><CodeLine lineNumber="609"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// Attempt to use a sequence of ORR-immediate followed by AND-immediate.</span></CodeLine>
<Link id="l00610" /><CodeLine lineNumber="610"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> (<a href="#aa20f3eb24c28efa9c93053a733a172c1">tryAndOfLogicalImmediates</a>(Imm, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>))</span></CodeLine>
<Link id="l00611" /><CodeLine lineNumber="611"><span class="doxyHighlight">    </span><span class="doxyHighlightKeywordFlow">return</span><span class="doxyHighlight">;</span></CodeLine>
<Link id="l00612" /><CodeLine lineNumber="612"></CodeLine>
<Link id="l00613" /><CodeLine lineNumber="613"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// Attempt to use a sequence of ORR-immediate followed by EOR-immediate.</span></CodeLine>
<Link id="l00614" /><CodeLine lineNumber="614"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> (<a href="#ab2f723b31c9dbe46610248a047805046">tryEorOfLogicalImmediates</a>(UImm, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>))</span></CodeLine>
<Link id="l00615" /><CodeLine lineNumber="615"><span class="doxyHighlight">    </span><span class="doxyHighlightKeywordFlow">return</span><span class="doxyHighlight">;</span></CodeLine>
<Link id="l00616" /><CodeLine lineNumber="616"></CodeLine>
<Link id="l00617" /><CodeLine lineNumber="617"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// FIXME: Add more two-instruction sequences.</span></CodeLine>
<Link id="l00618" /><CodeLine lineNumber="618"></CodeLine>
<Link id="l00619" /><CodeLine lineNumber="619"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// Three instruction sequences.</span></CodeLine>
<Link id="l00620" /><CodeLine lineNumber="620"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">//</span></CodeLine>
<Link id="l00621" /><CodeLine lineNumber="621"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// Prefer MOVZ/MOVN followed by two MOVK; it&#39;s more readable, and possibly</span></CodeLine>
<Link id="l00622" /><CodeLine lineNumber="622"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// the fastest sequence with fast literal generation. (If neither MOVK is</span></CodeLine>
<Link id="l00623" /><CodeLine lineNumber="623"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// part of a fast literal generation pair, it could be slower than the</span></CodeLine>
<Link id="l00624" /><CodeLine lineNumber="624"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// four-instruction sequence, but we won&#39;t worry about that for now.)</span></CodeLine>
<Link id="l00625" /><CodeLine lineNumber="625"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> (OneChunks || ZeroChunks) &#123;</span></CodeLine>
<Link id="l00626" /><CodeLine lineNumber="626"><span class="doxyHighlight">    <a href="#a2edf9e8f09bfb0cc4949aa1813872322">expandMOVImmSimple</a>(Imm, BitSize, OneChunks, ZeroChunks, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>);</span></CodeLine>
<Link id="l00627" /><CodeLine lineNumber="627"><span class="doxyHighlight">    </span><span class="doxyHighlightKeywordFlow">return</span><span class="doxyHighlight">;</span></CodeLine>
<Link id="l00628" /><CodeLine lineNumber="628"><span class="doxyHighlight">  &#125;</span></CodeLine>
<Link id="l00629" /><CodeLine lineNumber="629"></CodeLine>
<Link id="l00630" /><CodeLine lineNumber="630"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// Check for identical 16-bit chunks within the constant and if so materialize</span></CodeLine>
<Link id="l00631" /><CodeLine lineNumber="631"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// them with a single ORR instruction. The remaining one or two 16-bit chunks</span></CodeLine>
<Link id="l00632" /><CodeLine lineNumber="632"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// will be materialized with MOVK instructions.</span></CodeLine>
<Link id="l00633" /><CodeLine lineNumber="633"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> (BitSize == 64 &amp;&amp; <a href="#a6efd5b30fe34a042d2937ba63a73ad07">tryToreplicateChunks</a>(UImm, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>))</span></CodeLine>
<Link id="l00634" /><CodeLine lineNumber="634"><span class="doxyHighlight">    </span><span class="doxyHighlightKeywordFlow">return</span><span class="doxyHighlight">;</span></CodeLine>
<Link id="l00635" /><CodeLine lineNumber="635"></CodeLine>
<Link id="l00636" /><CodeLine lineNumber="636"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// Check whether the constant contains a sequence of contiguous ones, which</span></CodeLine>
<Link id="l00637" /><CodeLine lineNumber="637"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// might be interrupted by one or two chunks. If so, materialize the sequence</span></CodeLine>
<Link id="l00638" /><CodeLine lineNumber="638"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// of contiguous ones with an ORR instruction. Materialize the chunks which</span></CodeLine>
<Link id="l00639" /><CodeLine lineNumber="639"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// are either interrupting the sequence or outside of the sequence with a</span></CodeLine>
<Link id="l00640" /><CodeLine lineNumber="640"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// MOVK instruction.</span></CodeLine>
<Link id="l00641" /><CodeLine lineNumber="641"><span class="doxyHighlight">  </span><span class="doxyHighlightKeywordFlow">if</span><span class="doxyHighlight"> (BitSize == 64 &amp;&amp; <a href="#a7000ac817f63a64697020f0538311927">trySequenceOfOnes</a>(UImm, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>))</span></CodeLine>
<Link id="l00642" /><CodeLine lineNumber="642"><span class="doxyHighlight">    </span><span class="doxyHighlightKeywordFlow">return</span><span class="doxyHighlight">;</span></CodeLine>
<Link id="l00643" /><CodeLine lineNumber="643"></CodeLine>
<Link id="l00644" /><CodeLine lineNumber="644"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// We found no possible two or three instruction sequence; use the general</span></CodeLine>
<Link id="l00645" /><CodeLine lineNumber="645"><span class="doxyHighlight">  </span><span class="doxyHighlightComment">// four-instruction sequence.</span></CodeLine>
<Link id="l00646" /><CodeLine lineNumber="646"><span class="doxyHighlight">  <a href="#a2edf9e8f09bfb0cc4949aa1813872322">expandMOVImmSimple</a>(Imm, BitSize, OneChunks, ZeroChunks, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>);</span></CodeLine>
<Link id="l00647" /><CodeLine lineNumber="647"><span class="doxyHighlight">&#125;</span></CodeLine>

</ProgramListing>


</DoxygenPage>
