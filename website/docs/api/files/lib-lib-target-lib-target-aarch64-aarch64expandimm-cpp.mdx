---

# DO NOT EDIT!
# Automatically generated via docusaurus-plugin-doxygen by Doxygen.

slug: /api/files/lib/lib/target/lib/target/aarch64/aarch64expandimm-cpp
custom_edit_url: null
keywords:
  - doxygen
  - reference
  - file

---

import Link from '@docusaurus/Link'

import CodeLine from '@xpack/docusaurus-plugin-doxygen/components/CodeLine'
import DoxygenPage from '@xpack/docusaurus-plugin-doxygen/components/DoxygenPage'
import Highlight from '@xpack/docusaurus-plugin-doxygen/components/Highlight'
import IncludesList from '@xpack/docusaurus-plugin-doxygen/components/IncludesList'
import IncludesListItem from '@xpack/docusaurus-plugin-doxygen/components/IncludesListItem'
import MemberDefinition from '@xpack/docusaurus-plugin-doxygen/components/MemberDefinition'
import MembersIndex from '@xpack/docusaurus-plugin-doxygen/components/MembersIndex'
import MembersIndexItem from '@xpack/docusaurus-plugin-doxygen/components/MembersIndexItem'
import ProgramListing from '@xpack/docusaurus-plugin-doxygen/components/ProgramListing'
import SectionDefinition from '@xpack/docusaurus-plugin-doxygen/components/SectionDefinition'

import pluginConfig from '@site/docusaurus-plugin-doxygen-config.json'

# The `AArch64ExpandImm.cpp` File Reference

<DoxygenPage pluginConfig={pluginConfig}>



## Included Headers

<IncludesList>
<IncludesListItem
  filePath="AArch64.h"
  permalink="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64-h"
  isLocal="true" />
<IncludesListItem
  filePath="AArch64ExpandImm.h"
  permalink="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64expandimm-h"
  isLocal="true" />
<IncludesListItem
  filePath="MCTargetDesc/AArch64AddressingModes.h"
  permalink="/docs/api/files/lib/lib/target/lib/target/aarch64/lib/target/aarch64/mctargetdesc/aarch64addressingmodes-h"
  isLocal="true" />
</IncludesList>

## Functions Index

<MembersIndex>

<MembersIndexItem
  type="bool"
  name={<><a href="#a436cd44154cf245c297b6b5a5fac9a84">canUseOrr</a> (uint64&#95;t Chunk, uint64&#95;t &amp;Encoding)</>}>
<a href="/docs/api/namespaces/llvm/check">Check</a> whether the given 16-bit chunk replicated to full 64-bit width can be materialized with an ORR instruction. <a href="#a436cd44154cf245c297b6b5a5fac9a84">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<>std::optional&lt; std::pair&lt; uint64&#95;t, uint64&#95;t &gt; &gt;</>}
  name={<><a href="#aeb71b2a77bd02c4e0e01aecf2d392452">decomposeIntoOrrOfLogicalImmediates</a> (uint64&#95;t UImm)</>}>
</MembersIndexItem>

<MembersIndexItem
  type="void"
  name={<><a href="#a2edf9e8f09bfb0cc4949aa1813872322">expandMOVImmSimple</a> (uint64&#95;t Imm, unsigned BitSize, unsigned OneChunks, unsigned ZeroChunks, SmallVectorImpl&lt; ImmInsnModel &gt; &amp;Insn)</>}>
Expand a MOVi32imm or MOVi64imm pseudo instruction to a MOVZ or MOVN of width BitSize followed by up to 3 MOVK instructions. <a href="#a2edf9e8f09bfb0cc4949aa1813872322">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<>uint64&#95;t</>}
  name={<><a href="#aa5bbae3632b4bfe0de4faea7a4da829f">getChunk</a> (uint64&#95;t Imm, unsigned ChunkIdx)</>}>
Helper function which extracts the specified 16-bit chunk from a 64-bit value. <a href="#aa5bbae3632b4bfe0de4faea7a4da829f">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<>uint64&#95;t</>}
  name={<><a href="#a2e2936fed450c145238eeca56cf4572e">GetRunOfOnesStartingAt</a> (uint64&#95;t V, uint64&#95;t StartPosition)</>}>
</MembersIndexItem>

<MembersIndexItem
  type="bool"
  name={<><a href="#add895e8580b9acacceb10b92edcd4d37">isEndChunk</a> (uint64&#95;t Chunk)</>}>
<a href="/docs/api/namespaces/llvm/check">Check</a> whether this chunk matches the pattern &#39;0...1...&#39; This pattern ends a contiguous sequence of ones if we look at the bits from the LSB towards the MSB. <a href="#add895e8580b9acacceb10b92edcd4d37">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="bool"
  name={<><a href="#ad84ff3d34cc228b799e8bc2f070fc4ab">isStartChunk</a> (uint64&#95;t Chunk)</>}>
<a href="/docs/api/namespaces/llvm/check">Check</a> whether this chunk matches the pattern &#39;1...0...&#39;. <a href="#ad84ff3d34cc228b799e8bc2f070fc4ab">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<>uint64&#95;t</>}
  name={<><a href="#ad62d9bcb5891de134deb4465831a762b">maximalLogicalImmWithin</a> (uint64&#95;t RemainingBits, uint64&#95;t OriginalBits)</>}>
</MembersIndexItem>

<MembersIndexItem
  type={<>uint64&#95;t</>}
  name={<><a href="#a78822aec5f2ccbac50c2b2ac068dc7d7">MaximallyReplicateSubImmediate</a> (uint64&#95;t V, uint64&#95;t Subset)</>}>
</MembersIndexItem>

<MembersIndexItem
  type="bool"
  name={<><a href="#aa20f3eb24c28efa9c93053a733a172c1">tryAndOfLogicalImmediates</a> (uint64&#95;t UImm, SmallVectorImpl&lt; ImmInsnModel &gt; &amp;Insn)</>}>
</MembersIndexItem>

<MembersIndexItem
  type="bool"
  name={<><a href="#ab2f723b31c9dbe46610248a047805046">tryEorOfLogicalImmediates</a> (uint64&#95;t Imm, SmallVectorImpl&lt; ImmInsnModel &gt; &amp;Insn)</>}>
</MembersIndexItem>

<MembersIndexItem
  type="bool"
  name={<><a href="#ae492dde0ae62ef0c16a80f8b648bae19">tryOrrOfLogicalImmediates</a> (uint64&#95;t UImm, SmallVectorImpl&lt; ImmInsnModel &gt; &amp;Insn)</>}>
</MembersIndexItem>

<MembersIndexItem
  type="bool"
  name={<><a href="#a7000ac817f63a64697020f0538311927">trySequenceOfOnes</a> (uint64&#95;t UImm, SmallVectorImpl&lt; ImmInsnModel &gt; &amp;Insn)</>}>
<a href="/docs/api/namespaces/llvm/check">Check</a> whether the constant contains a sequence of contiguous ones, which might be interrupted by one or two chunks. <a href="#a7000ac817f63a64697020f0538311927">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type="bool"
  name={<><a href="#a6efd5b30fe34a042d2937ba63a73ad07">tryToreplicateChunks</a> (uint64&#95;t UImm, SmallVectorImpl&lt; ImmInsnModel &gt; &amp;Insn)</>}>
<a href="/docs/api/namespaces/llvm/check">Check</a> for identical 16-bit chunks within the constant and if so materialize them with a single ORR instruction. <a href="#a6efd5b30fe34a042d2937ba63a73ad07">More...</a>
</MembersIndexItem>

<MembersIndexItem
  type={<>uint64&#95;t</>}
  name={<><a href="#a4323e3fa0f558ea22393bc68e9520b27">updateImm</a> (uint64&#95;t Imm, unsigned Idx, bool Clear)</>}>
Clear or set all bits in the chunk at the given index. <a href="#a4323e3fa0f558ea22393bc68e9520b27">More...</a>
</MembersIndexItem>

</MembersIndex>


<SectionDefinition>

## Functions

### canUseOrr() {#a436cd44154cf245c297b6b5a5fac9a84}

<MemberDefinition
  prototype={<>static bool canUseOrr (uint64&#95;t Chunk, uint64&#95;t &amp; Encoding)</>}
  labels = {["static"]}>
<a href="/docs/api/namespaces/llvm/check">Check</a> whether the given 16-bit chunk replicated to full 64-bit width can be materialized with an ORR instruction.

Definition at line <a href="#l00030">30</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64expandimm-cpp">AArch64ExpandImm.cpp</a>.
</MemberDefinition>

### decomposeIntoOrrOfLogicalImmediates() {#aeb71b2a77bd02c4e0e01aecf2d392452}

<MemberDefinition
  prototype={<>static std::optional&lt; std::pair&lt; uint64&#95;t, uint64&#95;t &gt; &gt; decomposeIntoOrrOfLogicalImmediates (uint64&#95;t UImm)</>}
  labels = {["static"]}>

Definition at line <a href="#l00288">288</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64expandimm-cpp">AArch64ExpandImm.cpp</a>.
</MemberDefinition>

### expandMOVImmSimple() {#a2edf9e8f09bfb0cc4949aa1813872322}

<MemberDefinition
  prototype={<>static void expandMOVImmSimple (uint64&#95;t Imm, unsigned BitSize, unsigned OneChunks, unsigned ZeroChunks, <a href="/docs/api/classes/llvm/smallvectorimpl">SmallVectorImpl</a>&lt; <a href="/docs/api/structs/llvm/aarch64-imm/imminsnmodel">ImmInsnModel</a> &gt; &amp; Insn)</>}
  labels = {["inline", "static"]}>
Expand a MOVi32imm or MOVi64imm pseudo instruction to a MOVZ or MOVN of width BitSize followed by up to 3 MOVK instructions.

Definition at line <a href="#l00466">466</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64expandimm-cpp">AArch64ExpandImm.cpp</a>.
</MemberDefinition>

### getChunk() {#aa5bbae3632b4bfe0de4faea7a4da829f}

<MemberDefinition
  prototype={<>static uint64&#95;t getChunk (uint64&#95;t Imm, unsigned ChunkIdx)</>}
  labels = {["static"]}>
Helper function which extracts the specified 16-bit chunk from a 64-bit value.

Definition at line <a href="#l00022">22</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64expandimm-cpp">AArch64ExpandImm.cpp</a>.
</MemberDefinition>

### GetRunOfOnesStartingAt() {#a2e2936fed450c145238eeca56cf4572e}

<MemberDefinition
  prototype={<>static uint64&#95;t GetRunOfOnesStartingAt (uint64&#95;t V, uint64&#95;t StartPosition)</>}
  labels = {["static"]}>

Definition at line <a href="#l00242">242</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64expandimm-cpp">AArch64ExpandImm.cpp</a>.
</MemberDefinition>

### isEndChunk() {#add895e8580b9acacceb10b92edcd4d37}

<MemberDefinition
  prototype={<>static bool isEndChunk (uint64&#95;t Chunk)</>}
  labels = {["static"]}>
<a href="/docs/api/namespaces/llvm/check">Check</a> whether this chunk matches the pattern &#39;0...1...&#39; This pattern ends a contiguous sequence of ones if we look at the bits from the LSB towards the MSB.

Definition at line <a href="#l00116">116</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64expandimm-cpp">AArch64ExpandImm.cpp</a>.
</MemberDefinition>

### isStartChunk() {#ad84ff3d34cc228b799e8bc2f070fc4ab}

<MemberDefinition
  prototype={<>static bool isStartChunk (uint64&#95;t Chunk)</>}
  labels = {["static"]}>
<a href="/docs/api/namespaces/llvm/check">Check</a> whether this chunk matches the pattern &#39;1...0...&#39;.

This pattern starts a contiguous sequence of ones if we look at the bits from the LSB towards the MSB.

Definition at line <a href="#l00106">106</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64expandimm-cpp">AArch64ExpandImm.cpp</a>.
</MemberDefinition>

### maximalLogicalImmWithin() {#ad62d9bcb5891de134deb4465831a762b}

<MemberDefinition
  prototype={<>static uint64&#95;t maximalLogicalImmWithin (uint64&#95;t RemainingBits, uint64&#95;t OriginalBits)</>}
  labels = {["static"]}>

Definition at line <a href="#l00272">272</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64expandimm-cpp">AArch64ExpandImm.cpp</a>.
</MemberDefinition>

### MaximallyReplicateSubImmediate() {#a78822aec5f2ccbac50c2b2ac068dc7d7}

<MemberDefinition
  prototype={<>static uint64&#95;t MaximallyReplicateSubImmediate (uint64&#95;t V, uint64&#95;t Subset)</>}
  labels = {["static"]}>

Definition at line <a href="#l00254">254</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64expandimm-cpp">AArch64ExpandImm.cpp</a>.
</MemberDefinition>

### tryAndOfLogicalImmediates() {#aa20f3eb24c28efa9c93053a733a172c1}

<MemberDefinition
  prototype={<>static bool tryAndOfLogicalImmediates (uint64&#95;t UImm, <a href="/docs/api/classes/llvm/smallvectorimpl">SmallVectorImpl</a>&lt; <a href="/docs/api/structs/llvm/aarch64-imm/imminsnmodel">ImmInsnModel</a> &gt; &amp; Insn)</>}
  labels = {["static"]}>

Definition at line <a href="#l00341">341</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64expandimm-cpp">AArch64ExpandImm.cpp</a>.
</MemberDefinition>

### tryEorOfLogicalImmediates() {#ab2f723b31c9dbe46610248a047805046}

<MemberDefinition
  prototype={<>static bool tryEorOfLogicalImmediates (uint64&#95;t Imm, <a href="/docs/api/classes/llvm/smallvectorimpl">SmallVectorImpl</a>&lt; <a href="/docs/api/structs/llvm/aarch64-imm/imminsnmodel">ImmInsnModel</a> &gt; &amp; Insn)</>}
  labels = {["static"]}>

Definition at line <a href="#l00373">373</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64expandimm-cpp">AArch64ExpandImm.cpp</a>.
</MemberDefinition>

### tryOrrOfLogicalImmediates() {#ae492dde0ae62ef0c16a80f8b648bae19}

<MemberDefinition
  prototype={<>static bool tryOrrOfLogicalImmediates (uint64&#95;t UImm, <a href="/docs/api/classes/llvm/smallvectorimpl">SmallVectorImpl</a>&lt; <a href="/docs/api/structs/llvm/aarch64-imm/imminsnmodel">ImmInsnModel</a> &gt; &amp; Insn)</>}
  labels = {["static"]}>

Definition at line <a href="#l00316">316</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64expandimm-cpp">AArch64ExpandImm.cpp</a>.
</MemberDefinition>

### trySequenceOfOnes() {#a7000ac817f63a64697020f0538311927}

<MemberDefinition
  prototype={<>static bool trySequenceOfOnes (uint64&#95;t UImm, <a href="/docs/api/classes/llvm/smallvectorimpl">SmallVectorImpl</a>&lt; <a href="/docs/api/structs/llvm/aarch64-imm/imminsnmodel">ImmInsnModel</a> &gt; &amp; Insn)</>}
  labels = {["static"]}>
<a href="/docs/api/namespaces/llvm/check">Check</a> whether the constant contains a sequence of contiguous ones, which might be interrupted by one or two chunks.

If so, materialize the sequence of contiguous ones with an ORR instruction. Materialize the chunks which are either interrupting the sequence or outside of the sequence with a MOVK instruction.

Assuming S is a chunk which starts the sequence (1...0...), E is a chunk which ends the sequence (0...1...). Then we are looking for constants which contain at least one S and E chunk. E.g. |E|A|B|S|, |A|E|B|S| or |A|B|E|S|.

We are also looking for constants like |S|A|B|E| where the contiguous sequence of ones wraps around the MSB into the LSB.

Definition at line <a href="#l00150">150</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64expandimm-cpp">AArch64ExpandImm.cpp</a>.
</MemberDefinition>

### tryToreplicateChunks() {#a6efd5b30fe34a042d2937ba63a73ad07}

<MemberDefinition
  prototype={<>static bool tryToreplicateChunks (uint64&#95;t UImm, <a href="/docs/api/classes/llvm/smallvectorimpl">SmallVectorImpl</a>&lt; <a href="/docs/api/structs/llvm/aarch64-imm/imminsnmodel">ImmInsnModel</a> &gt; &amp; Insn)</>}
  labels = {["static"]}>
<a href="/docs/api/namespaces/llvm/check">Check</a> for identical 16-bit chunks within the constant and if so materialize them with a single ORR instruction.

The remaining one or two 16-bit chunks will be materialized with MOVK instructions.

This allows us to materialize constants like |A|B|A|A| or |A|B|C|A| (order of the chunks doesn&#39;t matter), assuming |A|A|A|A| can be materialized with an ORR instruction.

Definition at line <a href="#l00043">43</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64expandimm-cpp">AArch64ExpandImm.cpp</a>.
</MemberDefinition>

### updateImm() {#a4323e3fa0f558ea22393bc68e9520b27}

<MemberDefinition
  prototype={<>static uint64&#95;t updateImm (uint64&#95;t Imm, unsigned Idx, bool Clear)</>}
  labels = {["static"]}>
Clear or set all bits in the chunk at the given index.

Definition at line <a href="#l00124">124</a> of file <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64expandimm-cpp">AArch64ExpandImm.cpp</a>.
</MemberDefinition>

</SectionDefinition>

## File Listing

The file content with the documentation metadata removed is:

<ProgramListing>

<Link id="l00001" /><CodeLine lineNumber="1"><Highlight kind="comment">//===- AArch64ExpandImm.h - AArch64 Immediate Expansion -------------------===//</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00002" /><CodeLine lineNumber="2"><Highlight kind="normal"></Highlight><Highlight kind="comment">//</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00003" /><CodeLine lineNumber="3"><Highlight kind="normal"></Highlight><Highlight kind="comment">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00004" /><CodeLine lineNumber="4"><Highlight kind="normal"></Highlight><Highlight kind="comment">// See https://llvm.org/LICENSE.txt for license information.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00005" /><CodeLine lineNumber="5"><Highlight kind="normal"></Highlight><Highlight kind="comment">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00006" /><CodeLine lineNumber="6"><Highlight kind="normal"></Highlight><Highlight kind="comment">//</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00007" /><CodeLine lineNumber="7"><Highlight kind="normal"></Highlight><Highlight kind="comment">//===----------------------------------------------------------------------===//</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00008" /><CodeLine lineNumber="8"><Highlight kind="normal"></Highlight><Highlight kind="comment">//</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00009" /><CodeLine lineNumber="9"><Highlight kind="normal"></Highlight><Highlight kind="comment">// This file implements the AArch64ExpandImm stuff.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00010" /><CodeLine lineNumber="10"><Highlight kind="normal"></Highlight><Highlight kind="comment">//</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00011" /><CodeLine lineNumber="11"><Highlight kind="normal"></Highlight><Highlight kind="comment">//===----------------------------------------------------------------------===//</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00012" /><CodeLine lineNumber="12"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00013" /><CodeLine lineNumber="13"><Highlight kind="normal"></Highlight><Highlight kind="preprocessor">#include &quot;<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64-h">AArch64.h</a>&quot;</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00014" /><CodeLine lineNumber="14"><Highlight kind="normal"></Highlight><Highlight kind="preprocessor">#include &quot;<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64expandimm-h">AArch64ExpandImm.h</a>&quot;</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00015" /><CodeLine lineNumber="15"><Highlight kind="normal"></Highlight><Highlight kind="preprocessor">#include &quot;<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/lib/target/aarch64/mctargetdesc/aarch64addressingmodes-h">MCTargetDesc/AArch64AddressingModes.h</a>&quot;</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00016" /><CodeLine lineNumber="16"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00017" /><CodeLine lineNumber="17"><Highlight kind="normal"></Highlight><Highlight kind="keyword">using namespace </Highlight><Highlight kind="normal"><a href="/docs/api/namespaces/llvm">llvm</a>;</Highlight></CodeLine>
<Link id="l00018" /><CodeLine lineNumber="18"><Highlight kind="normal"></Highlight><Highlight kind="keyword">using namespace </Highlight><Highlight kind="normal"><a href="/docs/api/namespaces/llvm/aarch64-imm">llvm::AArch64&#95;IMM</a>;</Highlight></CodeLine>
<Link id="l00019" /><CodeLine lineNumber="19"><Highlight kind="normal"></Highlight><Highlight kind="comment"></Highlight></CodeLine>
<Link id="l00020" /><CodeLine lineNumber="20"><Highlight kind="comment">/// Helper function which extracts the specified 16-bit chunk from a</Highlight></CodeLine>
<Link id="l00021" /><CodeLine lineNumber="21"><Highlight kind="comment">/// 64-bit value.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00022" /><CodeLine lineNumber="22" lineLink="#aa5bbae3632b4bfe0de4faea7a4da829f"><Highlight kind="normal"></Highlight><Highlight kind="keyword">static</Highlight><Highlight kind="normal"> uint64&#95;t <a href="#aa5bbae3632b4bfe0de4faea7a4da829f">getChunk</a>(uint64&#95;t Imm, </Highlight><Highlight kind="keywordtype">unsigned</Highlight><Highlight kind="normal"> ChunkIdx) &#123;</Highlight></CodeLine>
<Link id="l00023" /><CodeLine lineNumber="23"><Highlight kind="normal">  <a href="/docs/api/files/lib/lib/target/lib/target/amdgpu/silowercontrolflow-cpp/#a4868c5d81c5ccc98c47aeab6244346a0">assert</a>(ChunkIdx &lt; 4 &amp;&amp; </Highlight><Highlight kind="stringliteral">&quot;Out of range chunk index specified!&quot;</Highlight><Highlight kind="normal">);</Highlight></CodeLine>
<Link id="l00024" /><CodeLine lineNumber="24"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00025" /><CodeLine lineNumber="25"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">return</Highlight><Highlight kind="normal"> (Imm &gt;&gt; (ChunkIdx &#42; 16)) &amp; 0xFFFF;</Highlight></CodeLine>
<Link id="l00026" /><CodeLine lineNumber="26"><Highlight kind="normal">&#125;</Highlight></CodeLine>
<Link id="l00027" /><CodeLine lineNumber="27"><Highlight kind="normal"></Highlight><Highlight kind="comment"></Highlight></CodeLine>
<Link id="l00028" /><CodeLine lineNumber="28"><Highlight kind="comment">/// Check whether the given 16-bit chunk replicated to full 64-bit width</Highlight></CodeLine>
<Link id="l00029" /><CodeLine lineNumber="29"><Highlight kind="comment">/// can be materialized with an ORR instruction.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00030" /><CodeLine lineNumber="30" lineLink="#a436cd44154cf245c297b6b5a5fac9a84"><Highlight kind="normal"></Highlight><Highlight kind="keyword">static</Highlight><Highlight kind="normal"> </Highlight><Highlight kind="keywordtype">bool</Highlight><Highlight kind="normal"> <a href="#a436cd44154cf245c297b6b5a5fac9a84">canUseOrr</a>(uint64&#95;t Chunk, uint64&#95;t &amp;Encoding) &#123;</Highlight></CodeLine>
<Link id="l00031" /><CodeLine lineNumber="31"><Highlight kind="normal">  Chunk = (Chunk &lt;&lt; 48) | (Chunk &lt;&lt; 32) | (Chunk &lt;&lt; 16) | Chunk;</Highlight></CodeLine>
<Link id="l00032" /><CodeLine lineNumber="32"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00033" /><CodeLine lineNumber="33"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">return</Highlight><Highlight kind="normal"> <a href="/docs/api/namespaces/llvm/aarch64-am/#a2cd3e23b97b495a98c0b723ab18e4d96">AArch64&#95;AM::processLogicalImmediate</a>(Chunk, 64, Encoding);</Highlight></CodeLine>
<Link id="l00034" /><CodeLine lineNumber="34"><Highlight kind="normal">&#125;</Highlight></CodeLine>
<Link id="l00035" /><CodeLine lineNumber="35"><Highlight kind="normal"></Highlight><Highlight kind="comment"></Highlight></CodeLine>
<Link id="l00036" /><CodeLine lineNumber="36"><Highlight kind="comment">/// Check for identical 16-bit chunks within the constant and if so</Highlight></CodeLine>
<Link id="l00037" /><CodeLine lineNumber="37"><Highlight kind="comment">/// materialize them with a single ORR instruction. The remaining one or two</Highlight></CodeLine>
<Link id="l00038" /><CodeLine lineNumber="38"><Highlight kind="comment">/// 16-bit chunks will be materialized with MOVK instructions.</Highlight></CodeLine>
<Link id="l00039" /><CodeLine lineNumber="39"><Highlight kind="comment">///</Highlight></CodeLine>
<Link id="l00040" /><CodeLine lineNumber="40"><Highlight kind="comment">/// This allows us to materialize constants like |A|B|A|A| or |A|B|C|A| (order</Highlight></CodeLine>
<Link id="l00041" /><CodeLine lineNumber="41"><Highlight kind="comment">/// of the chunks doesn&#39;t matter), assuming |A|A|A|A| can be materialized with</Highlight></CodeLine>
<Link id="l00042" /><CodeLine lineNumber="42"><Highlight kind="comment">/// an ORR instruction.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00043" /><CodeLine lineNumber="43" lineLink="#a6efd5b30fe34a042d2937ba63a73ad07"><Highlight kind="normal"></Highlight><Highlight kind="keyword">static</Highlight><Highlight kind="normal"> </Highlight><Highlight kind="keywordtype">bool</Highlight><Highlight kind="normal"> <a href="#a6efd5b30fe34a042d2937ba63a73ad07">tryToreplicateChunks</a>(uint64&#95;t UImm,</Highlight></CodeLine>
<Link id="l00044" /><CodeLine lineNumber="44"><Highlight kind="normal">         <a href="/docs/api/classes/llvm/smallvectorimpl">SmallVectorImpl&lt;ImmInsnModel&gt;</a> &amp;<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>) &#123;</Highlight></CodeLine>
<Link id="l00045" /><CodeLine lineNumber="45"><Highlight kind="normal">  </Highlight><Highlight kind="keyword">using </Highlight><Highlight kind="normal">CountMap = <a href="/docs/api/classes/llvm/densemap">DenseMap&lt;uint64&#95;t, unsigned&gt;</a>;</Highlight></CodeLine>
<Link id="l00046" /><CodeLine lineNumber="46"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00047" /><CodeLine lineNumber="47"><Highlight kind="normal">  CountMap Counts;</Highlight></CodeLine>
<Link id="l00048" /><CodeLine lineNumber="48"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00049" /><CodeLine lineNumber="49"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// Scan the constant and count how often every chunk occurs.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00050" /><CodeLine lineNumber="50"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">for</Highlight><Highlight kind="normal"> (</Highlight><Highlight kind="keywordtype">unsigned</Highlight><Highlight kind="normal"> Idx = 0; Idx &lt; 4; ++Idx)</Highlight></CodeLine>
<Link id="l00051" /><CodeLine lineNumber="51"><Highlight kind="normal">    ++Counts&#91;<a href="#aa5bbae3632b4bfe0de4faea7a4da829f">getChunk</a>(UImm, Idx)&#93;;</Highlight></CodeLine>
<Link id="l00052" /><CodeLine lineNumber="52"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00053" /><CodeLine lineNumber="53"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// Traverse the chunks to find one which occurs more than once.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00054" /><CodeLine lineNumber="54"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">for</Highlight><Highlight kind="normal"> (</Highlight><Highlight kind="keyword">const</Highlight><Highlight kind="normal"> </Highlight><Highlight kind="keyword">auto</Highlight><Highlight kind="normal"> &amp;Chunk : Counts) &#123;</Highlight></CodeLine>
<Link id="l00055" /><CodeLine lineNumber="55"><Highlight kind="normal">    </Highlight><Highlight kind="keyword">const</Highlight><Highlight kind="normal"> uint64&#95;t ChunkVal = Chunk.first;</Highlight></CodeLine>
<Link id="l00056" /><CodeLine lineNumber="56"><Highlight kind="normal">    </Highlight><Highlight kind="keyword">const</Highlight><Highlight kind="normal"> </Highlight><Highlight kind="keywordtype">unsigned</Highlight><Highlight kind="normal"> <a href="/docs/api/namespaces/llvm/#a845e08be4b0320d66901a66b0c0e9509">Count</a> = Chunk.second;</Highlight></CodeLine>
<Link id="l00057" /><CodeLine lineNumber="57"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00058" /><CodeLine lineNumber="58"><Highlight kind="normal">    uint64&#95;t Encoding = 0;</Highlight></CodeLine>
<Link id="l00059" /><CodeLine lineNumber="59"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00060" /><CodeLine lineNumber="60"><Highlight kind="normal">    </Highlight><Highlight kind="comment">// We are looking for chunks which have two or three instances and can be</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00061" /><CodeLine lineNumber="61"><Highlight kind="normal">    </Highlight><Highlight kind="comment">// materialized with an ORR instruction.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00062" /><CodeLine lineNumber="62"><Highlight kind="normal">    </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> ((<a href="/docs/api/namespaces/llvm/#a845e08be4b0320d66901a66b0c0e9509">Count</a> != 2 &amp;&amp; <a href="/docs/api/namespaces/llvm/#a845e08be4b0320d66901a66b0c0e9509">Count</a> != 3) || !<a href="#a436cd44154cf245c297b6b5a5fac9a84">canUseOrr</a>(ChunkVal, Encoding))</Highlight></CodeLine>
<Link id="l00063" /><CodeLine lineNumber="63"><Highlight kind="normal">      </Highlight><Highlight kind="keywordflow">continue</Highlight><Highlight kind="normal">;</Highlight></CodeLine>
<Link id="l00064" /><CodeLine lineNumber="64"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00065" /><CodeLine lineNumber="65"><Highlight kind="normal">    </Highlight><Highlight kind="keyword">const</Highlight><Highlight kind="normal"> </Highlight><Highlight kind="keywordtype">bool</Highlight><Highlight kind="normal"> CountThree = <a href="/docs/api/namespaces/llvm/#a845e08be4b0320d66901a66b0c0e9509">Count</a> == 3;</Highlight></CodeLine>
<Link id="l00066" /><CodeLine lineNumber="66"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00067" /><CodeLine lineNumber="67"><Highlight kind="normal">    <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>.push&#95;back(&#123; AArch64::ORRXri, 0, Encoding &#125;);</Highlight></CodeLine>
<Link id="l00068" /><CodeLine lineNumber="68"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00069" /><CodeLine lineNumber="69"><Highlight kind="normal">    </Highlight><Highlight kind="keywordtype">unsigned</Highlight><Highlight kind="normal"> ShiftAmt = 0;</Highlight></CodeLine>
<Link id="l00070" /><CodeLine lineNumber="70"><Highlight kind="normal">    uint64&#95;t Imm16 = 0;</Highlight></CodeLine>
<Link id="l00071" /><CodeLine lineNumber="71"><Highlight kind="normal">    </Highlight><Highlight kind="comment">// Find the first chunk not materialized with the ORR instruction.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00072" /><CodeLine lineNumber="72"><Highlight kind="normal">    </Highlight><Highlight kind="keywordflow">for</Highlight><Highlight kind="normal"> (; ShiftAmt &lt; 64; ShiftAmt += 16) &#123;</Highlight></CodeLine>
<Link id="l00073" /><CodeLine lineNumber="73"><Highlight kind="normal">      Imm16 = (UImm &gt;&gt; ShiftAmt) &amp; 0xFFFF;</Highlight></CodeLine>
<Link id="l00074" /><CodeLine lineNumber="74"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00075" /><CodeLine lineNumber="75"><Highlight kind="normal">      </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> (Imm16 != ChunkVal)</Highlight></CodeLine>
<Link id="l00076" /><CodeLine lineNumber="76"><Highlight kind="normal">        </Highlight><Highlight kind="keywordflow">break</Highlight><Highlight kind="normal">;</Highlight></CodeLine>
<Link id="l00077" /><CodeLine lineNumber="77"><Highlight kind="normal">    &#125;</Highlight></CodeLine>
<Link id="l00078" /><CodeLine lineNumber="78"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00079" /><CodeLine lineNumber="79"><Highlight kind="normal">    </Highlight><Highlight kind="comment">// Create the first MOVK instruction.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00080" /><CodeLine lineNumber="80"><Highlight kind="normal">    <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>.push&#95;back(&#123; AArch64::MOVKXi, Imm16,</Highlight></CodeLine>
<Link id="l00081" /><CodeLine lineNumber="81"><Highlight kind="normal">         <a href="/docs/api/namespaces/llvm/aarch64-am/#aeae88f12b667477f90db9b726556b337">AArch64&#95;AM::getShifterImm</a>(<a href="/docs/api/namespaces/llvm/aarch64-am/#a7e75394a33f6a5897d7a14c0ba5d44f1a1d97e13eb9923037fe733eda83b7f938">AArch64&#95;AM::LSL</a>, ShiftAmt) &#125;);</Highlight></CodeLine>
<Link id="l00082" /><CodeLine lineNumber="82"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00083" /><CodeLine lineNumber="83"><Highlight kind="normal">    </Highlight><Highlight kind="comment">// In case we have three instances the whole constant is now materialized</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00084" /><CodeLine lineNumber="84"><Highlight kind="normal">    </Highlight><Highlight kind="comment">// and we can exit.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00085" /><CodeLine lineNumber="85"><Highlight kind="normal">    </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> (CountThree)</Highlight></CodeLine>
<Link id="l00086" /><CodeLine lineNumber="86"><Highlight kind="normal">      </Highlight><Highlight kind="keywordflow">return</Highlight><Highlight kind="normal"> </Highlight><Highlight kind="keyword">true</Highlight><Highlight kind="normal">;</Highlight></CodeLine>
<Link id="l00087" /><CodeLine lineNumber="87"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00088" /><CodeLine lineNumber="88"><Highlight kind="normal">    </Highlight><Highlight kind="comment">// Find the remaining chunk which needs to be materialized.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00089" /><CodeLine lineNumber="89"><Highlight kind="normal">    </Highlight><Highlight kind="keywordflow">for</Highlight><Highlight kind="normal"> (ShiftAmt += 16; ShiftAmt &lt; 64; ShiftAmt += 16) &#123;</Highlight></CodeLine>
<Link id="l00090" /><CodeLine lineNumber="90"><Highlight kind="normal">      Imm16 = (UImm &gt;&gt; ShiftAmt) &amp; 0xFFFF;</Highlight></CodeLine>
<Link id="l00091" /><CodeLine lineNumber="91"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00092" /><CodeLine lineNumber="92"><Highlight kind="normal">      </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> (Imm16 != ChunkVal)</Highlight></CodeLine>
<Link id="l00093" /><CodeLine lineNumber="93"><Highlight kind="normal">        </Highlight><Highlight kind="keywordflow">break</Highlight><Highlight kind="normal">;</Highlight></CodeLine>
<Link id="l00094" /><CodeLine lineNumber="94"><Highlight kind="normal">    &#125;</Highlight></CodeLine>
<Link id="l00095" /><CodeLine lineNumber="95"><Highlight kind="normal">    <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>.push&#95;back(&#123; AArch64::MOVKXi, Imm16,</Highlight></CodeLine>
<Link id="l00096" /><CodeLine lineNumber="96"><Highlight kind="normal">                     <a href="/docs/api/namespaces/llvm/aarch64-am/#aeae88f12b667477f90db9b726556b337">AArch64&#95;AM::getShifterImm</a>(<a href="/docs/api/namespaces/llvm/aarch64-am/#a7e75394a33f6a5897d7a14c0ba5d44f1a1d97e13eb9923037fe733eda83b7f938">AArch64&#95;AM::LSL</a>, ShiftAmt) &#125;);</Highlight></CodeLine>
<Link id="l00097" /><CodeLine lineNumber="97"><Highlight kind="normal">    </Highlight><Highlight kind="keywordflow">return</Highlight><Highlight kind="normal"> </Highlight><Highlight kind="keyword">true</Highlight><Highlight kind="normal">;</Highlight></CodeLine>
<Link id="l00098" /><CodeLine lineNumber="98"><Highlight kind="normal">  &#125;</Highlight></CodeLine>
<Link id="l00099" /><CodeLine lineNumber="99"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00100" /><CodeLine lineNumber="100"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">return</Highlight><Highlight kind="normal"> </Highlight><Highlight kind="keyword">false</Highlight><Highlight kind="normal">;</Highlight></CodeLine>
<Link id="l00101" /><CodeLine lineNumber="101"><Highlight kind="normal">&#125;</Highlight></CodeLine>
<Link id="l00102" /><CodeLine lineNumber="102"><Highlight kind="normal"></Highlight><Highlight kind="comment"></Highlight></CodeLine>
<Link id="l00103" /><CodeLine lineNumber="103"><Highlight kind="comment">/// Check whether this chunk matches the pattern &#39;1...0...&#39;. This pattern</Highlight></CodeLine>
<Link id="l00104" /><CodeLine lineNumber="104"><Highlight kind="comment">/// starts a contiguous sequence of ones if we look at the bits from the LSB</Highlight></CodeLine>
<Link id="l00105" /><CodeLine lineNumber="105"><Highlight kind="comment">/// towards the MSB.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00106" /><CodeLine lineNumber="106" lineLink="#ad84ff3d34cc228b799e8bc2f070fc4ab"><Highlight kind="normal"></Highlight><Highlight kind="keyword">static</Highlight><Highlight kind="normal"> </Highlight><Highlight kind="keywordtype">bool</Highlight><Highlight kind="normal"> <a href="#ad84ff3d34cc228b799e8bc2f070fc4ab">isStartChunk</a>(uint64&#95;t Chunk) &#123;</Highlight></CodeLine>
<Link id="l00107" /><CodeLine lineNumber="107"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> (Chunk == 0 || Chunk == std::numeric&#95;limits&lt;uint64&#95;t&gt;::max())</Highlight></CodeLine>
<Link id="l00108" /><CodeLine lineNumber="108"><Highlight kind="normal">    </Highlight><Highlight kind="keywordflow">return</Highlight><Highlight kind="normal"> </Highlight><Highlight kind="keyword">false</Highlight><Highlight kind="normal">;</Highlight></CodeLine>
<Link id="l00109" /><CodeLine lineNumber="109"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00110" /><CodeLine lineNumber="110"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">return</Highlight><Highlight kind="normal"> <a href="/docs/api/namespaces/llvm/#a82a9558b6319303ae62f59dab9669685">isMask&#95;64</a>(~Chunk);</Highlight></CodeLine>
<Link id="l00111" /><CodeLine lineNumber="111"><Highlight kind="normal">&#125;</Highlight></CodeLine>
<Link id="l00112" /><CodeLine lineNumber="112"><Highlight kind="normal"></Highlight><Highlight kind="comment"></Highlight></CodeLine>
<Link id="l00113" /><CodeLine lineNumber="113"><Highlight kind="comment">/// Check whether this chunk matches the pattern &#39;0...1...&#39; This pattern</Highlight></CodeLine>
<Link id="l00114" /><CodeLine lineNumber="114"><Highlight kind="comment">/// ends a contiguous sequence of ones if we look at the bits from the LSB</Highlight></CodeLine>
<Link id="l00115" /><CodeLine lineNumber="115"><Highlight kind="comment">/// towards the MSB.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00116" /><CodeLine lineNumber="116" lineLink="#add895e8580b9acacceb10b92edcd4d37"><Highlight kind="normal"></Highlight><Highlight kind="keyword">static</Highlight><Highlight kind="normal"> </Highlight><Highlight kind="keywordtype">bool</Highlight><Highlight kind="normal"> <a href="#add895e8580b9acacceb10b92edcd4d37">isEndChunk</a>(uint64&#95;t Chunk) &#123;</Highlight></CodeLine>
<Link id="l00117" /><CodeLine lineNumber="117"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> (Chunk == 0 || Chunk == std::numeric&#95;limits&lt;uint64&#95;t&gt;::max())</Highlight></CodeLine>
<Link id="l00118" /><CodeLine lineNumber="118"><Highlight kind="normal">    </Highlight><Highlight kind="keywordflow">return</Highlight><Highlight kind="normal"> </Highlight><Highlight kind="keyword">false</Highlight><Highlight kind="normal">;</Highlight></CodeLine>
<Link id="l00119" /><CodeLine lineNumber="119"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00120" /><CodeLine lineNumber="120"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">return</Highlight><Highlight kind="normal"> <a href="/docs/api/namespaces/llvm/#a82a9558b6319303ae62f59dab9669685">isMask&#95;64</a>(Chunk);</Highlight></CodeLine>
<Link id="l00121" /><CodeLine lineNumber="121"><Highlight kind="normal">&#125;</Highlight></CodeLine>
<Link id="l00122" /><CodeLine lineNumber="122"><Highlight kind="normal"></Highlight><Highlight kind="comment"></Highlight></CodeLine>
<Link id="l00123" /><CodeLine lineNumber="123"><Highlight kind="comment">/// Clear or set all bits in the chunk at the given index.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00124" /><CodeLine lineNumber="124" lineLink="#a4323e3fa0f558ea22393bc68e9520b27"><Highlight kind="normal"></Highlight><Highlight kind="keyword">static</Highlight><Highlight kind="normal"> uint64&#95;t <a href="#a4323e3fa0f558ea22393bc68e9520b27">updateImm</a>(uint64&#95;t Imm, </Highlight><Highlight kind="keywordtype">unsigned</Highlight><Highlight kind="normal"> Idx, </Highlight><Highlight kind="keywordtype">bool</Highlight><Highlight kind="normal"> Clear) &#123;</Highlight></CodeLine>
<Link id="l00125" /><CodeLine lineNumber="125"><Highlight kind="normal">  </Highlight><Highlight kind="keyword">const</Highlight><Highlight kind="normal"> uint64&#95;t Mask = 0xFFFF;</Highlight></CodeLine>
<Link id="l00126" /><CodeLine lineNumber="126"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00127" /><CodeLine lineNumber="127"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> (Clear)</Highlight></CodeLine>
<Link id="l00128" /><CodeLine lineNumber="128"><Highlight kind="normal">    </Highlight><Highlight kind="comment">// Clear chunk in the immediate.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00129" /><CodeLine lineNumber="129"><Highlight kind="normal">    Imm &amp;= ~(Mask &lt;&lt; (Idx &#42; 16));</Highlight></CodeLine>
<Link id="l00130" /><CodeLine lineNumber="130"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">else</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00131" /><CodeLine lineNumber="131"><Highlight kind="normal">    </Highlight><Highlight kind="comment">// Set all bits in the immediate for the particular chunk.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00132" /><CodeLine lineNumber="132"><Highlight kind="normal">    Imm |= Mask &lt;&lt; (Idx &#42; 16);</Highlight></CodeLine>
<Link id="l00133" /><CodeLine lineNumber="133"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00134" /><CodeLine lineNumber="134"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">return</Highlight><Highlight kind="normal"> Imm;</Highlight></CodeLine>
<Link id="l00135" /><CodeLine lineNumber="135"><Highlight kind="normal">&#125;</Highlight></CodeLine>
<Link id="l00136" /><CodeLine lineNumber="136"><Highlight kind="normal"></Highlight><Highlight kind="comment"></Highlight></CodeLine>
<Link id="l00137" /><CodeLine lineNumber="137"><Highlight kind="comment">/// Check whether the constant contains a sequence of contiguous ones,</Highlight></CodeLine>
<Link id="l00138" /><CodeLine lineNumber="138"><Highlight kind="comment">/// which might be interrupted by one or two chunks. If so, materialize the</Highlight></CodeLine>
<Link id="l00139" /><CodeLine lineNumber="139"><Highlight kind="comment">/// sequence of contiguous ones with an ORR instruction.</Highlight></CodeLine>
<Link id="l00140" /><CodeLine lineNumber="140"><Highlight kind="comment">/// Materialize the chunks which are either interrupting the sequence or outside</Highlight></CodeLine>
<Link id="l00141" /><CodeLine lineNumber="141"><Highlight kind="comment">/// of the sequence with a MOVK instruction.</Highlight></CodeLine>
<Link id="l00142" /><CodeLine lineNumber="142"><Highlight kind="comment">///</Highlight></CodeLine>
<Link id="l00143" /><CodeLine lineNumber="143"><Highlight kind="comment">/// Assuming S is a chunk which starts the sequence (1...0...), E is a chunk</Highlight></CodeLine>
<Link id="l00144" /><CodeLine lineNumber="144"><Highlight kind="comment">/// which ends the sequence (0...1...). Then we are looking for constants which</Highlight></CodeLine>
<Link id="l00145" /><CodeLine lineNumber="145"><Highlight kind="comment">/// contain at least one S and E chunk.</Highlight></CodeLine>
<Link id="l00146" /><CodeLine lineNumber="146"><Highlight kind="comment">/// E.g. |E|A|B|S|, |A|E|B|S| or |A|B|E|S|.</Highlight></CodeLine>
<Link id="l00147" /><CodeLine lineNumber="147"><Highlight kind="comment">///</Highlight></CodeLine>
<Link id="l00148" /><CodeLine lineNumber="148"><Highlight kind="comment">/// We are also looking for constants like |S|A|B|E| where the contiguous</Highlight></CodeLine>
<Link id="l00149" /><CodeLine lineNumber="149"><Highlight kind="comment">/// sequence of ones wraps around the MSB into the LSB.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00150" /><CodeLine lineNumber="150" lineLink="#a7000ac817f63a64697020f0538311927"><Highlight kind="normal"></Highlight><Highlight kind="keyword">static</Highlight><Highlight kind="normal"> </Highlight><Highlight kind="keywordtype">bool</Highlight><Highlight kind="normal"> <a href="#a7000ac817f63a64697020f0538311927">trySequenceOfOnes</a>(uint64&#95;t UImm,</Highlight></CodeLine>
<Link id="l00151" /><CodeLine lineNumber="151"><Highlight kind="normal">                              <a href="/docs/api/classes/llvm/smallvectorimpl">SmallVectorImpl&lt;ImmInsnModel&gt;</a> &amp;<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>) &#123;</Highlight></CodeLine>
<Link id="l00152" /><CodeLine lineNumber="152"><Highlight kind="normal">  </Highlight><Highlight kind="keyword">const</Highlight><Highlight kind="normal"> </Highlight><Highlight kind="keywordtype">int</Highlight><Highlight kind="normal"> NotSet = -1;</Highlight></CodeLine>
<Link id="l00153" /><CodeLine lineNumber="153"><Highlight kind="normal">  </Highlight><Highlight kind="keyword">const</Highlight><Highlight kind="normal"> uint64&#95;t Mask = 0xFFFF;</Highlight></CodeLine>
<Link id="l00154" /><CodeLine lineNumber="154"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00155" /><CodeLine lineNumber="155"><Highlight kind="normal">  </Highlight><Highlight kind="keywordtype">int</Highlight><Highlight kind="normal"> StartIdx = NotSet;</Highlight></CodeLine>
<Link id="l00156" /><CodeLine lineNumber="156"><Highlight kind="normal">  </Highlight><Highlight kind="keywordtype">int</Highlight><Highlight kind="normal"> EndIdx = NotSet;</Highlight></CodeLine>
<Link id="l00157" /><CodeLine lineNumber="157"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// Try to find the chunks which start/end a contiguous sequence of ones.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00158" /><CodeLine lineNumber="158"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">for</Highlight><Highlight kind="normal"> (</Highlight><Highlight kind="keywordtype">int</Highlight><Highlight kind="normal"> Idx = 0; Idx &lt; 4; ++Idx) &#123;</Highlight></CodeLine>
<Link id="l00159" /><CodeLine lineNumber="159"><Highlight kind="normal">    int64&#95;t Chunk = <a href="#aa5bbae3632b4bfe0de4faea7a4da829f">getChunk</a>(UImm, Idx);</Highlight></CodeLine>
<Link id="l00160" /><CodeLine lineNumber="160"><Highlight kind="normal">    </Highlight><Highlight kind="comment">// Sign extend the 16-bit chunk to 64-bit.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00161" /><CodeLine lineNumber="161"><Highlight kind="normal">    Chunk = (Chunk &lt;&lt; 48) &gt;&gt; 48;</Highlight></CodeLine>
<Link id="l00162" /><CodeLine lineNumber="162"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00163" /><CodeLine lineNumber="163"><Highlight kind="normal">    </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> (<a href="#ad84ff3d34cc228b799e8bc2f070fc4ab">isStartChunk</a>(Chunk))</Highlight></CodeLine>
<Link id="l00164" /><CodeLine lineNumber="164"><Highlight kind="normal">      StartIdx = Idx;</Highlight></CodeLine>
<Link id="l00165" /><CodeLine lineNumber="165"><Highlight kind="normal">    </Highlight><Highlight kind="keywordflow">else</Highlight><Highlight kind="normal"> </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> (<a href="#add895e8580b9acacceb10b92edcd4d37">isEndChunk</a>(Chunk))</Highlight></CodeLine>
<Link id="l00166" /><CodeLine lineNumber="166"><Highlight kind="normal">      EndIdx = Idx;</Highlight></CodeLine>
<Link id="l00167" /><CodeLine lineNumber="167"><Highlight kind="normal">  &#125;</Highlight></CodeLine>
<Link id="l00168" /><CodeLine lineNumber="168"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00169" /><CodeLine lineNumber="169"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// Early exit in case we can&#39;t find a start/end chunk.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00170" /><CodeLine lineNumber="170"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> (StartIdx == NotSet || EndIdx == NotSet)</Highlight></CodeLine>
<Link id="l00171" /><CodeLine lineNumber="171"><Highlight kind="normal">    </Highlight><Highlight kind="keywordflow">return</Highlight><Highlight kind="normal"> </Highlight><Highlight kind="keyword">false</Highlight><Highlight kind="normal">;</Highlight></CodeLine>
<Link id="l00172" /><CodeLine lineNumber="172"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00173" /><CodeLine lineNumber="173"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// Outside of the contiguous sequence of ones everything needs to be zero.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00174" /><CodeLine lineNumber="174"><Highlight kind="normal">  uint64&#95;t Outside = 0;</Highlight></CodeLine>
<Link id="l00175" /><CodeLine lineNumber="175"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// Chunks between the start and end chunk need to have all their bits set.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00176" /><CodeLine lineNumber="176"><Highlight kind="normal">  uint64&#95;t Inside = Mask;</Highlight></CodeLine>
<Link id="l00177" /><CodeLine lineNumber="177"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00178" /><CodeLine lineNumber="178"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// If our contiguous sequence of ones wraps around from the MSB into the LSB,</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00179" /><CodeLine lineNumber="179"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// just swap indices and pretend we are materializing a contiguous sequence</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00180" /><CodeLine lineNumber="180"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// of zeros surrounded by a contiguous sequence of ones.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00181" /><CodeLine lineNumber="181"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> (StartIdx &gt; EndIdx) &#123;</Highlight></CodeLine>
<Link id="l00182" /><CodeLine lineNumber="182"><Highlight kind="normal">    <a href="/docs/api/namespaces/std/#ab8424022895aee3e366fb9a32f2883cb">std::swap</a>(StartIdx, EndIdx);</Highlight></CodeLine>
<Link id="l00183" /><CodeLine lineNumber="183"><Highlight kind="normal">    <a href="/docs/api/namespaces/std/#ab8424022895aee3e366fb9a32f2883cb">std::swap</a>(Outside, Inside);</Highlight></CodeLine>
<Link id="l00184" /><CodeLine lineNumber="184"><Highlight kind="normal">  &#125;</Highlight></CodeLine>
<Link id="l00185" /><CodeLine lineNumber="185"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00186" /><CodeLine lineNumber="186"><Highlight kind="normal">  uint64&#95;t OrrImm = UImm;</Highlight></CodeLine>
<Link id="l00187" /><CodeLine lineNumber="187"><Highlight kind="normal">  </Highlight><Highlight kind="keywordtype">int</Highlight><Highlight kind="normal"> FirstMovkIdx = NotSet;</Highlight></CodeLine>
<Link id="l00188" /><CodeLine lineNumber="188"><Highlight kind="normal">  </Highlight><Highlight kind="keywordtype">int</Highlight><Highlight kind="normal"> SecondMovkIdx = NotSet;</Highlight></CodeLine>
<Link id="l00189" /><CodeLine lineNumber="189"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00190" /><CodeLine lineNumber="190"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// Find out which chunks we need to patch up to obtain a contiguous sequence</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00191" /><CodeLine lineNumber="191"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// of ones.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00192" /><CodeLine lineNumber="192"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">for</Highlight><Highlight kind="normal"> (</Highlight><Highlight kind="keywordtype">int</Highlight><Highlight kind="normal"> Idx = 0; Idx &lt; 4; ++Idx) &#123;</Highlight></CodeLine>
<Link id="l00193" /><CodeLine lineNumber="193"><Highlight kind="normal">    </Highlight><Highlight kind="keyword">const</Highlight><Highlight kind="normal"> uint64&#95;t Chunk = <a href="#aa5bbae3632b4bfe0de4faea7a4da829f">getChunk</a>(UImm, Idx);</Highlight></CodeLine>
<Link id="l00194" /><CodeLine lineNumber="194"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00195" /><CodeLine lineNumber="195"><Highlight kind="normal">    </Highlight><Highlight kind="comment">// Check whether we are looking at a chunk which is not part of the</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00196" /><CodeLine lineNumber="196"><Highlight kind="normal">    </Highlight><Highlight kind="comment">// contiguous sequence of ones.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00197" /><CodeLine lineNumber="197"><Highlight kind="normal">    </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> ((Idx &lt; StartIdx || EndIdx &lt; Idx) &amp;&amp; Chunk != Outside) &#123;</Highlight></CodeLine>
<Link id="l00198" /><CodeLine lineNumber="198"><Highlight kind="normal">      OrrImm = <a href="#a4323e3fa0f558ea22393bc68e9520b27">updateImm</a>(OrrImm, Idx, Outside == 0);</Highlight></CodeLine>
<Link id="l00199" /><CodeLine lineNumber="199"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00200" /><CodeLine lineNumber="200"><Highlight kind="normal">      </Highlight><Highlight kind="comment">// Remember the index we need to patch.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00201" /><CodeLine lineNumber="201"><Highlight kind="normal">      </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> (FirstMovkIdx == NotSet)</Highlight></CodeLine>
<Link id="l00202" /><CodeLine lineNumber="202"><Highlight kind="normal">        FirstMovkIdx = Idx;</Highlight></CodeLine>
<Link id="l00203" /><CodeLine lineNumber="203"><Highlight kind="normal">      </Highlight><Highlight kind="keywordflow">else</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00204" /><CodeLine lineNumber="204"><Highlight kind="normal">        SecondMovkIdx = Idx;</Highlight></CodeLine>
<Link id="l00205" /><CodeLine lineNumber="205"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00206" /><CodeLine lineNumber="206"><Highlight kind="normal">      </Highlight><Highlight kind="comment">// Check whether we are looking a chunk which is part of the contiguous</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00207" /><CodeLine lineNumber="207"><Highlight kind="normal">      </Highlight><Highlight kind="comment">// sequence of ones.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00208" /><CodeLine lineNumber="208"><Highlight kind="normal">    &#125; </Highlight><Highlight kind="keywordflow">else</Highlight><Highlight kind="normal"> </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> (Idx &gt; StartIdx &amp;&amp; Idx &lt; EndIdx &amp;&amp; Chunk != Inside) &#123;</Highlight></CodeLine>
<Link id="l00209" /><CodeLine lineNumber="209"><Highlight kind="normal">      OrrImm = <a href="#a4323e3fa0f558ea22393bc68e9520b27">updateImm</a>(OrrImm, Idx, Inside != Mask);</Highlight></CodeLine>
<Link id="l00210" /><CodeLine lineNumber="210"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00211" /><CodeLine lineNumber="211"><Highlight kind="normal">      </Highlight><Highlight kind="comment">// Remember the index we need to patch.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00212" /><CodeLine lineNumber="212"><Highlight kind="normal">      </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> (FirstMovkIdx == NotSet)</Highlight></CodeLine>
<Link id="l00213" /><CodeLine lineNumber="213"><Highlight kind="normal">        FirstMovkIdx = Idx;</Highlight></CodeLine>
<Link id="l00214" /><CodeLine lineNumber="214"><Highlight kind="normal">      </Highlight><Highlight kind="keywordflow">else</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00215" /><CodeLine lineNumber="215"><Highlight kind="normal">        SecondMovkIdx = Idx;</Highlight></CodeLine>
<Link id="l00216" /><CodeLine lineNumber="216"><Highlight kind="normal">    &#125;</Highlight></CodeLine>
<Link id="l00217" /><CodeLine lineNumber="217"><Highlight kind="normal">  &#125;</Highlight></CodeLine>
<Link id="l00218" /><CodeLine lineNumber="218"><Highlight kind="normal">  <a href="/docs/api/files/lib/lib/target/lib/target/amdgpu/silowercontrolflow-cpp/#a4868c5d81c5ccc98c47aeab6244346a0">assert</a>(FirstMovkIdx != NotSet &amp;&amp; </Highlight><Highlight kind="stringliteral">&quot;Constant materializable with single ORR!&quot;</Highlight><Highlight kind="normal">);</Highlight></CodeLine>
<Link id="l00219" /><CodeLine lineNumber="219"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00220" /><CodeLine lineNumber="220"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// Create the ORR-immediate instruction.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00221" /><CodeLine lineNumber="221"><Highlight kind="normal">  uint64&#95;t Encoding = 0;</Highlight></CodeLine>
<Link id="l00222" /><CodeLine lineNumber="222"><Highlight kind="normal">  <a href="/docs/api/namespaces/llvm/aarch64-am/#a2cd3e23b97b495a98c0b723ab18e4d96">AArch64&#95;AM::processLogicalImmediate</a>(OrrImm, 64, Encoding);</Highlight></CodeLine>
<Link id="l00223" /><CodeLine lineNumber="223"><Highlight kind="normal">  <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>.push&#95;back(&#123; AArch64::ORRXri, 0, Encoding &#125;);</Highlight></CodeLine>
<Link id="l00224" /><CodeLine lineNumber="224"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00225" /><CodeLine lineNumber="225"><Highlight kind="normal">  </Highlight><Highlight kind="keyword">const</Highlight><Highlight kind="normal"> </Highlight><Highlight kind="keywordtype">bool</Highlight><Highlight kind="normal"> SingleMovk = SecondMovkIdx == NotSet;</Highlight></CodeLine>
<Link id="l00226" /><CodeLine lineNumber="226"><Highlight kind="normal">  <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>.push&#95;back(&#123; AArch64::MOVKXi, <a href="#aa5bbae3632b4bfe0de4faea7a4da829f">getChunk</a>(UImm, FirstMovkIdx),</Highlight></CodeLine>
<Link id="l00227" /><CodeLine lineNumber="227"><Highlight kind="normal">                   <a href="/docs/api/namespaces/llvm/aarch64-am/#aeae88f12b667477f90db9b726556b337">AArch64&#95;AM::getShifterImm</a>(<a href="/docs/api/namespaces/llvm/aarch64-am/#a7e75394a33f6a5897d7a14c0ba5d44f1a1d97e13eb9923037fe733eda83b7f938">AArch64&#95;AM::LSL</a>,</Highlight></CodeLine>
<Link id="l00228" /><CodeLine lineNumber="228"><Highlight kind="normal">                                             FirstMovkIdx &#42; 16) &#125;);</Highlight></CodeLine>
<Link id="l00229" /><CodeLine lineNumber="229"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00230" /><CodeLine lineNumber="230"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// Early exit in case we only need to emit a single MOVK instruction.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00231" /><CodeLine lineNumber="231"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> (SingleMovk)</Highlight></CodeLine>
<Link id="l00232" /><CodeLine lineNumber="232"><Highlight kind="normal">    </Highlight><Highlight kind="keywordflow">return</Highlight><Highlight kind="normal"> </Highlight><Highlight kind="keyword">true</Highlight><Highlight kind="normal">;</Highlight></CodeLine>
<Link id="l00233" /><CodeLine lineNumber="233"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00234" /><CodeLine lineNumber="234"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// Create the second MOVK instruction.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00235" /><CodeLine lineNumber="235"><Highlight kind="normal">  <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>.push&#95;back(&#123; AArch64::MOVKXi, <a href="#aa5bbae3632b4bfe0de4faea7a4da829f">getChunk</a>(UImm, SecondMovkIdx),</Highlight></CodeLine>
<Link id="l00236" /><CodeLine lineNumber="236"><Highlight kind="normal">             <a href="/docs/api/namespaces/llvm/aarch64-am/#aeae88f12b667477f90db9b726556b337">AArch64&#95;AM::getShifterImm</a>(<a href="/docs/api/namespaces/llvm/aarch64-am/#a7e75394a33f6a5897d7a14c0ba5d44f1a1d97e13eb9923037fe733eda83b7f938">AArch64&#95;AM::LSL</a>,</Highlight></CodeLine>
<Link id="l00237" /><CodeLine lineNumber="237"><Highlight kind="normal">                                             SecondMovkIdx &#42; 16) &#125;);</Highlight></CodeLine>
<Link id="l00238" /><CodeLine lineNumber="238"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00239" /><CodeLine lineNumber="239"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">return</Highlight><Highlight kind="normal"> </Highlight><Highlight kind="keyword">true</Highlight><Highlight kind="normal">;</Highlight></CodeLine>
<Link id="l00240" /><CodeLine lineNumber="240"><Highlight kind="normal">&#125;</Highlight></CodeLine>
<Link id="l00241" /><CodeLine lineNumber="241"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00242" /><CodeLine lineNumber="242" lineLink="#a2e2936fed450c145238eeca56cf4572e"><Highlight kind="normal"></Highlight><Highlight kind="keyword">static</Highlight><Highlight kind="normal"> uint64&#95;t <a href="#a2e2936fed450c145238eeca56cf4572e">GetRunOfOnesStartingAt</a>(uint64&#95;t V, uint64&#95;t StartPosition) &#123;</Highlight></CodeLine>
<Link id="l00243" /><CodeLine lineNumber="243"><Highlight kind="normal">  uint64&#95;t NumOnes = <a href="/docs/api/namespaces/llvm/#a239abca11deebf2731206dd41cf43c0e">llvm::countr&#95;one</a>(V &gt;&gt; StartPosition);</Highlight></CodeLine>
<Link id="l00244" /><CodeLine lineNumber="244"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00245" /><CodeLine lineNumber="245"><Highlight kind="normal">  uint64&#95;t UnshiftedOnes;</Highlight></CodeLine>
<Link id="l00246" /><CodeLine lineNumber="246"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> (NumOnes == 64) &#123;</Highlight></CodeLine>
<Link id="l00247" /><CodeLine lineNumber="247"><Highlight kind="normal">    UnshiftedOnes = ~0ULL;</Highlight></CodeLine>
<Link id="l00248" /><CodeLine lineNumber="248"><Highlight kind="normal">  &#125; </Highlight><Highlight kind="keywordflow">else</Highlight><Highlight kind="normal"> &#123;</Highlight></CodeLine>
<Link id="l00249" /><CodeLine lineNumber="249"><Highlight kind="normal">    UnshiftedOnes = (1ULL &lt;&lt; NumOnes) - 1;</Highlight></CodeLine>
<Link id="l00250" /><CodeLine lineNumber="250"><Highlight kind="normal">  &#125;</Highlight></CodeLine>
<Link id="l00251" /><CodeLine lineNumber="251"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">return</Highlight><Highlight kind="normal"> UnshiftedOnes &lt;&lt; StartPosition;</Highlight></CodeLine>
<Link id="l00252" /><CodeLine lineNumber="252"><Highlight kind="normal">&#125;</Highlight></CodeLine>
<Link id="l00253" /><CodeLine lineNumber="253"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00254" /><CodeLine lineNumber="254" lineLink="#a78822aec5f2ccbac50c2b2ac068dc7d7"><Highlight kind="normal"></Highlight><Highlight kind="keyword">static</Highlight><Highlight kind="normal"> uint64&#95;t <a href="#a78822aec5f2ccbac50c2b2ac068dc7d7">MaximallyReplicateSubImmediate</a>(uint64&#95;t V, uint64&#95;t Subset) &#123;</Highlight></CodeLine>
<Link id="l00255" /><CodeLine lineNumber="255"><Highlight kind="normal">  uint64&#95;t Result = Subset;</Highlight></CodeLine>
<Link id="l00256" /><CodeLine lineNumber="256"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00257" /><CodeLine lineNumber="257"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// 64, 32, 16, 8, 4, 2</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00258" /><CodeLine lineNumber="258"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">for</Highlight><Highlight kind="normal"> (uint64&#95;t i = 0; i &lt; 6; ++i) &#123;</Highlight></CodeLine>
<Link id="l00259" /><CodeLine lineNumber="259"><Highlight kind="normal">    uint64&#95;t Rotation = 1ULL &lt;&lt; (6 - i);</Highlight></CodeLine>
<Link id="l00260" /><CodeLine lineNumber="260"><Highlight kind="normal">    uint64&#95;t Closure = Result | <a href="/docs/api/namespaces/llvm/#aef2599d8a5a682c348b25f74051cdb2d">llvm::rotl&lt;uint64&#95;t&gt;</a>(Result, Rotation);</Highlight></CodeLine>
<Link id="l00261" /><CodeLine lineNumber="261"><Highlight kind="normal">    </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> (Closure != (Closure &amp; V)) &#123;</Highlight></CodeLine>
<Link id="l00262" /><CodeLine lineNumber="262"><Highlight kind="normal">      </Highlight><Highlight kind="keywordflow">break</Highlight><Highlight kind="normal">;</Highlight></CodeLine>
<Link id="l00263" /><CodeLine lineNumber="263"><Highlight kind="normal">    &#125;</Highlight></CodeLine>
<Link id="l00264" /><CodeLine lineNumber="264"><Highlight kind="normal">    Result = Closure;</Highlight></CodeLine>
<Link id="l00265" /><CodeLine lineNumber="265"><Highlight kind="normal">  &#125;</Highlight></CodeLine>
<Link id="l00266" /><CodeLine lineNumber="266"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00267" /><CodeLine lineNumber="267"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">return</Highlight><Highlight kind="normal"> Result;</Highlight></CodeLine>
<Link id="l00268" /><CodeLine lineNumber="268"><Highlight kind="normal">&#125;</Highlight></CodeLine>
<Link id="l00269" /><CodeLine lineNumber="269"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00270" /><CodeLine lineNumber="270"><Highlight kind="normal"></Highlight><Highlight kind="comment">// Find the logical immediate that covers the most bits in RemainingBits,</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00271" /><CodeLine lineNumber="271"><Highlight kind="normal"></Highlight><Highlight kind="comment">// allowing for additional bits to be set that were set in OriginalBits.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00272" /><CodeLine lineNumber="272" lineLink="#ad62d9bcb5891de134deb4465831a762b"><Highlight kind="normal"></Highlight><Highlight kind="keyword">static</Highlight><Highlight kind="normal"> uint64&#95;t <a href="#ad62d9bcb5891de134deb4465831a762b">maximalLogicalImmWithin</a>(uint64&#95;t RemainingBits,</Highlight></CodeLine>
<Link id="l00273" /><CodeLine lineNumber="273"><Highlight kind="normal">                                        uint64&#95;t OriginalBits) &#123;</Highlight></CodeLine>
<Link id="l00274" /><CodeLine lineNumber="274"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// Find the first set bit.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00275" /><CodeLine lineNumber="275"><Highlight kind="normal">  uint32&#95;t Position = <a href="/docs/api/namespaces/llvm/#a57d2f9ee99e9e68cff564d0d579c8163">llvm::countr&#95;zero</a>(RemainingBits);</Highlight></CodeLine>
<Link id="l00276" /><CodeLine lineNumber="276"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00277" /><CodeLine lineNumber="277"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// Get the first run of set bits.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00278" /><CodeLine lineNumber="278"><Highlight kind="normal">  uint64&#95;t FirstRun = <a href="#a2e2936fed450c145238eeca56cf4572e">GetRunOfOnesStartingAt</a>(OriginalBits, Position);</Highlight></CodeLine>
<Link id="l00279" /><CodeLine lineNumber="279"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00280" /><CodeLine lineNumber="280"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// Replicate the run as many times as possible, as long as the bits are set in</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00281" /><CodeLine lineNumber="281"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// RemainingBits.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00282" /><CodeLine lineNumber="282"><Highlight kind="normal">  uint64&#95;t MaximalImm = <a href="#a78822aec5f2ccbac50c2b2ac068dc7d7">MaximallyReplicateSubImmediate</a>(OriginalBits, FirstRun);</Highlight></CodeLine>
<Link id="l00283" /><CodeLine lineNumber="283"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00284" /><CodeLine lineNumber="284"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">return</Highlight><Highlight kind="normal"> MaximalImm;</Highlight></CodeLine>
<Link id="l00285" /><CodeLine lineNumber="285"><Highlight kind="normal">&#125;</Highlight></CodeLine>
<Link id="l00286" /><CodeLine lineNumber="286"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00287" /><CodeLine lineNumber="287"><Highlight kind="normal"></Highlight><Highlight kind="keyword">static</Highlight><Highlight kind="normal"> std::optional&lt;std::pair&lt;uint64&#95;t, uint64&#95;t&gt;&gt;</Highlight></CodeLine>
<Link id="l00288" /><CodeLine lineNumber="288" lineLink="#aeb71b2a77bd02c4e0e01aecf2d392452"><Highlight kind="normal"><a href="#aeb71b2a77bd02c4e0e01aecf2d392452">decomposeIntoOrrOfLogicalImmediates</a>(uint64&#95;t UImm) &#123;</Highlight></CodeLine>
<Link id="l00289" /><CodeLine lineNumber="289"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> (UImm == 0 || ~UImm == 0)</Highlight></CodeLine>
<Link id="l00290" /><CodeLine lineNumber="290"><Highlight kind="normal">    </Highlight><Highlight kind="keywordflow">return</Highlight><Highlight kind="normal"> std::nullopt;</Highlight></CodeLine>
<Link id="l00291" /><CodeLine lineNumber="291"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00292" /><CodeLine lineNumber="292"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// Make sure we don&#39;t have a run of ones split around the rotation boundary.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00293" /><CodeLine lineNumber="293"><Highlight kind="normal">  uint32&#95;t InitialTrailingOnes = <a href="/docs/api/namespaces/llvm/#a239abca11deebf2731206dd41cf43c0e">llvm::countr&#95;one</a>(UImm);</Highlight></CodeLine>
<Link id="l00294" /><CodeLine lineNumber="294"><Highlight kind="normal">  uint64&#95;t RotatedBits = <a href="/docs/api/namespaces/llvm/#a06620855572cf0307aea15a25099df47">llvm::rotr&lt;uint64&#95;t&gt;</a>(UImm, InitialTrailingOnes);</Highlight></CodeLine>
<Link id="l00295" /><CodeLine lineNumber="295"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00296" /><CodeLine lineNumber="296"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// Find the largest logical immediate that fits within the full immediate.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00297" /><CodeLine lineNumber="297"><Highlight kind="normal">  uint64&#95;t MaximalImm1 = <a href="#ad62d9bcb5891de134deb4465831a762b">maximalLogicalImmWithin</a>(RotatedBits, RotatedBits);</Highlight></CodeLine>
<Link id="l00298" /><CodeLine lineNumber="298"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00299" /><CodeLine lineNumber="299"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// Remove all bits that are set by this mask.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00300" /><CodeLine lineNumber="300"><Highlight kind="normal">  uint64&#95;t RemainingBits = RotatedBits &amp; ~MaximalImm1;</Highlight></CodeLine>
<Link id="l00301" /><CodeLine lineNumber="301"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00302" /><CodeLine lineNumber="302"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// Find the largest logical immediate covering the remaining bits, allowing</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00303" /><CodeLine lineNumber="303"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// for additional bits to be set that were also set in the original immediate.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00304" /><CodeLine lineNumber="304"><Highlight kind="normal">  uint64&#95;t MaximalImm2 = <a href="#ad62d9bcb5891de134deb4465831a762b">maximalLogicalImmWithin</a>(RemainingBits, RotatedBits);</Highlight></CodeLine>
<Link id="l00305" /><CodeLine lineNumber="305"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00306" /><CodeLine lineNumber="306"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// If any bits still haven&#39;t been covered, then give up.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00307" /><CodeLine lineNumber="307"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> (RemainingBits &amp; ~MaximalImm2)</Highlight></CodeLine>
<Link id="l00308" /><CodeLine lineNumber="308"><Highlight kind="normal">    </Highlight><Highlight kind="keywordflow">return</Highlight><Highlight kind="normal"> std::nullopt;</Highlight></CodeLine>
<Link id="l00309" /><CodeLine lineNumber="309"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00310" /><CodeLine lineNumber="310"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// Make sure to un-rotate the immediates.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00311" /><CodeLine lineNumber="311"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">return</Highlight><Highlight kind="normal"> std::make&#95;pair(<a href="/docs/api/namespaces/llvm/#aef2599d8a5a682c348b25f74051cdb2d">rotl</a>(MaximalImm1, InitialTrailingOnes),</Highlight></CodeLine>
<Link id="l00312" /><CodeLine lineNumber="312"><Highlight kind="normal">                        <a href="/docs/api/namespaces/llvm/#aef2599d8a5a682c348b25f74051cdb2d">rotl</a>(MaximalImm2, InitialTrailingOnes));</Highlight></CodeLine>
<Link id="l00313" /><CodeLine lineNumber="313"><Highlight kind="normal">&#125;</Highlight></CodeLine>
<Link id="l00314" /><CodeLine lineNumber="314"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00315" /><CodeLine lineNumber="315"><Highlight kind="normal"></Highlight><Highlight kind="comment">// Attempt to expand an immediate as the ORR of a pair of logical immediates.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00316" /><CodeLine lineNumber="316" lineLink="#ae492dde0ae62ef0c16a80f8b648bae19"><Highlight kind="normal"></Highlight><Highlight kind="keyword">static</Highlight><Highlight kind="normal"> </Highlight><Highlight kind="keywordtype">bool</Highlight><Highlight kind="normal"> <a href="#ae492dde0ae62ef0c16a80f8b648bae19">tryOrrOfLogicalImmediates</a>(uint64&#95;t UImm,</Highlight></CodeLine>
<Link id="l00317" /><CodeLine lineNumber="317"><Highlight kind="normal">                                      <a href="/docs/api/classes/llvm/smallvectorimpl">SmallVectorImpl&lt;ImmInsnModel&gt;</a> &amp;<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>) &#123;</Highlight></CodeLine>
<Link id="l00318" /><CodeLine lineNumber="318"><Highlight kind="normal">  </Highlight><Highlight kind="keyword">auto</Highlight><Highlight kind="normal"> MaybeDecomposition = <a href="#aeb71b2a77bd02c4e0e01aecf2d392452">decomposeIntoOrrOfLogicalImmediates</a>(UImm);</Highlight></CodeLine>
<Link id="l00319" /><CodeLine lineNumber="319"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> (MaybeDecomposition == std::nullopt)</Highlight></CodeLine>
<Link id="l00320" /><CodeLine lineNumber="320"><Highlight kind="normal">    </Highlight><Highlight kind="keywordflow">return</Highlight><Highlight kind="normal"> </Highlight><Highlight kind="keyword">false</Highlight><Highlight kind="normal">;</Highlight></CodeLine>
<Link id="l00321" /><CodeLine lineNumber="321"><Highlight kind="normal">  uint64&#95;t Imm1 = MaybeDecomposition-&gt;first;</Highlight></CodeLine>
<Link id="l00322" /><CodeLine lineNumber="322"><Highlight kind="normal">  uint64&#95;t Imm2 = MaybeDecomposition-&gt;second;</Highlight></CodeLine>
<Link id="l00323" /><CodeLine lineNumber="323"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00324" /><CodeLine lineNumber="324"><Highlight kind="normal">  uint64&#95;t Encoding1, Encoding2;</Highlight></CodeLine>
<Link id="l00325" /><CodeLine lineNumber="325"><Highlight kind="normal">  </Highlight><Highlight kind="keywordtype">bool</Highlight><Highlight kind="normal"> Imm1Success = <a href="/docs/api/namespaces/llvm/aarch64-am/#a2cd3e23b97b495a98c0b723ab18e4d96">AArch64&#95;AM::processLogicalImmediate</a>(Imm1, 64, Encoding1);</Highlight></CodeLine>
<Link id="l00326" /><CodeLine lineNumber="326"><Highlight kind="normal">  </Highlight><Highlight kind="keywordtype">bool</Highlight><Highlight kind="normal"> Imm2Success = <a href="/docs/api/namespaces/llvm/aarch64-am/#a2cd3e23b97b495a98c0b723ab18e4d96">AArch64&#95;AM::processLogicalImmediate</a>(Imm2, 64, Encoding2);</Highlight></CodeLine>
<Link id="l00327" /><CodeLine lineNumber="327"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00328" /><CodeLine lineNumber="328"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> (Imm1Success &amp;&amp; Imm2Success) &#123;</Highlight></CodeLine>
<Link id="l00329" /><CodeLine lineNumber="329"><Highlight kind="normal">    </Highlight><Highlight kind="comment">// Create the ORR-immediate instructions.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00330" /><CodeLine lineNumber="330"><Highlight kind="normal">    <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>.push&#95;back(&#123;AArch64::ORRXri, 0, Encoding1&#125;);</Highlight></CodeLine>
<Link id="l00331" /><CodeLine lineNumber="331"><Highlight kind="normal">    <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>.push&#95;back(&#123;AArch64::ORRXri, 1, Encoding2&#125;);</Highlight></CodeLine>
<Link id="l00332" /><CodeLine lineNumber="332"><Highlight kind="normal">    </Highlight><Highlight kind="keywordflow">return</Highlight><Highlight kind="normal"> </Highlight><Highlight kind="keyword">true</Highlight><Highlight kind="normal">;</Highlight></CodeLine>
<Link id="l00333" /><CodeLine lineNumber="333"><Highlight kind="normal">  &#125;</Highlight></CodeLine>
<Link id="l00334" /><CodeLine lineNumber="334"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00335" /><CodeLine lineNumber="335"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">return</Highlight><Highlight kind="normal"> </Highlight><Highlight kind="keyword">false</Highlight><Highlight kind="normal">;</Highlight></CodeLine>
<Link id="l00336" /><CodeLine lineNumber="336"><Highlight kind="normal">&#125;</Highlight></CodeLine>
<Link id="l00337" /><CodeLine lineNumber="337"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00338" /><CodeLine lineNumber="338"><Highlight kind="normal"></Highlight><Highlight kind="comment">// Attempt to expand an immediate as the AND of a pair of logical immediates.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00339" /><CodeLine lineNumber="339"><Highlight kind="normal"></Highlight><Highlight kind="comment">// This is done by applying DeMorgan&#39;s law, under which logical immediates</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00340" /><CodeLine lineNumber="340"><Highlight kind="normal"></Highlight><Highlight kind="comment">// are closed.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00341" /><CodeLine lineNumber="341" lineLink="#aa20f3eb24c28efa9c93053a733a172c1"><Highlight kind="normal"></Highlight><Highlight kind="keyword">static</Highlight><Highlight kind="normal"> </Highlight><Highlight kind="keywordtype">bool</Highlight><Highlight kind="normal"> <a href="#aa20f3eb24c28efa9c93053a733a172c1">tryAndOfLogicalImmediates</a>(uint64&#95;t UImm,</Highlight></CodeLine>
<Link id="l00342" /><CodeLine lineNumber="342"><Highlight kind="normal">                                      <a href="/docs/api/classes/llvm/smallvectorimpl">SmallVectorImpl&lt;ImmInsnModel&gt;</a> &amp;<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>) &#123;</Highlight></CodeLine>
<Link id="l00343" /><CodeLine lineNumber="343"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// Apply DeMorgan&#39;s law to turn this into an ORR problem.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00344" /><CodeLine lineNumber="344"><Highlight kind="normal">  </Highlight><Highlight kind="keyword">auto</Highlight><Highlight kind="normal"> MaybeDecomposition = <a href="#aeb71b2a77bd02c4e0e01aecf2d392452">decomposeIntoOrrOfLogicalImmediates</a>(~UImm);</Highlight></CodeLine>
<Link id="l00345" /><CodeLine lineNumber="345"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> (MaybeDecomposition == std::nullopt)</Highlight></CodeLine>
<Link id="l00346" /><CodeLine lineNumber="346"><Highlight kind="normal">    </Highlight><Highlight kind="keywordflow">return</Highlight><Highlight kind="normal"> </Highlight><Highlight kind="keyword">false</Highlight><Highlight kind="normal">;</Highlight></CodeLine>
<Link id="l00347" /><CodeLine lineNumber="347"><Highlight kind="normal">  uint64&#95;t Imm1 = MaybeDecomposition-&gt;first;</Highlight></CodeLine>
<Link id="l00348" /><CodeLine lineNumber="348"><Highlight kind="normal">  uint64&#95;t Imm2 = MaybeDecomposition-&gt;second;</Highlight></CodeLine>
<Link id="l00349" /><CodeLine lineNumber="349"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00350" /><CodeLine lineNumber="350"><Highlight kind="normal">  uint64&#95;t Encoding1, Encoding2;</Highlight></CodeLine>
<Link id="l00351" /><CodeLine lineNumber="351"><Highlight kind="normal">  </Highlight><Highlight kind="keywordtype">bool</Highlight><Highlight kind="normal"> Imm1Success = <a href="/docs/api/namespaces/llvm/aarch64-am/#a2cd3e23b97b495a98c0b723ab18e4d96">AArch64&#95;AM::processLogicalImmediate</a>(~Imm1, 64, Encoding1);</Highlight></CodeLine>
<Link id="l00352" /><CodeLine lineNumber="352"><Highlight kind="normal">  </Highlight><Highlight kind="keywordtype">bool</Highlight><Highlight kind="normal"> Imm2Success = <a href="/docs/api/namespaces/llvm/aarch64-am/#a2cd3e23b97b495a98c0b723ab18e4d96">AArch64&#95;AM::processLogicalImmediate</a>(~Imm2, 64, Encoding2);</Highlight></CodeLine>
<Link id="l00353" /><CodeLine lineNumber="353"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00354" /><CodeLine lineNumber="354"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> (Imm1Success &amp;&amp; Imm2Success) &#123;</Highlight></CodeLine>
<Link id="l00355" /><CodeLine lineNumber="355"><Highlight kind="normal">    </Highlight><Highlight kind="comment">// Materialize Imm1, the LHS of the AND</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00356" /><CodeLine lineNumber="356"><Highlight kind="normal">    <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>.push&#95;back(&#123;AArch64::ORRXri, 0, Encoding1&#125;);</Highlight></CodeLine>
<Link id="l00357" /><CodeLine lineNumber="357"><Highlight kind="normal">    </Highlight><Highlight kind="comment">// AND Imm1 with Imm2</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00358" /><CodeLine lineNumber="358"><Highlight kind="normal">    <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>.push&#95;back(&#123;AArch64::ANDXri, 1, Encoding2&#125;);</Highlight></CodeLine>
<Link id="l00359" /><CodeLine lineNumber="359"><Highlight kind="normal">    </Highlight><Highlight kind="keywordflow">return</Highlight><Highlight kind="normal"> </Highlight><Highlight kind="keyword">true</Highlight><Highlight kind="normal">;</Highlight></CodeLine>
<Link id="l00360" /><CodeLine lineNumber="360"><Highlight kind="normal">  &#125;</Highlight></CodeLine>
<Link id="l00361" /><CodeLine lineNumber="361"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00362" /><CodeLine lineNumber="362"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">return</Highlight><Highlight kind="normal"> </Highlight><Highlight kind="keyword">false</Highlight><Highlight kind="normal">;</Highlight></CodeLine>
<Link id="l00363" /><CodeLine lineNumber="363"><Highlight kind="normal">&#125;</Highlight></CodeLine>
<Link id="l00364" /><CodeLine lineNumber="364"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00365" /><CodeLine lineNumber="365"><Highlight kind="normal"></Highlight><Highlight kind="comment">// Check whether the constant can be represented by exclusive-or of two 64-bit</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00366" /><CodeLine lineNumber="366"><Highlight kind="normal"></Highlight><Highlight kind="comment">// logical immediates. If so, materialize it with an ORR instruction followed</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00367" /><CodeLine lineNumber="367"><Highlight kind="normal"></Highlight><Highlight kind="comment">// by an EOR instruction.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00368" /><CodeLine lineNumber="368"><Highlight kind="normal"></Highlight><Highlight kind="comment">//</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00369" /><CodeLine lineNumber="369"><Highlight kind="normal"></Highlight><Highlight kind="comment">// This encoding allows all remaining repeated byte patterns, and many repeated</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00370" /><CodeLine lineNumber="370"><Highlight kind="normal"></Highlight><Highlight kind="comment">// 16-bit values, to be encoded without needing four instructions. It can also</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00371" /><CodeLine lineNumber="371"><Highlight kind="normal"></Highlight><Highlight kind="comment">// represent some irregular bitmasks (although those would mostly only need</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00372" /><CodeLine lineNumber="372"><Highlight kind="normal"></Highlight><Highlight kind="comment">// three instructions otherwise).</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00373" /><CodeLine lineNumber="373" lineLink="#ab2f723b31c9dbe46610248a047805046"><Highlight kind="normal"></Highlight><Highlight kind="keyword">static</Highlight><Highlight kind="normal"> </Highlight><Highlight kind="keywordtype">bool</Highlight><Highlight kind="normal"> <a href="#ab2f723b31c9dbe46610248a047805046">tryEorOfLogicalImmediates</a>(uint64&#95;t Imm,</Highlight></CodeLine>
<Link id="l00374" /><CodeLine lineNumber="374"><Highlight kind="normal">                                      <a href="/docs/api/classes/llvm/smallvectorimpl">SmallVectorImpl&lt;ImmInsnModel&gt;</a> &amp;<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>) &#123;</Highlight></CodeLine>
<Link id="l00375" /><CodeLine lineNumber="375"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// Determine the larger repetition size of the two possible logical</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00376" /><CodeLine lineNumber="376"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// immediates, by finding the repetition size of Imm.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00377" /><CodeLine lineNumber="377"><Highlight kind="normal">  </Highlight><Highlight kind="keywordtype">unsigned</Highlight><Highlight kind="normal"> BigSize = 64;</Highlight></CodeLine>
<Link id="l00378" /><CodeLine lineNumber="378"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00379" /><CodeLine lineNumber="379"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">do</Highlight><Highlight kind="normal"> &#123;</Highlight></CodeLine>
<Link id="l00380" /><CodeLine lineNumber="380"><Highlight kind="normal">    BigSize /= 2;</Highlight></CodeLine>
<Link id="l00381" /><CodeLine lineNumber="381"><Highlight kind="normal">    uint64&#95;t Mask = (1ULL &lt;&lt; BigSize) - 1;</Highlight></CodeLine>
<Link id="l00382" /><CodeLine lineNumber="382"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00383" /><CodeLine lineNumber="383"><Highlight kind="normal">    </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> ((Imm &amp; Mask) != ((Imm &gt;&gt; BigSize) &amp; Mask)) &#123;</Highlight></CodeLine>
<Link id="l00384" /><CodeLine lineNumber="384"><Highlight kind="normal">      BigSize &#42;= 2;</Highlight></CodeLine>
<Link id="l00385" /><CodeLine lineNumber="385"><Highlight kind="normal">      </Highlight><Highlight kind="keywordflow">break</Highlight><Highlight kind="normal">;</Highlight></CodeLine>
<Link id="l00386" /><CodeLine lineNumber="386"><Highlight kind="normal">    &#125;</Highlight></CodeLine>
<Link id="l00387" /><CodeLine lineNumber="387"><Highlight kind="normal">  &#125; </Highlight><Highlight kind="keywordflow">while</Highlight><Highlight kind="normal"> (BigSize &gt; 2);</Highlight></CodeLine>
<Link id="l00388" /><CodeLine lineNumber="388"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00389" /><CodeLine lineNumber="389"><Highlight kind="normal">  uint64&#95;t BigMask = ((uint64&#95;t)-1LL) &gt;&gt; (64 - BigSize);</Highlight></CodeLine>
<Link id="l00390" /><CodeLine lineNumber="390"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00391" /><CodeLine lineNumber="391"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// Find the last bit of each run of ones, circularly. For runs which wrap</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00392" /><CodeLine lineNumber="392"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// around from bit 0 to bit 63, this is the bit before the most-significant</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00393" /><CodeLine lineNumber="393"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// zero, otherwise it is the least-significant bit in the run of ones.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00394" /><CodeLine lineNumber="394"><Highlight kind="normal">  uint64&#95;t RunStarts = Imm &amp; <a href="/docs/api/namespaces/llvm/#aef2599d8a5a682c348b25f74051cdb2d">~rotl&lt;uint64&#95;t&gt;</a>(Imm, 1);</Highlight></CodeLine>
<Link id="l00395" /><CodeLine lineNumber="395"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00396" /><CodeLine lineNumber="396"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// Find the smaller repetition size of the two possible logical immediates by</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00397" /><CodeLine lineNumber="397"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// counting the number of runs of one-bits within the BigSize-bit value. Both</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00398" /><CodeLine lineNumber="398"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// sizes may be the same. The EOR may add one or subtract one from the</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00399" /><CodeLine lineNumber="399"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// power-of-two count that can be represented by a logical immediate, or it</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00400" /><CodeLine lineNumber="400"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// may be left unchanged.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00401" /><CodeLine lineNumber="401"><Highlight kind="normal">  </Highlight><Highlight kind="keywordtype">int</Highlight><Highlight kind="normal"> RunsPerBigChunk = <a href="/docs/api/namespaces/llvm/#a0eea77e7bfa82e0219d2ec7b4efbc94f">popcount</a>(RunStarts &amp; BigMask);</Highlight></CodeLine>
<Link id="l00402" /><CodeLine lineNumber="402"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00403" /><CodeLine lineNumber="403"><Highlight kind="normal">  </Highlight><Highlight kind="keyword">static</Highlight><Highlight kind="normal"> </Highlight><Highlight kind="keyword">const</Highlight><Highlight kind="normal"> int8&#95;t BigToSmallSizeTable&#91;32&#93; = &#123;</Highlight></CodeLine>
<Link id="l00404" /><CodeLine lineNumber="404"><Highlight kind="normal">      -1, -1, 0,  1,  2,  2,  -1, 3,  3,  3,  -1, -1, -1, -1, -1, 4,</Highlight></CodeLine>
<Link id="l00405" /><CodeLine lineNumber="405"><Highlight kind="normal">      4,  4,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5,</Highlight></CodeLine>
<Link id="l00406" /><CodeLine lineNumber="406"><Highlight kind="normal">  &#125;;</Highlight></CodeLine>
<Link id="l00407" /><CodeLine lineNumber="407"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00408" /><CodeLine lineNumber="408"><Highlight kind="normal">  </Highlight><Highlight kind="keywordtype">int</Highlight><Highlight kind="normal"> BigToSmallShift = BigToSmallSizeTable&#91;RunsPerBigChunk&#93;;</Highlight></CodeLine>
<Link id="l00409" /><CodeLine lineNumber="409"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00410" /><CodeLine lineNumber="410"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// Early-exit if the big chunk couldn&#39;t be a power-of-two number of runs</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00411" /><CodeLine lineNumber="411"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// EORed with another single run.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00412" /><CodeLine lineNumber="412"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> (BigToSmallShift == -1)</Highlight></CodeLine>
<Link id="l00413" /><CodeLine lineNumber="413"><Highlight kind="normal">    </Highlight><Highlight kind="keywordflow">return</Highlight><Highlight kind="normal"> </Highlight><Highlight kind="keyword">false</Highlight><Highlight kind="normal">;</Highlight></CodeLine>
<Link id="l00414" /><CodeLine lineNumber="414"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00415" /><CodeLine lineNumber="415"><Highlight kind="normal">  </Highlight><Highlight kind="keywordtype">unsigned</Highlight><Highlight kind="normal"> SmallSize = BigSize &gt;&gt; BigToSmallShift;</Highlight></CodeLine>
<Link id="l00416" /><CodeLine lineNumber="416"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00417" /><CodeLine lineNumber="417"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// 64-bit values with a bit set every (1 &lt;&lt; index) bits.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00418" /><CodeLine lineNumber="418"><Highlight kind="normal">  </Highlight><Highlight kind="keyword">static</Highlight><Highlight kind="normal"> </Highlight><Highlight kind="keyword">const</Highlight><Highlight kind="normal"> uint64&#95;t RepeatedOnesTable&#91;&#93; = &#123;</Highlight></CodeLine>
<Link id="l00419" /><CodeLine lineNumber="419"><Highlight kind="normal">      0xffffffffffffffff, 0x5555555555555555, 0x1111111111111111,</Highlight></CodeLine>
<Link id="l00420" /><CodeLine lineNumber="420"><Highlight kind="normal">      0x0101010101010101, 0x0001000100010001, 0x0000000100000001,</Highlight></CodeLine>
<Link id="l00421" /><CodeLine lineNumber="421"><Highlight kind="normal">      0x0000000000000001,</Highlight></CodeLine>
<Link id="l00422" /><CodeLine lineNumber="422"><Highlight kind="normal">  &#125;;</Highlight></CodeLine>
<Link id="l00423" /><CodeLine lineNumber="423"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00424" /><CodeLine lineNumber="424"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// This RepeatedOnesTable lookup is a faster implementation of the division</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00425" /><CodeLine lineNumber="425"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// 18446744073709552000 / ((1 &lt;&lt; SmallSize) - 1), and can be thought of as</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00426" /><CodeLine lineNumber="426"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// dividing the 64-bit value into fields of width SmallSize, and placing a</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00427" /><CodeLine lineNumber="427"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// one in the least significant bit of each field.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00428" /><CodeLine lineNumber="428"><Highlight kind="normal">  uint64&#95;t SmallOnes = RepeatedOnesTable&#91;<a href="/docs/api/namespaces/llvm/#a57d2f9ee99e9e68cff564d0d579c8163">countr&#95;zero</a>(SmallSize)&#93;;</Highlight></CodeLine>
<Link id="l00429" /><CodeLine lineNumber="429"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00430" /><CodeLine lineNumber="430"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// Now we try to find the number of ones in each of the smaller repetitions,</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00431" /><CodeLine lineNumber="431"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// by looking at runs of ones in Imm. This can take three attempts, as the</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00432" /><CodeLine lineNumber="432"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// EOR may have changed the length of the first two runs we find.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00433" /><CodeLine lineNumber="433"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00434" /><CodeLine lineNumber="434"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// Rotate a run of ones so we can count the number of trailing set bits.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00435" /><CodeLine lineNumber="435"><Highlight kind="normal">  </Highlight><Highlight kind="keywordtype">int</Highlight><Highlight kind="normal"> Rotation = <a href="/docs/api/namespaces/llvm/#a57d2f9ee99e9e68cff564d0d579c8163">countr&#95;zero</a>(RunStarts);</Highlight></CodeLine>
<Link id="l00436" /><CodeLine lineNumber="436"><Highlight kind="normal">  uint64&#95;t RotatedImm = <a href="/docs/api/namespaces/llvm/#a06620855572cf0307aea15a25099df47">rotr&lt;uint64&#95;t&gt;</a>(Imm, Rotation);</Highlight></CodeLine>
<Link id="l00437" /><CodeLine lineNumber="437"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">for</Highlight><Highlight kind="normal"> (</Highlight><Highlight kind="keywordtype">int</Highlight><Highlight kind="normal"> Attempt = 0; Attempt &lt; 3; ++Attempt) &#123;</Highlight></CodeLine>
<Link id="l00438" /><CodeLine lineNumber="438"><Highlight kind="normal">    </Highlight><Highlight kind="keywordtype">unsigned</Highlight><Highlight kind="normal"> RunLength = <a href="/docs/api/namespaces/llvm/#a239abca11deebf2731206dd41cf43c0e">countr&#95;one</a>(RotatedImm);</Highlight></CodeLine>
<Link id="l00439" /><CodeLine lineNumber="439"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00440" /><CodeLine lineNumber="440"><Highlight kind="normal">    </Highlight><Highlight kind="comment">// Construct candidate values BigImm and SmallImm, such that if these two</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00441" /><CodeLine lineNumber="441"><Highlight kind="normal">    </Highlight><Highlight kind="comment">// values are encodable, we have a solution. (SmallImm is constructed to be</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00442" /><CodeLine lineNumber="442"><Highlight kind="normal">    </Highlight><Highlight kind="comment">// encodable, but this isn&#39;t guaranteed when RunLength &gt;= SmallSize)</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00443" /><CodeLine lineNumber="443"><Highlight kind="normal">    uint64&#95;t SmallImm =</Highlight></CodeLine>
<Link id="l00444" /><CodeLine lineNumber="444"><Highlight kind="normal">        <a href="/docs/api/namespaces/llvm/#aef2599d8a5a682c348b25f74051cdb2d">rotl&lt;uint64&#95;t&gt;</a>((SmallOnes &lt;&lt; RunLength) - SmallOnes, Rotation);</Highlight></CodeLine>
<Link id="l00445" /><CodeLine lineNumber="445"><Highlight kind="normal">    uint64&#95;t BigImm = Imm ^ SmallImm;</Highlight></CodeLine>
<Link id="l00446" /><CodeLine lineNumber="446"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00447" /><CodeLine lineNumber="447"><Highlight kind="normal">    uint64&#95;t BigEncoding = 0;</Highlight></CodeLine>
<Link id="l00448" /><CodeLine lineNumber="448"><Highlight kind="normal">    uint64&#95;t SmallEncoding = 0;</Highlight></CodeLine>
<Link id="l00449" /><CodeLine lineNumber="449"><Highlight kind="normal">    </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> (<a href="/docs/api/namespaces/llvm/aarch64-am/#a2cd3e23b97b495a98c0b723ab18e4d96">AArch64&#95;AM::processLogicalImmediate</a>(BigImm, 64, BigEncoding) &amp;&amp;</Highlight></CodeLine>
<Link id="l00450" /><CodeLine lineNumber="450"><Highlight kind="normal">        <a href="/docs/api/namespaces/llvm/aarch64-am/#a2cd3e23b97b495a98c0b723ab18e4d96">AArch64&#95;AM::processLogicalImmediate</a>(SmallImm, 64, SmallEncoding)) &#123;</Highlight></CodeLine>
<Link id="l00451" /><CodeLine lineNumber="451"><Highlight kind="normal">      <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>.push&#95;back(&#123;AArch64::ORRXri, 0, SmallEncoding&#125;);</Highlight></CodeLine>
<Link id="l00452" /><CodeLine lineNumber="452"><Highlight kind="normal">      <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>.push&#95;back(&#123;AArch64::EORXri, 1, BigEncoding&#125;);</Highlight></CodeLine>
<Link id="l00453" /><CodeLine lineNumber="453"><Highlight kind="normal">      </Highlight><Highlight kind="keywordflow">return</Highlight><Highlight kind="normal"> </Highlight><Highlight kind="keyword">true</Highlight><Highlight kind="normal">;</Highlight></CodeLine>
<Link id="l00454" /><CodeLine lineNumber="454"><Highlight kind="normal">    &#125;</Highlight></CodeLine>
<Link id="l00455" /><CodeLine lineNumber="455"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00456" /><CodeLine lineNumber="456"><Highlight kind="normal">    </Highlight><Highlight kind="comment">// Rotate to the next run of ones</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00457" /><CodeLine lineNumber="457"><Highlight kind="normal">    Rotation += <a href="/docs/api/namespaces/llvm/#a57d2f9ee99e9e68cff564d0d579c8163">countr&#95;zero</a>(<a href="/docs/api/namespaces/llvm/#a06620855572cf0307aea15a25099df47">rotr&lt;uint64&#95;t&gt;</a>(RunStarts, Rotation) &amp; ~1);</Highlight></CodeLine>
<Link id="l00458" /><CodeLine lineNumber="458"><Highlight kind="normal">    RotatedImm = <a href="/docs/api/namespaces/llvm/#a06620855572cf0307aea15a25099df47">rotr&lt;uint64&#95;t&gt;</a>(Imm, Rotation);</Highlight></CodeLine>
<Link id="l00459" /><CodeLine lineNumber="459"><Highlight kind="normal">  &#125;</Highlight></CodeLine>
<Link id="l00460" /><CodeLine lineNumber="460"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00461" /><CodeLine lineNumber="461"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">return</Highlight><Highlight kind="normal"> </Highlight><Highlight kind="keyword">false</Highlight><Highlight kind="normal">;</Highlight></CodeLine>
<Link id="l00462" /><CodeLine lineNumber="462"><Highlight kind="normal">&#125;</Highlight></CodeLine>
<Link id="l00463" /><CodeLine lineNumber="463"><Highlight kind="normal"></Highlight><Highlight kind="comment"></Highlight></CodeLine>
<Link id="l00464" /><CodeLine lineNumber="464"><Highlight kind="comment">/// \\brief Expand a MOVi32imm or MOVi64imm pseudo instruction to a</Highlight></CodeLine>
<Link id="l00465" /><CodeLine lineNumber="465"><Highlight kind="comment">/// MOVZ or MOVN of width BitSize followed by up to 3 MOVK instructions.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00466" /><CodeLine lineNumber="466" lineLink="#a2edf9e8f09bfb0cc4949aa1813872322"><Highlight kind="normal"></Highlight><Highlight kind="keyword">static</Highlight><Highlight kind="normal"> </Highlight><Highlight kind="keyword">inline</Highlight><Highlight kind="normal"> </Highlight><Highlight kind="keywordtype">void</Highlight><Highlight kind="normal"> <a href="#a2edf9e8f09bfb0cc4949aa1813872322">expandMOVImmSimple</a>(uint64&#95;t Imm, </Highlight><Highlight kind="keywordtype">unsigned</Highlight><Highlight kind="normal"> BitSize,</Highlight></CodeLine>
<Link id="l00467" /><CodeLine lineNumber="467"><Highlight kind="normal">              </Highlight><Highlight kind="keywordtype">unsigned</Highlight><Highlight kind="normal"> OneChunks, </Highlight><Highlight kind="keywordtype">unsigned</Highlight><Highlight kind="normal"> ZeroChunks,</Highlight></CodeLine>
<Link id="l00468" /><CodeLine lineNumber="468"><Highlight kind="normal">              <a href="/docs/api/classes/llvm/smallvectorimpl">SmallVectorImpl&lt;ImmInsnModel&gt;</a> &amp;<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>) &#123;</Highlight></CodeLine>
<Link id="l00469" /><CodeLine lineNumber="469"><Highlight kind="normal">  </Highlight><Highlight kind="keyword">const</Highlight><Highlight kind="normal"> </Highlight><Highlight kind="keywordtype">unsigned</Highlight><Highlight kind="normal"> Mask = 0xFFFF;</Highlight></CodeLine>
<Link id="l00470" /><CodeLine lineNumber="470"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00471" /><CodeLine lineNumber="471"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// Use a MOVZ or MOVN instruction to set the high bits, followed by one or</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00472" /><CodeLine lineNumber="472"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// more MOVK instructions to insert additional 16-bit portions into the</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00473" /><CodeLine lineNumber="473"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// lower bits.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00474" /><CodeLine lineNumber="474"><Highlight kind="normal">  </Highlight><Highlight kind="keywordtype">bool</Highlight><Highlight kind="normal"> <a href="/docs/api/files/lib/lib/codegen/complexdeinterleavingpass-cpp/#a2762113571c7956c9818c452b2d256ae">isNeg</a> = </Highlight><Highlight kind="keyword">false</Highlight><Highlight kind="normal">;</Highlight></CodeLine>
<Link id="l00475" /><CodeLine lineNumber="475"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00476" /><CodeLine lineNumber="476"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// Use MOVN to materialize the high bits if we have more all one chunks</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00477" /><CodeLine lineNumber="477"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// than all zero chunks.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00478" /><CodeLine lineNumber="478"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> (OneChunks &gt; ZeroChunks) &#123;</Highlight></CodeLine>
<Link id="l00479" /><CodeLine lineNumber="479"><Highlight kind="normal">    <a href="/docs/api/files/lib/lib/codegen/complexdeinterleavingpass-cpp/#a2762113571c7956c9818c452b2d256ae">isNeg</a> = </Highlight><Highlight kind="keyword">true</Highlight><Highlight kind="normal">;</Highlight></CodeLine>
<Link id="l00480" /><CodeLine lineNumber="480"><Highlight kind="normal">    Imm = ~Imm;</Highlight></CodeLine>
<Link id="l00481" /><CodeLine lineNumber="481"><Highlight kind="normal">  &#125;</Highlight></CodeLine>
<Link id="l00482" /><CodeLine lineNumber="482"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00483" /><CodeLine lineNumber="483"><Highlight kind="normal">  </Highlight><Highlight kind="keywordtype">unsigned</Highlight><Highlight kind="normal"> FirstOpc;</Highlight></CodeLine>
<Link id="l00484" /><CodeLine lineNumber="484"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> (BitSize == 32) &#123;</Highlight></CodeLine>
<Link id="l00485" /><CodeLine lineNumber="485"><Highlight kind="normal">    Imm &amp;= (1LL &lt;&lt; 32) - 1;</Highlight></CodeLine>
<Link id="l00486" /><CodeLine lineNumber="486"><Highlight kind="normal">    FirstOpc = (<a href="/docs/api/files/lib/lib/codegen/complexdeinterleavingpass-cpp/#a2762113571c7956c9818c452b2d256ae">isNeg</a> ? AArch64::MOVNWi : AArch64::MOVZWi);</Highlight></CodeLine>
<Link id="l00487" /><CodeLine lineNumber="487"><Highlight kind="normal">  &#125; </Highlight><Highlight kind="keywordflow">else</Highlight><Highlight kind="normal"> &#123;</Highlight></CodeLine>
<Link id="l00488" /><CodeLine lineNumber="488"><Highlight kind="normal">    FirstOpc = (<a href="/docs/api/files/lib/lib/codegen/complexdeinterleavingpass-cpp/#a2762113571c7956c9818c452b2d256ae">isNeg</a> ? AArch64::MOVNXi : AArch64::MOVZXi);</Highlight></CodeLine>
<Link id="l00489" /><CodeLine lineNumber="489"><Highlight kind="normal">  &#125;</Highlight></CodeLine>
<Link id="l00490" /><CodeLine lineNumber="490"><Highlight kind="normal">  </Highlight><Highlight kind="keywordtype">unsigned</Highlight><Highlight kind="normal"> Shift = 0;     </Highlight><Highlight kind="comment">// LSL amount for high bits with MOVZ/MOVN</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00491" /><CodeLine lineNumber="491"><Highlight kind="normal">  </Highlight><Highlight kind="keywordtype">unsigned</Highlight><Highlight kind="normal"> LastShift = 0; </Highlight><Highlight kind="comment">// LSL amount for last MOVK</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00492" /><CodeLine lineNumber="492"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> (Imm != 0) &#123;</Highlight></CodeLine>
<Link id="l00493" /><CodeLine lineNumber="493"><Highlight kind="normal">    </Highlight><Highlight kind="keywordtype">unsigned</Highlight><Highlight kind="normal"> LZ = <a href="/docs/api/namespaces/llvm/#a66191f0bcc8c62b784819e9e96ceeba2">llvm::countl&#95;zero</a>(Imm);</Highlight></CodeLine>
<Link id="l00494" /><CodeLine lineNumber="494"><Highlight kind="normal">    </Highlight><Highlight kind="keywordtype">unsigned</Highlight><Highlight kind="normal"> TZ = <a href="/docs/api/namespaces/llvm/#a57d2f9ee99e9e68cff564d0d579c8163">llvm::countr&#95;zero</a>(Imm);</Highlight></CodeLine>
<Link id="l00495" /><CodeLine lineNumber="495"><Highlight kind="normal">    Shift = (TZ / 16) &#42; 16;</Highlight></CodeLine>
<Link id="l00496" /><CodeLine lineNumber="496"><Highlight kind="normal">    LastShift = ((63 - LZ) / 16) &#42; 16;</Highlight></CodeLine>
<Link id="l00497" /><CodeLine lineNumber="497"><Highlight kind="normal">  &#125;</Highlight></CodeLine>
<Link id="l00498" /><CodeLine lineNumber="498"><Highlight kind="normal">  </Highlight><Highlight kind="keywordtype">unsigned</Highlight><Highlight kind="normal"> Imm16 = (Imm &gt;&gt; Shift) &amp; Mask;</Highlight></CodeLine>
<Link id="l00499" /><CodeLine lineNumber="499"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00500" /><CodeLine lineNumber="500"><Highlight kind="normal">  <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>.push&#95;back(&#123; FirstOpc, Imm16,</Highlight></CodeLine>
<Link id="l00501" /><CodeLine lineNumber="501"><Highlight kind="normal">                   <a href="/docs/api/namespaces/llvm/aarch64-am/#aeae88f12b667477f90db9b726556b337">AArch64&#95;AM::getShifterImm</a>(<a href="/docs/api/namespaces/llvm/aarch64-am/#a7e75394a33f6a5897d7a14c0ba5d44f1a1d97e13eb9923037fe733eda83b7f938">AArch64&#95;AM::LSL</a>, Shift) &#125;);</Highlight></CodeLine>
<Link id="l00502" /><CodeLine lineNumber="502"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00503" /><CodeLine lineNumber="503"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> (Shift == LastShift)</Highlight></CodeLine>
<Link id="l00504" /><CodeLine lineNumber="504"><Highlight kind="normal">    </Highlight><Highlight kind="keywordflow">return</Highlight><Highlight kind="normal">;</Highlight></CodeLine>
<Link id="l00505" /><CodeLine lineNumber="505"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00506" /><CodeLine lineNumber="506"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// If a MOVN was used for the high bits of a negative value, flip the rest</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00507" /><CodeLine lineNumber="507"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// of the bits back for use with MOVK.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00508" /><CodeLine lineNumber="508"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> (<a href="/docs/api/files/lib/lib/codegen/complexdeinterleavingpass-cpp/#a2762113571c7956c9818c452b2d256ae">isNeg</a>)</Highlight></CodeLine>
<Link id="l00509" /><CodeLine lineNumber="509"><Highlight kind="normal">    Imm = ~Imm;</Highlight></CodeLine>
<Link id="l00510" /><CodeLine lineNumber="510"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00511" /><CodeLine lineNumber="511"><Highlight kind="normal">  </Highlight><Highlight kind="keywordtype">unsigned</Highlight><Highlight kind="normal"> Opc = (BitSize == 32 ? AArch64::MOVKWi : AArch64::MOVKXi);</Highlight></CodeLine>
<Link id="l00512" /><CodeLine lineNumber="512"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">while</Highlight><Highlight kind="normal"> (Shift &lt; LastShift) &#123;</Highlight></CodeLine>
<Link id="l00513" /><CodeLine lineNumber="513"><Highlight kind="normal">    Shift += 16;</Highlight></CodeLine>
<Link id="l00514" /><CodeLine lineNumber="514"><Highlight kind="normal">    Imm16 = (Imm &gt;&gt; Shift) &amp; Mask;</Highlight></CodeLine>
<Link id="l00515" /><CodeLine lineNumber="515"><Highlight kind="normal">    </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> (Imm16 == (<a href="/docs/api/files/lib/lib/codegen/complexdeinterleavingpass-cpp/#a2762113571c7956c9818c452b2d256ae">isNeg</a> ? Mask : 0))</Highlight></CodeLine>
<Link id="l00516" /><CodeLine lineNumber="516"><Highlight kind="normal">      </Highlight><Highlight kind="keywordflow">continue</Highlight><Highlight kind="normal">; </Highlight><Highlight kind="comment">// This 16-bit portion is already set correctly.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00517" /><CodeLine lineNumber="517"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00518" /><CodeLine lineNumber="518"><Highlight kind="normal">    <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>.push&#95;back(&#123; Opc, Imm16,</Highlight></CodeLine>
<Link id="l00519" /><CodeLine lineNumber="519"><Highlight kind="normal">                     <a href="/docs/api/namespaces/llvm/aarch64-am/#aeae88f12b667477f90db9b726556b337">AArch64&#95;AM::getShifterImm</a>(<a href="/docs/api/namespaces/llvm/aarch64-am/#a7e75394a33f6a5897d7a14c0ba5d44f1a1d97e13eb9923037fe733eda83b7f938">AArch64&#95;AM::LSL</a>, Shift) &#125;);</Highlight></CodeLine>
<Link id="l00520" /><CodeLine lineNumber="520"><Highlight kind="normal">  &#125;</Highlight></CodeLine>
<Link id="l00521" /><CodeLine lineNumber="521"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00522" /><CodeLine lineNumber="522"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// Now, we get 16-bit divided Imm. If high and low bits are same in</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00523" /><CodeLine lineNumber="523"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// 32-bit, there is an opportunity to reduce instruction.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00524" /><CodeLine lineNumber="524"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> (<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>.size() &gt; 2 &amp;&amp; (Imm &gt;&gt; 32) == (Imm &amp; 0xffffffffULL)) &#123;</Highlight></CodeLine>
<Link id="l00525" /><CodeLine lineNumber="525"><Highlight kind="normal">    </Highlight><Highlight kind="keywordflow">for</Highlight><Highlight kind="normal"> (</Highlight><Highlight kind="keywordtype">int</Highlight><Highlight kind="normal"> <a href="/docs/api/files/lib/lib/analysis/inlineorder-cpp/#a7ee6f0cb51c3b9056199e9a0001fe8c3a6f6cb72d544962fa333e2e34ce64f719">Size</a> = <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>.size(); <a href="/docs/api/files/lib/lib/analysis/inlineorder-cpp/#a7ee6f0cb51c3b9056199e9a0001fe8c3a6f6cb72d544962fa333e2e34ce64f719">Size</a> &gt; 2; <a href="/docs/api/files/lib/lib/analysis/inlineorder-cpp/#a7ee6f0cb51c3b9056199e9a0001fe8c3a6f6cb72d544962fa333e2e34ce64f719">Size</a>--)</Highlight></CodeLine>
<Link id="l00526" /><CodeLine lineNumber="526"><Highlight kind="normal">      <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>.pop&#95;back();</Highlight></CodeLine>
<Link id="l00527" /><CodeLine lineNumber="527"><Highlight kind="normal">    <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>.push&#95;back(&#123;AArch64::ORRXrs, 0, 32&#125;);</Highlight></CodeLine>
<Link id="l00528" /><CodeLine lineNumber="528"><Highlight kind="normal">  &#125;</Highlight></CodeLine>
<Link id="l00529" /><CodeLine lineNumber="529"><Highlight kind="normal">&#125;</Highlight></CodeLine>
<Link id="l00530" /><CodeLine lineNumber="530"><Highlight kind="normal"></Highlight><Highlight kind="comment"></Highlight></CodeLine>
<Link id="l00531" /><CodeLine lineNumber="531"><Highlight kind="comment">/// Expand a MOVi32imm or MOVi64imm pseudo instruction to one or more</Highlight></CodeLine>
<Link id="l00532" /><CodeLine lineNumber="532"><Highlight kind="comment">/// real move-immediate instructions to synthesize the immediate.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00533" /><CodeLine lineNumber="533" lineLink="/docs/api/namespaces/llvm/aarch64-imm/#a77a4e6615fbc6c2bbcf179370dbd0fa9"><Highlight kind="normal"></Highlight><Highlight kind="keywordtype">void</Highlight><Highlight kind="normal"> <a href="/docs/api/namespaces/llvm/aarch64-imm/#a77a4e6615fbc6c2bbcf179370dbd0fa9">AArch64&#95;IMM::expandMOVImm</a>(uint64&#95;t Imm, </Highlight><Highlight kind="keywordtype">unsigned</Highlight><Highlight kind="normal"> BitSize,</Highlight></CodeLine>
<Link id="l00534" /><CodeLine lineNumber="534"><Highlight kind="normal">                               <a href="/docs/api/classes/llvm/smallvectorimpl">SmallVectorImpl&lt;ImmInsnModel&gt;</a> &amp;<a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>) &#123;</Highlight></CodeLine>
<Link id="l00535" /><CodeLine lineNumber="535"><Highlight kind="normal">  </Highlight><Highlight kind="keyword">const</Highlight><Highlight kind="normal"> </Highlight><Highlight kind="keywordtype">unsigned</Highlight><Highlight kind="normal"> Mask = 0xFFFF;</Highlight></CodeLine>
<Link id="l00536" /><CodeLine lineNumber="536"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00537" /><CodeLine lineNumber="537"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// Scan the immediate and count the number of 16-bit chunks which are either</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00538" /><CodeLine lineNumber="538"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// all ones or all zeros.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00539" /><CodeLine lineNumber="539"><Highlight kind="normal">  </Highlight><Highlight kind="keywordtype">unsigned</Highlight><Highlight kind="normal"> OneChunks = 0;</Highlight></CodeLine>
<Link id="l00540" /><CodeLine lineNumber="540"><Highlight kind="normal">  </Highlight><Highlight kind="keywordtype">unsigned</Highlight><Highlight kind="normal"> ZeroChunks = 0;</Highlight></CodeLine>
<Link id="l00541" /><CodeLine lineNumber="541"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">for</Highlight><Highlight kind="normal"> (</Highlight><Highlight kind="keywordtype">unsigned</Highlight><Highlight kind="normal"> Shift = 0; Shift &lt; BitSize; Shift += 16) &#123;</Highlight></CodeLine>
<Link id="l00542" /><CodeLine lineNumber="542"><Highlight kind="normal">    </Highlight><Highlight kind="keyword">const</Highlight><Highlight kind="normal"> </Highlight><Highlight kind="keywordtype">unsigned</Highlight><Highlight kind="normal"> Chunk = (Imm &gt;&gt; Shift) &amp; Mask;</Highlight></CodeLine>
<Link id="l00543" /><CodeLine lineNumber="543"><Highlight kind="normal">    </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> (Chunk == Mask)</Highlight></CodeLine>
<Link id="l00544" /><CodeLine lineNumber="544"><Highlight kind="normal">      OneChunks++;</Highlight></CodeLine>
<Link id="l00545" /><CodeLine lineNumber="545"><Highlight kind="normal">    </Highlight><Highlight kind="keywordflow">else</Highlight><Highlight kind="normal"> </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> (Chunk == 0)</Highlight></CodeLine>
<Link id="l00546" /><CodeLine lineNumber="546"><Highlight kind="normal">      ZeroChunks++;</Highlight></CodeLine>
<Link id="l00547" /><CodeLine lineNumber="547"><Highlight kind="normal">  &#125;</Highlight></CodeLine>
<Link id="l00548" /><CodeLine lineNumber="548"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00549" /><CodeLine lineNumber="549"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// Prefer MOVZ/MOVN over ORR because of the rules for the &quot;mov&quot; alias.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00550" /><CodeLine lineNumber="550"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> ((BitSize / 16) - OneChunks &lt;= 1 || (BitSize / 16) - ZeroChunks &lt;= 1) &#123;</Highlight></CodeLine>
<Link id="l00551" /><CodeLine lineNumber="551"><Highlight kind="normal">    <a href="#a2edf9e8f09bfb0cc4949aa1813872322">expandMOVImmSimple</a>(Imm, BitSize, OneChunks, ZeroChunks, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>);</Highlight></CodeLine>
<Link id="l00552" /><CodeLine lineNumber="552"><Highlight kind="normal">    </Highlight><Highlight kind="keywordflow">return</Highlight><Highlight kind="normal">;</Highlight></CodeLine>
<Link id="l00553" /><CodeLine lineNumber="553"><Highlight kind="normal">  &#125;</Highlight></CodeLine>
<Link id="l00554" /><CodeLine lineNumber="554"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00555" /><CodeLine lineNumber="555"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// Try a single ORR.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00556" /><CodeLine lineNumber="556"><Highlight kind="normal">  uint64&#95;t UImm = Imm &lt;&lt; (64 - BitSize) &gt;&gt; (64 - BitSize);</Highlight></CodeLine>
<Link id="l00557" /><CodeLine lineNumber="557"><Highlight kind="normal">  uint64&#95;t Encoding;</Highlight></CodeLine>
<Link id="l00558" /><CodeLine lineNumber="558"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> (<a href="/docs/api/namespaces/llvm/aarch64-am/#a2cd3e23b97b495a98c0b723ab18e4d96">AArch64&#95;AM::processLogicalImmediate</a>(UImm, BitSize, Encoding)) &#123;</Highlight></CodeLine>
<Link id="l00559" /><CodeLine lineNumber="559"><Highlight kind="normal">    </Highlight><Highlight kind="keywordtype">unsigned</Highlight><Highlight kind="normal"> Opc = (BitSize == 32 ? AArch64::ORRWri : AArch64::ORRXri);</Highlight></CodeLine>
<Link id="l00560" /><CodeLine lineNumber="560"><Highlight kind="normal">    <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>.push&#95;back(&#123; Opc, 0, Encoding &#125;);</Highlight></CodeLine>
<Link id="l00561" /><CodeLine lineNumber="561"><Highlight kind="normal">    </Highlight><Highlight kind="keywordflow">return</Highlight><Highlight kind="normal">;</Highlight></CodeLine>
<Link id="l00562" /><CodeLine lineNumber="562"><Highlight kind="normal">  &#125;</Highlight></CodeLine>
<Link id="l00563" /><CodeLine lineNumber="563"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00564" /><CodeLine lineNumber="564"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// One to up three instruction sequences.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00565" /><CodeLine lineNumber="565"><Highlight kind="normal">  </Highlight><Highlight kind="comment">//</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00566" /><CodeLine lineNumber="566"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// Prefer MOVZ/MOVN followed by MOVK; it&#39;s more readable, and possibly the</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00567" /><CodeLine lineNumber="567"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// fastest sequence with fast literal generation.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00568" /><CodeLine lineNumber="568"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> (OneChunks &gt;= (BitSize / 16) - 2 || ZeroChunks &gt;= (BitSize / 16) - 2) &#123;</Highlight></CodeLine>
<Link id="l00569" /><CodeLine lineNumber="569"><Highlight kind="normal">    <a href="#a2edf9e8f09bfb0cc4949aa1813872322">expandMOVImmSimple</a>(Imm, BitSize, OneChunks, ZeroChunks, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>);</Highlight></CodeLine>
<Link id="l00570" /><CodeLine lineNumber="570"><Highlight kind="normal">    </Highlight><Highlight kind="keywordflow">return</Highlight><Highlight kind="normal">;</Highlight></CodeLine>
<Link id="l00571" /><CodeLine lineNumber="571"><Highlight kind="normal">  &#125;</Highlight></CodeLine>
<Link id="l00572" /><CodeLine lineNumber="572"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00573" /><CodeLine lineNumber="573"><Highlight kind="normal">  <a href="/docs/api/files/lib/lib/target/lib/target/amdgpu/silowercontrolflow-cpp/#a4868c5d81c5ccc98c47aeab6244346a0">assert</a>(BitSize == 64 &amp;&amp; </Highlight><Highlight kind="stringliteral">&quot;All 32-bit immediates can be expanded with a&quot;</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00574" /><CodeLine lineNumber="574"><Highlight kind="normal">                          </Highlight><Highlight kind="stringliteral">&quot;MOVZ/MOVK pair&quot;</Highlight><Highlight kind="normal">);</Highlight></CodeLine>
<Link id="l00575" /><CodeLine lineNumber="575"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00576" /><CodeLine lineNumber="576"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// Try other two-instruction sequences.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00577" /><CodeLine lineNumber="577"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00578" /><CodeLine lineNumber="578"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// 64-bit ORR followed by MOVK.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00579" /><CodeLine lineNumber="579"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// We try to construct the ORR immediate in three different ways: either we</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00580" /><CodeLine lineNumber="580"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// zero out the chunk which will be replaced, we fill the chunk which will</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00581" /><CodeLine lineNumber="581"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// be replaced with ones, or we take the bit pattern from the other half of</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00582" /><CodeLine lineNumber="582"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// the 64-bit immediate. This is comprehensive because of the way ORR</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00583" /><CodeLine lineNumber="583"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// immediates are constructed.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00584" /><CodeLine lineNumber="584"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">for</Highlight><Highlight kind="normal"> (</Highlight><Highlight kind="keywordtype">unsigned</Highlight><Highlight kind="normal"> Shift = 0; Shift &lt; BitSize; Shift += 16) &#123;</Highlight></CodeLine>
<Link id="l00585" /><CodeLine lineNumber="585"><Highlight kind="normal">    uint64&#95;t ShiftedMask = (0xFFFFULL &lt;&lt; Shift);</Highlight></CodeLine>
<Link id="l00586" /><CodeLine lineNumber="586"><Highlight kind="normal">    uint64&#95;t ZeroChunk = UImm &amp; ~ShiftedMask;</Highlight></CodeLine>
<Link id="l00587" /><CodeLine lineNumber="587"><Highlight kind="normal">    uint64&#95;t OneChunk = UImm | ShiftedMask;</Highlight></CodeLine>
<Link id="l00588" /><CodeLine lineNumber="588"><Highlight kind="normal">    uint64&#95;t RotatedImm = (UImm &lt;&lt; 32) | (UImm &gt;&gt; 32);</Highlight></CodeLine>
<Link id="l00589" /><CodeLine lineNumber="589"><Highlight kind="normal">    uint64&#95;t ReplicateChunk = ZeroChunk | (RotatedImm &amp; ShiftedMask);</Highlight></CodeLine>
<Link id="l00590" /><CodeLine lineNumber="590"><Highlight kind="normal">    </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> (<a href="/docs/api/namespaces/llvm/aarch64-am/#a2cd3e23b97b495a98c0b723ab18e4d96">AArch64&#95;AM::processLogicalImmediate</a>(ZeroChunk, BitSize, Encoding) ||</Highlight></CodeLine>
<Link id="l00591" /><CodeLine lineNumber="591"><Highlight kind="normal">        <a href="/docs/api/namespaces/llvm/aarch64-am/#a2cd3e23b97b495a98c0b723ab18e4d96">AArch64&#95;AM::processLogicalImmediate</a>(OneChunk, BitSize, Encoding) ||</Highlight></CodeLine>
<Link id="l00592" /><CodeLine lineNumber="592"><Highlight kind="normal">        <a href="/docs/api/namespaces/llvm/aarch64-am/#a2cd3e23b97b495a98c0b723ab18e4d96">AArch64&#95;AM::processLogicalImmediate</a>(ReplicateChunk, BitSize,</Highlight></CodeLine>
<Link id="l00593" /><CodeLine lineNumber="593"><Highlight kind="normal">                                            Encoding)) &#123;</Highlight></CodeLine>
<Link id="l00594" /><CodeLine lineNumber="594"><Highlight kind="normal">      </Highlight><Highlight kind="comment">// Create the ORR-immediate instruction.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00595" /><CodeLine lineNumber="595"><Highlight kind="normal">      <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>.push&#95;back(&#123; AArch64::ORRXri, 0, Encoding &#125;);</Highlight></CodeLine>
<Link id="l00596" /><CodeLine lineNumber="596"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00597" /><CodeLine lineNumber="597"><Highlight kind="normal">      </Highlight><Highlight kind="comment">// Create the MOVK instruction.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00598" /><CodeLine lineNumber="598"><Highlight kind="normal">      </Highlight><Highlight kind="keyword">const</Highlight><Highlight kind="normal"> </Highlight><Highlight kind="keywordtype">unsigned</Highlight><Highlight kind="normal"> Imm16 = <a href="#aa5bbae3632b4bfe0de4faea7a4da829f">getChunk</a>(UImm, Shift / 16);</Highlight></CodeLine>
<Link id="l00599" /><CodeLine lineNumber="599"><Highlight kind="normal">      <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>.push&#95;back(&#123; AArch64::MOVKXi, Imm16,</Highlight></CodeLine>
<Link id="l00600" /><CodeLine lineNumber="600"><Highlight kind="normal">           <a href="/docs/api/namespaces/llvm/aarch64-am/#aeae88f12b667477f90db9b726556b337">AArch64&#95;AM::getShifterImm</a>(<a href="/docs/api/namespaces/llvm/aarch64-am/#a7e75394a33f6a5897d7a14c0ba5d44f1a1d97e13eb9923037fe733eda83b7f938">AArch64&#95;AM::LSL</a>, Shift) &#125;);</Highlight></CodeLine>
<Link id="l00601" /><CodeLine lineNumber="601"><Highlight kind="normal">      </Highlight><Highlight kind="keywordflow">return</Highlight><Highlight kind="normal">;</Highlight></CodeLine>
<Link id="l00602" /><CodeLine lineNumber="602"><Highlight kind="normal">    &#125;</Highlight></CodeLine>
<Link id="l00603" /><CodeLine lineNumber="603"><Highlight kind="normal">  &#125;</Highlight></CodeLine>
<Link id="l00604" /><CodeLine lineNumber="604"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00605" /><CodeLine lineNumber="605"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// Attempt to use a sequence of two ORR-immediate instructions.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00606" /><CodeLine lineNumber="606"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> (<a href="#ae492dde0ae62ef0c16a80f8b648bae19">tryOrrOfLogicalImmediates</a>(Imm, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>))</Highlight></CodeLine>
<Link id="l00607" /><CodeLine lineNumber="607"><Highlight kind="normal">    </Highlight><Highlight kind="keywordflow">return</Highlight><Highlight kind="normal">;</Highlight></CodeLine>
<Link id="l00608" /><CodeLine lineNumber="608"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00609" /><CodeLine lineNumber="609"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// Attempt to use a sequence of ORR-immediate followed by AND-immediate.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00610" /><CodeLine lineNumber="610"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> (<a href="#aa20f3eb24c28efa9c93053a733a172c1">tryAndOfLogicalImmediates</a>(Imm, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>))</Highlight></CodeLine>
<Link id="l00611" /><CodeLine lineNumber="611"><Highlight kind="normal">    </Highlight><Highlight kind="keywordflow">return</Highlight><Highlight kind="normal">;</Highlight></CodeLine>
<Link id="l00612" /><CodeLine lineNumber="612"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00613" /><CodeLine lineNumber="613"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// Attempt to use a sequence of ORR-immediate followed by EOR-immediate.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00614" /><CodeLine lineNumber="614"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> (<a href="#ab2f723b31c9dbe46610248a047805046">tryEorOfLogicalImmediates</a>(UImm, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>))</Highlight></CodeLine>
<Link id="l00615" /><CodeLine lineNumber="615"><Highlight kind="normal">    </Highlight><Highlight kind="keywordflow">return</Highlight><Highlight kind="normal">;</Highlight></CodeLine>
<Link id="l00616" /><CodeLine lineNumber="616"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00617" /><CodeLine lineNumber="617"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// FIXME: Add more two-instruction sequences.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00618" /><CodeLine lineNumber="618"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00619" /><CodeLine lineNumber="619"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// Three instruction sequences.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00620" /><CodeLine lineNumber="620"><Highlight kind="normal">  </Highlight><Highlight kind="comment">//</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00621" /><CodeLine lineNumber="621"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// Prefer MOVZ/MOVN followed by two MOVK; it&#39;s more readable, and possibly</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00622" /><CodeLine lineNumber="622"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// the fastest sequence with fast literal generation. (If neither MOVK is</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00623" /><CodeLine lineNumber="623"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// part of a fast literal generation pair, it could be slower than the</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00624" /><CodeLine lineNumber="624"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// four-instruction sequence, but we won&#39;t worry about that for now.)</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00625" /><CodeLine lineNumber="625"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> (OneChunks || ZeroChunks) &#123;</Highlight></CodeLine>
<Link id="l00626" /><CodeLine lineNumber="626"><Highlight kind="normal">    <a href="#a2edf9e8f09bfb0cc4949aa1813872322">expandMOVImmSimple</a>(Imm, BitSize, OneChunks, ZeroChunks, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>);</Highlight></CodeLine>
<Link id="l00627" /><CodeLine lineNumber="627"><Highlight kind="normal">    </Highlight><Highlight kind="keywordflow">return</Highlight><Highlight kind="normal">;</Highlight></CodeLine>
<Link id="l00628" /><CodeLine lineNumber="628"><Highlight kind="normal">  &#125;</Highlight></CodeLine>
<Link id="l00629" /><CodeLine lineNumber="629"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00630" /><CodeLine lineNumber="630"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// Check for identical 16-bit chunks within the constant and if so materialize</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00631" /><CodeLine lineNumber="631"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// them with a single ORR instruction. The remaining one or two 16-bit chunks</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00632" /><CodeLine lineNumber="632"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// will be materialized with MOVK instructions.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00633" /><CodeLine lineNumber="633"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> (BitSize == 64 &amp;&amp; <a href="#a6efd5b30fe34a042d2937ba63a73ad07">tryToreplicateChunks</a>(UImm, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>))</Highlight></CodeLine>
<Link id="l00634" /><CodeLine lineNumber="634"><Highlight kind="normal">    </Highlight><Highlight kind="keywordflow">return</Highlight><Highlight kind="normal">;</Highlight></CodeLine>
<Link id="l00635" /><CodeLine lineNumber="635"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00636" /><CodeLine lineNumber="636"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// Check whether the constant contains a sequence of contiguous ones, which</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00637" /><CodeLine lineNumber="637"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// might be interrupted by one or two chunks. If so, materialize the sequence</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00638" /><CodeLine lineNumber="638"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// of contiguous ones with an ORR instruction. Materialize the chunks which</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00639" /><CodeLine lineNumber="639"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// are either interrupting the sequence or outside of the sequence with a</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00640" /><CodeLine lineNumber="640"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// MOVK instruction.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00641" /><CodeLine lineNumber="641"><Highlight kind="normal">  </Highlight><Highlight kind="keywordflow">if</Highlight><Highlight kind="normal"> (BitSize == 64 &amp;&amp; <a href="#a7000ac817f63a64697020f0538311927">trySequenceOfOnes</a>(UImm, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>))</Highlight></CodeLine>
<Link id="l00642" /><CodeLine lineNumber="642"><Highlight kind="normal">    </Highlight><Highlight kind="keywordflow">return</Highlight><Highlight kind="normal">;</Highlight></CodeLine>
<Link id="l00643" /><CodeLine lineNumber="643"><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00644" /><CodeLine lineNumber="644"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// We found no possible two or three instruction sequence; use the general</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00645" /><CodeLine lineNumber="645"><Highlight kind="normal">  </Highlight><Highlight kind="comment">// four-instruction sequence.</Highlight><Highlight kind="normal"></Highlight></CodeLine>
<Link id="l00646" /><CodeLine lineNumber="646"><Highlight kind="normal">  <a href="#a2edf9e8f09bfb0cc4949aa1813872322">expandMOVImmSimple</a>(Imm, BitSize, OneChunks, ZeroChunks, <a href="/docs/api/files/lib/lib/target/lib/target/aarch64/aarch64mipeepholeopt-cpp/#a96d5dc120196819fbfbc257cba09b2aa">Insn</a>);</Highlight></CodeLine>
<Link id="l00647" /><CodeLine lineNumber="647"><Highlight kind="normal">&#125;</Highlight></CodeLine>

</ProgramListing>


</DoxygenPage>
