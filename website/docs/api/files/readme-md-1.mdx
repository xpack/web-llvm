---

# DO NOT EDIT!
# Automatically generated via docusaurus-plugin-doxygen by Doxygen.

slug: /api/files/readme-md-1
custom_edit_url: null
keywords:
  - doxygen
  - reference
  - file

---


import CodeLine from '@xpack/docusaurus-plugin-doxygen/components/CodeLine'
import DoxygenPage from '@xpack/docusaurus-plugin-doxygen/components/DoxygenPage'
import ProgramListing from '@xpack/docusaurus-plugin-doxygen/components/ProgramListing'

import pluginConfig from '@site/docusaurus-plugin-doxygen-config.json'

# The `README.md` File Reference

<DoxygenPage pluginConfig={pluginConfig}>




## File Listing

The file content with the documentation metadata removed is:

<ProgramListing>

<CodeLine><span class="doxyHighlight">Implementation of BLAKE3, originating from https://github.com/BLAKE3-team/BLAKE3/tree/1.3.1/c</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight"># Example</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">An example program that hashes bytes from standard input and prints the</span></CodeLine>
<CodeLine><span class="doxyHighlight">result:</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">Using the C++ API:</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">&#96;&#96;&#96;c++</span></CodeLine>
<CodeLine><span class="doxyHighlight">#include &quot;llvm/Support/BLAKE3.h&quot;</span></CodeLine>
<CodeLine><span class="doxyHighlight">#include &lt;errno.h&gt;</span></CodeLine>
<CodeLine><span class="doxyHighlight">#include &lt;stdio.h&gt;</span></CodeLine>
<CodeLine><span class="doxyHighlight">#include &lt;stdlib.h&gt;</span></CodeLine>
<CodeLine><span class="doxyHighlight">#include &lt;string.h&gt;</span></CodeLine>
<CodeLine><span class="doxyHighlight">#include &lt;unistd.h&gt;</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">int main() &#123;</span></CodeLine>
<CodeLine><span class="doxyHighlight">  // Initialize the hasher.</span></CodeLine>
<CodeLine><span class="doxyHighlight">  llvm::BLAKE3 hasher;</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">  // Read input bytes from stdin.</span></CodeLine>
<CodeLine><span class="doxyHighlight">  char buf&#91;65536&#93;;</span></CodeLine>
<CodeLine><span class="doxyHighlight">  while (1) &#123;</span></CodeLine>
<CodeLine><span class="doxyHighlight">    ssize&#95;t n = read(STDIN&#95;FILENO, buf, sizeof(buf));</span></CodeLine>
<CodeLine><span class="doxyHighlight">    if (n &gt; 0) &#123;</span></CodeLine>
<CodeLine><span class="doxyHighlight">      hasher.update(llvm::StringRef(buf, n));</span></CodeLine>
<CodeLine><span class="doxyHighlight">    &#125; else if (n == 0) &#123;</span></CodeLine>
<CodeLine><span class="doxyHighlight">      break; // end of file</span></CodeLine>
<CodeLine><span class="doxyHighlight">    &#125; else &#123;</span></CodeLine>
<CodeLine><span class="doxyHighlight">      fprintf(stderr, &quot;read failed: %s\\n&quot;, strerror(errno));</span></CodeLine>
<CodeLine><span class="doxyHighlight">      exit(1);</span></CodeLine>
<CodeLine><span class="doxyHighlight">    &#125;</span></CodeLine>
<CodeLine><span class="doxyHighlight">  &#125;</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">  // Finalize the hash. Default output length is 32 bytes.</span></CodeLine>
<CodeLine><span class="doxyHighlight">  auto output = hasher.final();</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">  // Print the hash as hexadecimal.</span></CodeLine>
<CodeLine><span class="doxyHighlight">  for (uint8&#95;t byte : output) &#123;</span></CodeLine>
<CodeLine><span class="doxyHighlight">    printf(&quot;%02x&quot;, byte);</span></CodeLine>
<CodeLine><span class="doxyHighlight">  &#125;</span></CodeLine>
<CodeLine><span class="doxyHighlight">  printf(&quot;\\n&quot;);</span></CodeLine>
<CodeLine><span class="doxyHighlight">  return 0;</span></CodeLine>
<CodeLine><span class="doxyHighlight">&#125;</span></CodeLine>
<CodeLine><span class="doxyHighlight">&#96;&#96;&#96;</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">Using the C API:</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">&#96;&#96;&#96;c</span></CodeLine>
<CodeLine><span class="doxyHighlight">#include &quot;llvm-c/blake3.h&quot;</span></CodeLine>
<CodeLine><span class="doxyHighlight">#include &lt;errno.h&gt;</span></CodeLine>
<CodeLine><span class="doxyHighlight">#include &lt;stdio.h&gt;</span></CodeLine>
<CodeLine><span class="doxyHighlight">#include &lt;stdlib.h&gt;</span></CodeLine>
<CodeLine><span class="doxyHighlight">#include &lt;string.h&gt;</span></CodeLine>
<CodeLine><span class="doxyHighlight">#include &lt;unistd.h&gt;</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">int main() &#123;</span></CodeLine>
<CodeLine><span class="doxyHighlight">  // Initialize the hasher.</span></CodeLine>
<CodeLine><span class="doxyHighlight">  llvm&#95;blake3&#95;hasher hasher;</span></CodeLine>
<CodeLine><span class="doxyHighlight">  llvm&#95;blake3&#95;hasher&#95;init(&amp;hasher);</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">  // Read input bytes from stdin.</span></CodeLine>
<CodeLine><span class="doxyHighlight">  unsigned char buf&#91;65536&#93;;</span></CodeLine>
<CodeLine><span class="doxyHighlight">  while (1) &#123;</span></CodeLine>
<CodeLine><span class="doxyHighlight">    ssize&#95;t n = read(STDIN&#95;FILENO, buf, sizeof(buf));</span></CodeLine>
<CodeLine><span class="doxyHighlight">    if (n &gt; 0) &#123;</span></CodeLine>
<CodeLine><span class="doxyHighlight">      llvm&#95;blake3&#95;hasher&#95;update(&amp;hasher, buf, n);</span></CodeLine>
<CodeLine><span class="doxyHighlight">    &#125; else if (n == 0) &#123;</span></CodeLine>
<CodeLine><span class="doxyHighlight">      break; // end of file</span></CodeLine>
<CodeLine><span class="doxyHighlight">    &#125; else &#123;</span></CodeLine>
<CodeLine><span class="doxyHighlight">      fprintf(stderr, &quot;read failed: %s\\n&quot;, strerror(errno));</span></CodeLine>
<CodeLine><span class="doxyHighlight">      exit(1);</span></CodeLine>
<CodeLine><span class="doxyHighlight">    &#125;</span></CodeLine>
<CodeLine><span class="doxyHighlight">  &#125;</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">  // Finalize the hash. LLVM&#95;BLAKE3&#95;OUT&#95;LEN is the default output length, 32 bytes.</span></CodeLine>
<CodeLine><span class="doxyHighlight">  uint8&#95;t output&#91;LLVM&#95;BLAKE3&#95;OUT&#95;LEN&#93;;</span></CodeLine>
<CodeLine><span class="doxyHighlight">  llvm&#95;blake3&#95;hasher&#95;finalize(&amp;hasher, output, LLVM&#95;BLAKE3&#95;OUT&#95;LEN);</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">  // Print the hash as hexadecimal.</span></CodeLine>
<CodeLine><span class="doxyHighlight">  for (size&#95;t i = 0; i &lt; LLVM&#95;BLAKE3&#95;OUT&#95;LEN; i++) &#123;</span></CodeLine>
<CodeLine><span class="doxyHighlight">    printf(&quot;%02x&quot;, output&#91;i&#93;);</span></CodeLine>
<CodeLine><span class="doxyHighlight">  &#125;</span></CodeLine>
<CodeLine><span class="doxyHighlight">  printf(&quot;\\n&quot;);</span></CodeLine>
<CodeLine><span class="doxyHighlight">  return 0;</span></CodeLine>
<CodeLine><span class="doxyHighlight">&#125;</span></CodeLine>
<CodeLine><span class="doxyHighlight">&#96;&#96;&#96;</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight"># API</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">## The Class/Struct</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">&#96;&#96;&#96;c++</span></CodeLine>
<CodeLine><span class="doxyHighlight">class BLAKE3 &#123;</span></CodeLine>
<CodeLine><span class="doxyHighlight">  // API</span></CodeLine>
<CodeLine><span class="doxyHighlight">private:</span></CodeLine>
<CodeLine><span class="doxyHighlight">  llvm&#95;blake3&#95;hasher Hasher;</span></CodeLine>
<CodeLine><span class="doxyHighlight">&#125;;</span></CodeLine>
<CodeLine><span class="doxyHighlight">&#96;&#96;&#96;</span></CodeLine>
<CodeLine><span class="doxyHighlight">&#96;&#96;&#96;c</span></CodeLine>
<CodeLine><span class="doxyHighlight">typedef struct &#123;</span></CodeLine>
<CodeLine><span class="doxyHighlight">  // private fields</span></CodeLine>
<CodeLine><span class="doxyHighlight">&#125; llvm&#95;blake3&#95;hasher;</span></CodeLine>
<CodeLine><span class="doxyHighlight">&#96;&#96;&#96;</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">An incremental BLAKE3 hashing state, which can accept any number of</span></CodeLine>
<CodeLine><span class="doxyHighlight">updates. This implementation doesn&#39;t allocate any heap memory, but</span></CodeLine>
<CodeLine><span class="doxyHighlight">&#96;sizeof(llvm&#95;blake3&#95;hasher)&#96; itself is relatively large, currently 1912 bytes</span></CodeLine>
<CodeLine><span class="doxyHighlight">on x86-64. This size can be reduced by restricting the maximum input</span></CodeLine>
<CodeLine><span class="doxyHighlight">length, as described in Section 5.4 of &#91;the BLAKE3</span></CodeLine>
<CodeLine><span class="doxyHighlight">spec&#93;(https://github.com/BLAKE3-team/BLAKE3-specs/blob/master/blake3.pdf),</span></CodeLine>
<CodeLine><span class="doxyHighlight">but this implementation doesn&#39;t currently support that strategy.</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">## Common API Functions</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">&#96;&#96;&#96;c++</span></CodeLine>
<CodeLine><span class="doxyHighlight">BLAKE3::BLAKE3();</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">void BLAKE3::init();</span></CodeLine>
<CodeLine><span class="doxyHighlight">&#96;&#96;&#96;</span></CodeLine>
<CodeLine><span class="doxyHighlight">&#96;&#96;&#96;c</span></CodeLine>
<CodeLine><span class="doxyHighlight">void llvm&#95;blake3&#95;hasher&#95;init(</span></CodeLine>
<CodeLine><span class="doxyHighlight">  llvm&#95;blake3&#95;hasher &#42;self);</span></CodeLine>
<CodeLine><span class="doxyHighlight">&#96;&#96;&#96;</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">Initialize a &#96;llvm&#95;blake3&#95;hasher&#96; in the default hashing mode.</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">---</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">&#96;&#96;&#96;c++</span></CodeLine>
<CodeLine><span class="doxyHighlight">void BLAKE3::update(ArrayRef&lt;uint8&#95;t&gt; Data);</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">void BLAKE3::update(StringRef Str);</span></CodeLine>
<CodeLine><span class="doxyHighlight">&#96;&#96;&#96;</span></CodeLine>
<CodeLine><span class="doxyHighlight">&#96;&#96;&#96;c</span></CodeLine>
<CodeLine><span class="doxyHighlight">void llvm&#95;blake3&#95;hasher&#95;update(</span></CodeLine>
<CodeLine><span class="doxyHighlight">  llvm&#95;blake3&#95;hasher &#42;self,</span></CodeLine>
<CodeLine><span class="doxyHighlight">  const void &#42;input,</span></CodeLine>
<CodeLine><span class="doxyHighlight">  size&#95;t input&#95;len);</span></CodeLine>
<CodeLine><span class="doxyHighlight">&#96;&#96;&#96;</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">Add input to the hasher. This can be called any number of times.</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">---</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">&#96;&#96;&#96;c++</span></CodeLine>
<CodeLine><span class="doxyHighlight">template &lt;size&#95;t NumBytes = LLVM&#95;BLAKE3&#95;OUT&#95;LEN&gt;</span></CodeLine>
<CodeLine><span class="doxyHighlight">using BLAKE3Result = std::array&lt;uint8&#95;t, NumBytes&gt;;</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">template &lt;size&#95;t NumBytes = LLVM&#95;BLAKE3&#95;OUT&#95;LEN&gt;</span></CodeLine>
<CodeLine><span class="doxyHighlight">void BLAKE3::final(BLAKE3Result&lt;NumBytes&gt; &amp;Result);</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">template &lt;size&#95;t NumBytes = LLVM&#95;BLAKE3&#95;OUT&#95;LEN&gt;</span></CodeLine>
<CodeLine><span class="doxyHighlight">BLAKE3Result&lt;NumBytes&gt; BLAKE3::final();</span></CodeLine>
<CodeLine><span class="doxyHighlight">&#96;&#96;&#96;</span></CodeLine>
<CodeLine><span class="doxyHighlight">&#96;&#96;&#96;c</span></CodeLine>
<CodeLine><span class="doxyHighlight">void llvm&#95;blake3&#95;hasher&#95;finalize(</span></CodeLine>
<CodeLine><span class="doxyHighlight">  const llvm&#95;blake3&#95;hasher &#42;self,</span></CodeLine>
<CodeLine><span class="doxyHighlight">  uint8&#95;t &#42;out,</span></CodeLine>
<CodeLine><span class="doxyHighlight">  size&#95;t out&#95;len);</span></CodeLine>
<CodeLine><span class="doxyHighlight">&#96;&#96;&#96;</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">Finalize the hasher and return an output of any length, given in bytes.</span></CodeLine>
<CodeLine><span class="doxyHighlight">This doesn&#39;t modify the hasher itself, and it&#39;s possible to finalize</span></CodeLine>
<CodeLine><span class="doxyHighlight">again after adding more input. The constant &#96;LLVM&#95;BLAKE3&#95;OUT&#95;LEN&#96; provides</span></CodeLine>
<CodeLine><span class="doxyHighlight">the default output length, 32 bytes, which is recommended for most</span></CodeLine>
<CodeLine><span class="doxyHighlight">callers.</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">Outputs shorter than the default length of 32 bytes (256 bits) provide</span></CodeLine>
<CodeLine><span class="doxyHighlight">less security. An N-bit BLAKE3 output is intended to provide N bits of</span></CodeLine>
<CodeLine><span class="doxyHighlight">first and second preimage resistance and N/2 bits of collision</span></CodeLine>
<CodeLine><span class="doxyHighlight">resistance, for any N up to 256 Longer outputs don&#39;t provide any</span></CodeLine>
<CodeLine><span class="doxyHighlight">additional security.</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">Shorter BLAKE3 outputs are prefixes of longer ones. Explicitly</span></CodeLine>
<CodeLine><span class="doxyHighlight">requesting a short output is equivalent to truncating the default-length</span></CodeLine>
<CodeLine><span class="doxyHighlight">output. (Note that this is different between BLAKE2 and BLAKE3.)</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">## Less Common API Functions</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">&#96;&#96;&#96;c</span></CodeLine>
<CodeLine><span class="doxyHighlight">void llvm&#95;blake3&#95;hasher&#95;init&#95;keyed(</span></CodeLine>
<CodeLine><span class="doxyHighlight">  llvm&#95;blake3&#95;hasher &#42;self,</span></CodeLine>
<CodeLine><span class="doxyHighlight">  const uint8&#95;t key&#91;LLVM&#95;BLAKE3&#95;KEY&#95;LEN&#93;);</span></CodeLine>
<CodeLine><span class="doxyHighlight">&#96;&#96;&#96;</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">Initialize a &#96;llvm&#95;blake3&#95;hasher&#96; in the keyed hashing mode. The key must be</span></CodeLine>
<CodeLine><span class="doxyHighlight">exactly 32 bytes.</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">---</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">&#96;&#96;&#96;c</span></CodeLine>
<CodeLine><span class="doxyHighlight">void llvm&#95;blake3&#95;hasher&#95;init&#95;derive&#95;key(</span></CodeLine>
<CodeLine><span class="doxyHighlight">  llvm&#95;blake3&#95;hasher &#42;self,</span></CodeLine>
<CodeLine><span class="doxyHighlight">  const char &#42;context);</span></CodeLine>
<CodeLine><span class="doxyHighlight">&#96;&#96;&#96;</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">Initialize a &#96;llvm&#95;blake3&#95;hasher&#96; in the key derivation mode. The context</span></CodeLine>
<CodeLine><span class="doxyHighlight">string is given as an initialization parameter, and afterwards input key</span></CodeLine>
<CodeLine><span class="doxyHighlight">material should be given with &#96;llvm&#95;blake3&#95;hasher&#95;update&#96;. The context string</span></CodeLine>
<CodeLine><span class="doxyHighlight">is a null-terminated C string which should be &#42;&#42;hardcoded, globally</span></CodeLine>
<CodeLine><span class="doxyHighlight">unique, and application-specific&#42;&#42;. The context string should not</span></CodeLine>
<CodeLine><span class="doxyHighlight">include any dynamic input like salts, nonces, or identifiers read from a</span></CodeLine>
<CodeLine><span class="doxyHighlight">database at runtime. A good default format for the context string is</span></CodeLine>
<CodeLine><span class="doxyHighlight">&#96;&quot;&#91;application&#93; &#91;commit timestamp&#93; &#91;purpose&#93;&quot;&#96;, e.g., &#96;&quot;example.com</span></CodeLine>
<CodeLine><span class="doxyHighlight">2019-12-25 16:18:03 session tokens v1&quot;&#96;.</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">This function is intended for application code written in C. For</span></CodeLine>
<CodeLine><span class="doxyHighlight">language bindings, see &#96;llvm&#95;blake3&#95;hasher&#95;init&#95;derive&#95;key&#95;raw&#96; below.</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">---</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">&#96;&#96;&#96;c</span></CodeLine>
<CodeLine><span class="doxyHighlight">void llvm&#95;blake3&#95;hasher&#95;init&#95;derive&#95;key&#95;raw(</span></CodeLine>
<CodeLine><span class="doxyHighlight">  llvm&#95;blake3&#95;hasher &#42;self,</span></CodeLine>
<CodeLine><span class="doxyHighlight">  const void &#42;context,</span></CodeLine>
<CodeLine><span class="doxyHighlight">  size&#95;t context&#95;len);</span></CodeLine>
<CodeLine><span class="doxyHighlight">&#96;&#96;&#96;</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">As &#96;llvm&#95;blake3&#95;hasher&#95;init&#95;derive&#95;key&#96; above, except that the context string</span></CodeLine>
<CodeLine><span class="doxyHighlight">is given as a pointer to an array of arbitrary bytes with a provided</span></CodeLine>
<CodeLine><span class="doxyHighlight">length. This is intended for writing language bindings, where C string</span></CodeLine>
<CodeLine><span class="doxyHighlight">conversion would add unnecessary overhead and new error cases. Unicode</span></CodeLine>
<CodeLine><span class="doxyHighlight">strings should be encoded as UTF-8.</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">Application code in C should prefer &#96;llvm&#95;blake3&#95;hasher&#95;init&#95;derive&#95;key&#96;,</span></CodeLine>
<CodeLine><span class="doxyHighlight">which takes the context as a C string. If you need to use arbitrary</span></CodeLine>
<CodeLine><span class="doxyHighlight">bytes as a context string in application code, consider whether you&#39;re</span></CodeLine>
<CodeLine><span class="doxyHighlight">violating the requirement that context strings should be hardcoded.</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">---</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">&#96;&#96;&#96;c</span></CodeLine>
<CodeLine><span class="doxyHighlight">void llvm&#95;blake3&#95;hasher&#95;finalize&#95;seek(</span></CodeLine>
<CodeLine><span class="doxyHighlight">  const llvm&#95;blake3&#95;hasher &#42;self,</span></CodeLine>
<CodeLine><span class="doxyHighlight">  uint64&#95;t seek,</span></CodeLine>
<CodeLine><span class="doxyHighlight">  uint8&#95;t &#42;out,</span></CodeLine>
<CodeLine><span class="doxyHighlight">  size&#95;t out&#95;len);</span></CodeLine>
<CodeLine><span class="doxyHighlight">&#96;&#96;&#96;</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">The same as &#96;llvm&#95;blake3&#95;hasher&#95;finalize&#96;, but with an additional &#96;seek&#96;</span></CodeLine>
<CodeLine><span class="doxyHighlight">parameter for the starting byte position in the output stream. To</span></CodeLine>
<CodeLine><span class="doxyHighlight">efficiently stream a large output without allocating memory, call this</span></CodeLine>
<CodeLine><span class="doxyHighlight">function in a loop, incrementing &#96;seek&#96; by the output length each time.</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">---</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">&#96;&#96;&#96;c</span></CodeLine>
<CodeLine><span class="doxyHighlight">void llvm&#95;blake3&#95;hasher&#95;reset(</span></CodeLine>
<CodeLine><span class="doxyHighlight">  llvm&#95;blake3&#95;hasher &#42;self);</span></CodeLine>
<CodeLine><span class="doxyHighlight">&#96;&#96;&#96;</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">Reset the hasher to its initial state, prior to any calls to</span></CodeLine>
<CodeLine><span class="doxyHighlight">&#96;llvm&#95;blake3&#95;hasher&#95;update&#96;. Currently this is no different from calling</span></CodeLine>
<CodeLine><span class="doxyHighlight">&#96;llvm&#95;blake3&#95;hasher&#95;init&#96; or similar again. However, if this implementation gains</span></CodeLine>
<CodeLine><span class="doxyHighlight">multithreading support in the future, and if &#96;llvm&#95;blake3&#95;hasher&#96; holds (optional)</span></CodeLine>
<CodeLine><span class="doxyHighlight">threading resources, this function will reuse those resources.</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight"># Building</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">This implementation is just C and assembly files.</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">## x86</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">Dynamic dispatch is enabled by default on x86. The implementation will</span></CodeLine>
<CodeLine><span class="doxyHighlight">query the CPU at runtime to detect SIMD support, and it will use the</span></CodeLine>
<CodeLine><span class="doxyHighlight">widest instruction set available. By default, &#96;blake3&#95;dispatch.c&#96;</span></CodeLine>
<CodeLine><span class="doxyHighlight">expects to be linked with code for five different instruction sets:</span></CodeLine>
<CodeLine><span class="doxyHighlight">portable C, SSE2, SSE4.1, AVX2, and AVX-512.</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">For each of the x86 SIMD instruction sets, four versions are available:</span></CodeLine>
<CodeLine><span class="doxyHighlight">three flavors of assembly (Unix, Windows MSVC, and Windows GNU) and one</span></CodeLine>
<CodeLine><span class="doxyHighlight">version using C intrinsics. The assembly versions are generally</span></CodeLine>
<CodeLine><span class="doxyHighlight">preferred. They perform better, they perform more consistently across</span></CodeLine>
<CodeLine><span class="doxyHighlight">different compilers, and they build more quickly. On the other hand, the</span></CodeLine>
<CodeLine><span class="doxyHighlight">assembly versions are x86\\&#95;64-only, and you need to select the right</span></CodeLine>
<CodeLine><span class="doxyHighlight">flavor for your target platform.</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">## ARM NEON</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">The NEON implementation is enabled by default on AArch64, but not on</span></CodeLine>
<CodeLine><span class="doxyHighlight">other ARM targets, since not all of them support it. To enable it, set</span></CodeLine>
<CodeLine><span class="doxyHighlight">&#96;BLAKE3&#95;USE&#95;NEON=1&#96;.</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">To explicitiy disable using NEON instructions on AArch64, set</span></CodeLine>
<CodeLine><span class="doxyHighlight">&#96;BLAKE3&#95;USE&#95;NEON=0&#96;.</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">## Other Platforms</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">The portable implementation should work on most other architectures.</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight"># Multithreading</span></CodeLine>
<CodeLine></CodeLine>
<CodeLine><span class="doxyHighlight">The implementation doesn&#39;t currently support multithreading.</span></CodeLine>

</ProgramListing>


</DoxygenPage>
